//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class VerticalDoor : SectorMover;

int			Type;
float		TopHeight;
float		Speed;
int			Direction;	// 1 = up, 0 = waiting, -1 = down
float		TopWait;	// time to wait at the top
float		TopTime;	// (keep in case a door going down is reset)
						// when it reaches 0, start going down

float		BotDist;
float		OldFloorDist;

TVec		BotSpot;

int			LightTag;

//==========================================================================
//
//	Init
//
//==========================================================================

void Init(sector_t* InSector, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int InType)
{
	float		Height;
	TVec		Spot;

	Sector = InSector;
	Sector->CeilingData = self;

	Type = InType;
	Speed = itof(Arg2) * 35.0 / 8.0;
	TopWait = itof(Arg3) / 35.0;
	switch (Type)
	{
	case DOOREV_Close:
		Height = FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		Direction = -1;
		if (Speed >= 256.0)
		{
			SectorStartSoundName(Sector, 'doors/dr2_clos', CHAN_VOICE);
		}
		else
		{
			SectorStartSoundName(Sector, 'doors/dr1_clos', CHAN_VOICE);
		}
		break;

	case DOOREV_CloseWaitOpen:
		LightTag = Arg4;
		TopHeight = Sector->ceiling.dist;
		TopWait *= 4.0;
		Direction = -1;
		if (Speed >= 256.0)
		{
			SectorStartSoundName(Sector, 'doors/dr2_clos', CHAN_VOICE);
		}
		else
		{
			SectorStartSoundName(Sector, 'doors/dr1_clos', CHAN_VOICE);
		}
		break;

	case DOOREV_Raise:
	case DOOREV_RaiseLocked:
	case DOOREV_Open:
		//	Get light tag depending on type.
		if (Type == DOOREV_Open)
		{
			LightTag = Arg3;
		}
		else if (Type == DOOREV_Raise)
		{
			LightTag = Arg4;
		}
		else
		{
			LightTag = Arg5;
			Type = DOOREV_Raise;
		}

		//HACK delay 0 means open
		if (Type == DOOREV_Raise && !Arg3)
		{
			Type = DOOREV_Open;
		}
		Height = FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		Direction = 1;
		if (TopHeight != Sector->ceiling.dist)
		{
			// for proper sound
			if (Speed >= 256.0)
			{
				// BLAZING DOOR
				SectorStartSoundName(Sector, 'doors/dr2_open', CHAN_VOICE);
			}
			else
			{
				// NORMAL DOOR SOUND
				SectorStartSoundName(Sector, 'doors/dr1_open', CHAN_VOICE);
			}
		}
		break;

	case DOOREV_RaiseIn5Mins:
		Direction = 2;
		Height = FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		TopTime = 5.0 * 60.0;
		break;
	}

	Height = FindHighestFloorPoint(Sector, &BotSpot);
	BotDist = DotProduct(vector(BotSpot.x, BotSpot.y, Height),
		Sector->ceiling.normal);
	OldFloorDist = Sector->floor.dist;
}

//==========================================================================
//
//  InitCloseIn30
//
//  Spawn a door that closes after 30 seconds
//
//==========================================================================

void InitCloseIn30(sector_t* InSector)
{
	float		Height;

	Sector = InSector;
	Sector->CeilingData = self;

	Direction = 0;
	Type = DOOREV_Raise;
	Speed = 70.0;
	TopTime = 30.0;
	Height = FindHighestFloorPoint(Sector, &BotSpot);
	BotDist = DotProduct(vector(BotSpot.x, BotSpot.y, Height),
		Sector->ceiling.normal);
	OldFloorDist = Sector->floor.dist;
	TopHeight = Sector->ceiling.dist;
	LightTag = 0;
}

//==========================================================================
//
//	ReUse
//
//==========================================================================

bool ReUse(int InType, line_t* Line, Actor Thing)
{
	if (InType == DOOREV_Raise && Type == DOOREV_Raise)
	{
		// ONLY FOR "RAISE" DOORS, NOT "OPEN"s
		if (Direction == -1)
		{
			Direction = 1;	// go back up
			return true;
		}
		else if (GET_SPAC(Line->flags) != SPAC_PUSH)
		// [RH] activate push doors don't go back down when you
		//		run into them (otherwise opening them would be
		//		a real pain).
		{
			if (!Thing || !Thing.bIsPlayer || Thing.Player.bIsBot)
			{
				return false;	// JDC: bad guys never close doors
			}
			Direction = -1;	// start going down immediately
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	int			res;

	if (Sector->floor.dist != OldFloorDist)
	{
		OldFloorDist = Sector->floor.dist;
		BotDist = DotProduct(Sector->ceiling.normal, vector(BotSpot.x,
			BotSpot.y, GetPlanePointZ(&Sector->floor, BotSpot)));
	}

	switch (Direction)
	{
	case 0:
		// WAITING
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
		{
			TopTime = 0.0;
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = -1;	// time to go back down
				if (Speed >= 256.0)
				{
					SectorStartSoundName(Sector, 'doors/dr2_clos',
						CHAN_VOICE);
				}
				else
				{
					SectorStartSoundName(Sector, 'doors/dr1_clos', CHAN_VOICE);
				}
				break;

			case DOOREV_CloseWaitOpen:
				Direction = 1;
				SectorStartSoundName(Sector, 'doors/dr1_open', CHAN_VOICE);
				break;
			default:
				break;
			}
		}
		break;

	case 2:
		//  INITIAL WAIT
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
		{
			TopTime = 0.0;
			switch (Type)
			{
			case DOOREV_RaiseIn5Mins:
				Direction = 1;
				Type = DOOREV_Raise;
				SectorStartSoundName(Sector, 'doors/dr1_open', CHAN_VOICE);
				break;

			default:
				break;
			}
		}
		break;

	case -1:
		// DOWN
		res = MovePlane(Sector, Speed * deltaTime, BotDist, false, 1,
			Direction, false);

		// killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -Sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (Sector->ceiling.dist +
				Sector->floor.dist) / (TopHeight + Sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			switch (Type)
			{
			case DOOREV_Raise:
			case DOOREV_Close:
				if (Speed >= 256.0)
				{
					SectorStartSoundName(Sector, 'doors/dr2_clos',
						CHAN_VOICE);
				}
				Finished();
				break;

			case DOOREV_CloseWaitOpen:
				Direction = 0;
				TopTime = TopWait;
				break;
			default:
				break;
			}
		}
		else if (res == RES_CRUSHED)
		{
			switch (Type)
			{
			case DOOREV_Close:	// DO NOT GO BACK UP!
				break;

			default:
				Direction = 1;
				SectorStartSoundName(Sector, 'doors/dr1_open', CHAN_VOICE);
				break;
			}
		}
		break;

	case 1:
		// UP
		res = MovePlane(Sector, Speed * deltaTime, TopHeight, false, 1,
			Direction, false);

		//	killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -Sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (Sector->ceiling.dist +
				Sector->floor.dist) / (TopHeight + Sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = 0;	// wait at top
				TopTime = TopWait;
				break;

			case DOOREV_CloseWaitOpen:
			case DOOREV_Open:
				Finished();	// unlink and free
				break;

			default:
				break;
			}
		}
		break;
	}
}

defaultproperties
{
}

//**************************************************************************
//
//  $Log$
//  Revision 1.4  2005/11/17 23:05:22  dj_jl
//  Renamed sounds.
//
//  Revision 1.3  2005/03/01 14:39:31  dj_jl
//  Big update of line specials.
//
//  Revision 1.2  2005/01/25 17:45:11  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.1  2002/10/26 16:32:19  dj_jl
//  New style of defining classes.
//
//**************************************************************************
