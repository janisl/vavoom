//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Special thinker utilites.
//**
//**************************************************************************

// HEADER FILES ------------------------------------------------------------

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------

// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------

// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------

// EXTERNAL DATA DECLARATIONS ----------------------------------------------

// PUBLIC DATA DEFINITIONS -------------------------------------------------

// PRIVATE DATA DEFINITIONS ------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  getNextSector
//
//  Return sector_t * of sector next to current. NULL if not two-sided line
//
//==========================================================================

sector_t *getNextSector(line_t * line, sector_t * sec)
{
	if (!(line->flags & ML_TWOSIDED))
		return NULL;

	if (line->frontsector == sec)
		return line->backsector;

	return line->frontsector;
}

//==========================================================================
//
//  FindLowestFloorSurrounding
//
//  FIND LOWEST FLOOR HEIGHT IN SURROUNDING SECTORS
//
//==========================================================================

float FindLowestFloorSurrounding(sector_t * sec)
{
	int i;
	line_t *check;
	sector_t *other;
	float floor = sec->floor.minz;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		other = getNextSector(check, sec);

		if (!other)
			continue;

		if (other->floor.minz < floor)
			floor = other->floor.minz;
	}
	return floor;
}

//==========================================================================
//
//  FindHighestFloorSurrounding
//
//  FIND HIGHEST FLOOR HEIGHT IN SURROUNDING SECTORS
//
//==========================================================================

float FindHighestFloorSurrounding(sector_t * sec)
{
	int i;
	line_t *check;
	sector_t *other;
	float floor = -500.0;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		other = getNextSector(check, sec);

		if (!other)
			continue;

		if (other->floor.maxz > floor)
			floor = other->floor.maxz;
	}
	return floor;
}

//==========================================================================
//
//  FindNextHighestFloor
//
//  FIND NEXT HIGHEST FLOOR IN SURROUNDING SECTORS
//  Note: this should be doable w/o a fixed array.
//
//==========================================================================

float FindNextHighestFloor(sector_t * sec, float currentheight)
{
	// 20 adjoining sectors max!
#define MAX_ADJOINING_SECTORS    	20

	int i;
	int h;
	float min;
	line_t *check;
	sector_t *other;
	float height = currentheight;
	float heightlist[MAX_ADJOINING_SECTORS];

	for (i = 0, h = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		other = getNextSector(check, sec);

		if (!other)
			continue;

		if (other->floor.minz > height)
			heightlist[h++] = other->floor.minz;

		// Check for overflow. Exit.
		if (h >= MAX_ADJOINING_SECTORS)
		{
			dprint("Sector with more than 20 adjoining sectors");
			break;
		}
	}

	// Find lowest height in list
	if (!h)
		return currentheight;

	min = heightlist[0];

	// Range checking? 
	for (i = 1; i < h; i++)
		if (heightlist[i] < min)
			min = heightlist[i];

	return min;
}

//==========================================================================
//
//  FindLowestCeilingSurrounding
//
//  FIND LOWEST CEILING IN THE SURROUNDING SECTORS
//
//==========================================================================

float FindLowestCeilingSurrounding(sector_t * sec)
{
	int i;
	line_t *check;
	sector_t *other;
	float height = 99999.0;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		other = getNextSector(check, sec);

		if (!other)
			continue;

		if (other->ceiling.minz < height)
			height = other->ceiling.minz;
	}
	return height;
}

//==========================================================================
//
//  FindHighestCeilingSurrounding
//
//  FIND HIGHEST CEILING IN THE SURROUNDING SECTORS
//
//==========================================================================

float FindHighestCeilingSurrounding(sector_t * sec)
{
	int i;
	line_t *check;
	sector_t *other;
	float height = 0.0;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		other = getNextSector(check, sec);

		if (!other)
			continue;

		if (other->ceiling.maxz > height)
			height = other->ceiling.maxz;
	}
	return height;
}

//==========================================================================
//
//  FindMinSurroundingLight
//
//  Find minimum light from an adjacent sector
//
//==========================================================================

int FindMinSurroundingLight(sector_t * sector, int max)
{
	int i;
	int min;
	line_t *line;
	sector_t *check;

	min = max;
	for (i = 0; i < sector->linecount; i++)
	{
		line = sector->lines[i];
		check = getNextSector(line, sector);

		if (!check)
			continue;

		if (check->params.lightlevel < min)
			min = check->params.lightlevel;
	}
	return min;
}

//==========================================================================
//
//  FindSectorFromTag
//
//  RETURN NEXT SECTOR # THAT LINE TAG REFERS TO
//
//==========================================================================

int FindSectorFromTag(int tag, int start)
{
	int i;

	for (i = start + 1; i < GLevel.NumSectors; i++)
		if (GLevel.Sectors[i].tag == tag)
			return i;

	return -1;
}

//**************************************************************************
//
//  MOVE FLOOR/CEILING
//
//**************************************************************************

//==========================================================================
//
//  T_MovePlane
//
//  Move a plane (floor or ceiling) and check for crushing
//
//==========================================================================

int T_MovePlane(sector_t * sector, float amount, float dest,
	int crush, int floorOrCeiling, int direction)
{
	bool flag;
	float lastpos;

	switch (floorOrCeiling)
	{
	case 0:
		// FLOOR
		amount *= sector->floor.normal.z;
		dest *= sector->floor.normal.z;
		switch (direction)
		{
		case -1:
			// DOWN
			if (sector->floor.dist - amount < dest)
			{
				lastpos = sector->floor.dist;
				sector->floor.dist = dest;
				flag = P_ChangeSector(sector, crush);
				if (flag)
				{
					sector->floor.dist = lastpos;
					P_ChangeSector(sector, crush);
				}
				return RES_PASTDEST;
			}
			else
			{
				lastpos = sector->floor.dist;
				sector->floor.dist -= amount;
				flag = P_ChangeSector(sector, crush);
				if (flag)
				{
					sector->floor.dist = lastpos;
					P_ChangeSector(sector, crush);
					return RES_CRUSHED;
				}
			}
			break;

		case 1:
			// UP
			if (sector->floor.dist + amount > dest)
			{
				lastpos = sector->floor.dist;
				sector->floor.dist = dest;
				flag = P_ChangeSector(sector, crush);
				if (flag)
				{
					sector->floor.dist = lastpos;
					P_ChangeSector(sector, crush);
				}
				return RES_PASTDEST;
			}
			else
			{
				// COULD GET CRUSHED
				lastpos = sector->floor.dist;
				sector->floor.dist += amount;
				flag = P_ChangeSector(sector, crush);
				if (flag)
				{
					if (!crush)
					{
						sector->floor.dist = lastpos;
						P_ChangeSector(sector, crush);
					}
					return RES_CRUSHED;
				}
			}
			break;
		}
		break;

	case 1:
		// CEILING
		amount *= sector->ceiling.normal.z;
		dest *= sector->ceiling.normal.z;
		switch (direction)
		{
		case -1:
			// DOWN
			if (sector->ceiling.dist - amount > dest)
			{
				lastpos = sector->ceiling.dist;
				sector->ceiling.dist = dest;
				flag = P_ChangeSector(sector, crush);

				if (flag)
				{
					sector->ceiling.dist = lastpos;
					P_ChangeSector(sector, crush);
				}
				return RES_PASTDEST;
			}
			else
			{
				// COULD GET CRUSHED
				lastpos = sector->ceiling.dist;
				sector->ceiling.dist -= amount;
				flag = P_ChangeSector(sector, crush);

				if (flag)
				{
					if (!crush)
					{
						sector->ceiling.dist = lastpos;
						P_ChangeSector(sector, crush);
					}
					return RES_CRUSHED;
				}
			}
			break;

		case 1:
			// UP
			if (sector->ceiling.dist + amount < dest)
			{
				lastpos = sector->ceiling.dist;
				sector->ceiling.dist = dest;
				flag = P_ChangeSector(sector, crush);
				if (flag)
				{
					sector->ceiling.dist = lastpos;
					P_ChangeSector(sector, crush);
				}
				return RES_PASTDEST;
			}
			else
			{
				lastpos = sector->ceiling.dist;
				sector->ceiling.dist += amount;
				flag = P_ChangeSector(sector, crush);
			}
			break;
		}
		break;
	}
	return RES_OK;
}

//==========================================================================
//
//	TagBusy
//
//==========================================================================

bool TagBusy(int tag)
{
	int sectorIndex;

	sectorIndex = -1;
	while ((sectorIndex = FindSectorFromTag(tag, sectorIndex)) >= 0)
	{
		if (GLevel.Sectors[sectorIndex].SpecialData)
		{
			return true;
		}
	}
	return false;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.9  2002/09/07 16:28:25  dj_jl
//  Added Level class.
//
//  Revision 1.8  2002/07/23 16:31:44  dj_jl
//  Beautification.
//
//  Revision 1.7  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.6  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.5  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
