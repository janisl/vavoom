//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// ===== Polyobj Event Code =====

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	PODOOR_NONE,
	PODOOR_SLIDE,
	PODOOR_SWING
};

// TYPES -------------------------------------------------------------------

class PolyobjThinker;

addfields polyobj_t
{
	PolyobjThinker SpecialData;	// pointer a thinker, if the poly is moving
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================

bool EV_RotatePoly(line_t * line, int *args, int direction, bool overRide)
{
	int mirror;
	int polyNum;
	PolyobjRotator pe;
	polyobj_t *poly;

	polyNum = args[0];
	poly = GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(PolyobjRotator);
	pe.polyobj = polyNum;
	if (args[2])
	{
		if (args[2] == 255)
		{
			pe.dist = -1.0;
		}
		else
		{
			pe.dist = itof(args[2]) * (90.0 / 64.0);	// Angle
		}
	}
	else
	{
		pe.dist = 360.0;
	}
	pe.speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) * 90.0 / 64.0 / 8.0);

	//THRUST
	pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

	poly->SpecialData = pe;
	PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));

	for (mirror = GetPolyobjMirror(polyNum); mirror;
		mirror = GetPolyobjMirror(polyNum))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(PolyobjRotator);
		poly->SpecialData = pe;
		pe.polyobj = mirror;
		if (args[2])
		{
			if (args[2] == 255)
			{
				pe.dist = -1.0;
			}
			else
			{
				pe.dist = itof(args[2]) * (90.0 / 64.0);	// Angle
			}
		}
		else
		{
			pe.dist = 360.0;
		}
		poly = GetPolyobj(polyNum);
		if (poly)
		{
			poly->SpecialData = pe;
		}
		else
		{
			Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
		}
		direction = -direction;
		pe.speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) *
			90.0 / 64.0 / 8.0);

		//THRUST
		pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

		polyNum = mirror;
		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	return true;
}

//==========================================================================
//
// EV_MovePoly
//
//==========================================================================

bool EV_MovePoly(line_t * line, int *args, bool timesEight, bool overRide)
{
	int mirror;
	int polyNum;
	PolyobjMover pe;
	polyobj_t *poly;
	float an;

	polyNum = args[0];
	poly = GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_MovePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(PolyobjMover);
	pe.polyobj = polyNum;
	if (timesEight)
	{
		pe.dist = itof(args[3]) * 8.0;
	}
	else
	{
		pe.dist = itof(args[3]);	// Distance
	}
	pe.speed = itof(args[1]) * 4.0;

	//THRUST
	pe.thrust_force = pe.speed / 8.0;

	poly->SpecialData = pe;

	an = itof(args[2]) * (90.0 / 64.0);

	pe.angle = an;
	PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));

	for (mirror = GetPolyobjMirror(polyNum); mirror;
		mirror = GetPolyobjMirror(polyNum))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(PolyobjMover);
		pe.polyobj = mirror;
		poly->SpecialData = pe;
		if (timesEight)
		{
			pe.dist = itof(args[3]) * 8.0;
		}
		else
		{
			pe.dist = itof(args[3]);	// Distance
		}
		pe.speed = itof(args[1]) * 4.0;

		//THRUST
		pe.thrust_force = pe.speed / 8.0;

		an = AngleMod360(an + 180.0);	// reverse the angle
		pe.angle = an;
		polyNum = mirror;
		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	return true;
}

//==========================================================================
//
// EV_OpenPolyDoor
//
//==========================================================================

bool EV_OpenPolyDoor(line_t * line, int *args, int type)
{
	int mirror;
	int polyNum;
	PolyobjDoor pd;
	polyobj_t *poly;
	float an = 0.0;

	polyNum = args[0];
	poly = GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_OpenPolyDoor:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pd = NewSpecialThinker(PolyobjDoor);
	pd.type = type;
	pd.polyobj = polyNum;
	if (type == PODOOR_SLIDE)
	{
		pd.waitTime = itof(args[4]) / 35.0;
		pd.speed = itof(args[1]) * 4.0;
		pd.totalDist = itof(args[3]);	// Distance
		pd.dist = pd.totalDist;
		an = itof(args[2]) * (90.0 / 64.0);
		pd.xSpeed = cos(an);
		pd.ySpeed = sin(an);

		//THRUST
		pd.thrust_force = pd.speed / 8.0;

		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	else if (type == PODOOR_SWING)
	{
		pd.waitTime = itof(args[3]) / 35.0;
		pd.speed = AngleMod180(4.0 * itof(args[1]) * (90.0 / 64.0));
		pd.totalDist = itof(args[2]) * (90.0 / 64.0);
		pd.dist = pd.totalDist;

		//THRUST
		pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}

	poly->SpecialData = pd;

	for (mirror = GetPolyobjMirror(polyNum); mirror;
		mirror = GetPolyobjMirror(polyNum))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData)
		{	// mirroring poly is already in motion
			break;
		}
		pd = NewSpecialThinker(PolyobjDoor);
		pd.polyobj = mirror;
		pd.type = type;
		poly->SpecialData = pd;
		if (type == PODOOR_SLIDE)
		{
			pd.waitTime = itof(args[4]) / 35.0;
			pd.speed = itof(args[1]) * 4.0;
			pd.totalDist = itof(args[3]);	// Distance
			pd.dist = pd.totalDist;
			an = AngleMod360(an + 180.0);	// reverse the angle
			pd.xSpeed = cos(an);
			pd.ySpeed = sin(an);

			//THRUST
			pd.thrust_force = pd.speed / 8.0;

			PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
		}
		else if (type == PODOOR_SWING)
		{
			pd.waitTime = itof(args[3]) / 35.0;
			pd.speed = AngleMod180(4.0 * itof(-args[1]) * (90.0 / 64.0));
			pd.totalDist = itof(args[2]) * (90.0 / 64.0);
			pd.dist = pd.totalDist;

			//THRUST
			pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

			PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
		}
		polyNum = mirror;
	}
	return true;
}

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(Actor A, TVec thrustDir, polyobj_t * po)
{
	float force;
	PolyobjThinker pe;

	if (!A.bShootable && !A.bIsPlayer)
	{
		return;
	}

	pe = po->SpecialData;
	if (pe)
	{
		force = pe.thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 128.0)
		{
			force = 128.0;
		}
	}
	else
	{
		force = 1.0;
	}

	A.Velocity += force * thrustDir;
	if (po->bCrush)
	{
		TVec testPos;

		testPos = A.Origin + force * thrustDir * frametime;
		if (!A.CheckPosition(testPos))
		{
			A.Damage(none, none, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

bool PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = GetPolyobj(polyobj);
	if (!poly->SpecialData)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.16  2005/11/24 20:30:57  dj_jl
//  Beautification.
//
//  Revision 1.15  2002/10/26 16:32:24  dj_jl
//  New style of defining classes.
//
//  Revision 1.14  2002/09/07 16:28:25  dj_jl
//  Added Level class.
//
//  Revision 1.13  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.12  2002/03/20 19:07:46  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.11  2002/03/16 17:36:38  dj_jl
//  Changed to use CheckPosition since object is not moving yet.
//
//  Revision 1.10  2002/03/02 17:41:13  dj_jl
//  Renamed Enemy to Target. Beautification.
//
//  Revision 1.9  2002/02/22 18:00:18  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.8  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.7  2002/02/07 18:50:08  dj_jl
//  Made CheckPosition shared.
//
//  Revision 1.6  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.5  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.4  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.3  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.2  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.1  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.8  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.7  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.4  2001/09/24 17:18:15  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
