//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	SCROLLEV_Side,
	SCROLLEV_Floor,
	SCROLLEV_Ceiling,
	SCROLLEV_Carry
};

enum
{
	PUSHER_Push,
	PUSHER_Pull,
	PUSHER_Wind,
	PUSHER_Current
};

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  SpawnScrollingFloor
//
//==========================================================================

void SpawnScrollingFloor(sector_t* Sector, int XDir, int YDir, int Speed)
{
	Scroller	Scroll;

	Scroll = NewSpecialThinker(Scroller);
	Scroll.InitFloor(Sector, XDir, YDir, Speed);
}

//==========================================================================
//
//  SpawnWallScroller
//
//==========================================================================

void SpawnWallScroller(line_t* Line, int XDir, int YDir)
{
	Scroller	Scroll;

	Scroll = NewSpecialThinker(Scroller);
	Scroll.InitWall(Line, XDir, YDir);
}

//==========================================================================
//
//  SpawnWallOffsetsScroller
//
//==========================================================================

void SpawnWallOffsetsScroller(line_t* Line)
{
	Scroller	Scroll;

	Scroll = NewSpecialThinker(Scroller);
	Scroll.InitWallOffsets(Line);
}

//==========================================================================
//
//  SpawnTextureBothScroller
//
//==========================================================================

void SpawnTextureBothScroller(line_t* Line)
{
	Scroller	Scroll;

	Scroll = NewSpecialThinker(Scroller);
	Scroll.InitTextureBoth(Line);
}

//==========================================================================
//
//  SpawnScrollCeiling
//
//==========================================================================

void SpawnScrollCeiling(line_t* Line)
{
	Scroller	Scroll;
	int			SecNum;

	for (SecNum = FindSectorFromTag(Line->arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Line->arg1, SecNum))
	{
		Scroll = NewSpecialThinker(Scroller);
		Scroll.InitGen(SCROLLEV_Ceiling, Line, SecNum);
	}
}

//==========================================================================
//
//  SpawnScrollFloor
//
//==========================================================================

void SpawnScrollFloor(line_t* Line)
{
	Scroller	Scroll;
	int			SecNum;

	for (SecNum = FindSectorFromTag(Line->arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Line->arg1, SecNum))
	{
		if (Line->arg3 != 1)
		{
			//	Scroll the floor texture
			Scroll = NewSpecialThinker(Scroller);
			Scroll.InitGen(SCROLLEV_Floor, Line, SecNum);
		}

		if (Line->arg3 > 0)
		{
			//	Carry objects on the floor
			Scroll = NewSpecialThinker(Scroller);
			Scroll.InitGen(SCROLLEV_Carry, Line, SecNum);
		}
	}
}

//==========================================================================
//
//  SpawnScrollTextureModel
//
//	Scroll wall according to linedef
// (same direction and speed as scrolling floors)
//
//==========================================================================

void SpawnScrollTextureModel(line_t* Line)
{
	Scroller	Scroll;
	int			Searcher;
	line_t*		Other;

	Searcher = -1;
	for (Other = P_FindLine(Line->arg1, &Searcher); Other;
		Other = P_FindLine(Line->arg1, &Searcher))
	{
		if (Line != Other)
		{
			Scroll = NewSpecialThinker(Scroller);
			Scroll.InitTextureModel(Other, Line);
		}
	}
}

//==========================================================================
//
//	PIT_PushThing
//
// PIT_PushThing determines the angle and magnitude of the effect.
// The object's x and y momentum values are changed.
//
// tmpusher belongs to the point source (MT_PUSH/MT_PULL).
//
//==========================================================================

class Pusher;

Pusher tmpusher; // pusher structure for blockmap searches

bool PIT_PushThing(Actor thing)
{
	float sx;
	float sy;
	float dist;
	float speed;
	float pushangle;

	if (thing.bWindThrust && thing.bColideWithWorld)
	{
		sx = tmpusher.X;
		sy = tmpusher.Y;
		dist = Length(vector(thing.Origin.x - sx, thing.Origin.y - sy, 0.0));
		speed = itof(tmpusher.Magnitude - (ftoi(dist) >> 1)) / (2.0 * tmpusher.PUSH_FACTOR);

		// If speed <= 0, you're outside the effective radius. You also have
		// to be able to see the push/pull source point.

		if ((speed > 0.0) && thing.CanSee(tmpusher.Source))
		{
			pushangle = atan2(sy - thing.Origin.y, sx - thing.Origin.x);
			if (PointPusher(tmpusher.Source))
				pushangle += 180.0;    // away
			thing.Velocity.x += speed * cos(pushangle) * 35.0 * frametime;
			thing.Velocity.y += speed * sin(pushangle) * 35.0 * frametime;
		}
	}
	return true;
}

//==========================================================================
//
//	P_GetPushThing
//
//	Returns a pointer to an MT_PUSH or MT_PULL thing, NULL otherwise.
//
//==========================================================================

Actor P_GetPushThing(int s)
{
	Actor		thing;
	sector_t*	sec;

	sec = &GLevel.Sectors[s];
	FOREACH(Actor, thing)
	{
		if (PointPusher(thing) || PointPuller(thing))
		{
			return thing;
		}
	}
	return none;
}

//==========================================================================
//
//	P_SpawnPushers
//
//	Initialise the sectors where pushers are present
//
//==========================================================================

void P_SpawnPushers()
{
	int			i;
	line_t*		l;
	int			s;
	Pusher		P;
	Actor		thing;
	int			searcher;

	for (i = 0; i < GLevel.NumLines; i++)
	{
		l = &GLevel.Lines[i];
		switch (l->special)
		{
		case LNSPEC_SectorSetWind: // wind
			for (s = FindSectorFromTag(l->arg1, -1); s >= 0; s = FindSectorFromTag(l->arg1, s))
			{
				P = Pusher(NewSpecialThinker(Pusher));
				P.Init(PUSHER_Wind, l->arg4 ? l : NULL, l->arg2, l->arg3, none, s);
			}
			break;

		case LNSPEC_SectorSetCurrent: // current
			for (s = FindSectorFromTag(l->arg1, -1); s >= 0; s = FindSectorFromTag(l->arg1, s))
			{
				P = Pusher(NewSpecialThinker(Pusher));
				P.Init(PUSHER_Current, l->arg4 ? l : NULL, l->arg2, l->arg3, none, s);
			}
			break;

		case LNSPEC_PointPushSetForce: // push/pull
			if (l->arg1)
			{
				// [RH] Find thing by sector
				for (s = FindSectorFromTag(l->arg1, -1); s >= 0;
					s = FindSectorFromTag(l->arg1, s))
				{
					thing = P_GetPushThing(s);
					if (thing)
					{
						// No MT_P* means no effect
						// [RH] Allow narrowing it down by tid
						if (!l->arg2 || l->arg2 == thing.TID)
						{
							P = Pusher(NewSpecialThinker(Pusher));
							P.Init(PUSHER_Push, l->arg4 ? l : NULL, l->arg3,
								0, thing, s);
						}
					}
				}
			}
			else
			{
				// [RH] Find thing by tid
				searcher = -1;
				for (thing = Actor(FindMobjFromTID(l->arg2, &searcher)); thing;
					thing = Actor(FindMobjFromTID(l->arg2, &searcher)))
				{
					if (PointPuller(thing) || PointPusher(thing))
					{
						for (s = 0; s < GLevel.NumSectors; s++)
							if (&GLevel.Sectors[s] == thing.Sector)
								break;
						P = Pusher(NewSpecialThinker(Pusher));
						P.Init(PUSHER_Push, l->arg4 ? l : NULL, l->arg3, 0,
							thing, s);
					}
				}
			}
			break;
		}
	}
}

//==========================================================================
//
//	AdjustPusher
//
//==========================================================================

bool AdjustPusher(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, int Type)
{
	int		tag;
	int		magnitude;
	int		angle;
	Pusher	Collection;
	Pusher	P;
	int		secnum;

	if (Line || Arg4)
	{
		return false;
	}
	tag = Arg1;
	magnitude = Arg2;
	angle = Arg3;
	Collection = none;
	// Find pushers already attached to the sector, and change their parameters.
	FOREACH(Pusher, P)
	{
		if (P.CheckForSectorMatch(Type, tag) >= 0)
		{
			P.ChangeValues(magnitude, angle);
			P.AdjustLink = Collection;
			Collection = P;
		}
	}

	// Now create pushers for any sectors that don't already have them.
	for (secnum = FindSectorFromTag(tag, -1); secnum >= 0;
		secnum = FindSectorFromTag(tag, secnum))
	{
		for (P = Collection; P; P = P.AdjustLink)
		{
			if (P.Affectee == secnum)
				break;
		}
		if (!P)
		{
			P = Pusher(NewSpecialThinker(Pusher));
			P.Init(Type, NULL, magnitude, angle, none, secnum);
		}
	}
	return true;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2005/06/04 13:48:47  dj_jl
//  Added pusher specials.
//
//  Revision 1.4  2005/03/28 07:43:30  dj_jl
//  Some Boom line specials and other improvements.
//
//  Revision 1.3  2005/03/16 15:04:22  dj_jl
//  More work on line specials.
//
//  Revision 1.2  2005/03/01 14:39:32  dj_jl
//  Big update of line specials.
//
//  Revision 1.1  2004/11/22 07:36:27  dj_jl
//  Implemented all sector specials in all games.
//
//**************************************************************************
