//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class MenuSList : MenuChoice;

int			Cursor;
slist_t*	slist;

void InitWindow()
{
	::InitWindow();
	StartSearch();
}

void DrawTextBox(GC gc, string text)
{
	int x;
	int y;
	int w;
	int h;

	// Horiz. & Vertically center string and print it.
	T_SetFont(font_small);
	T_SetAlign(hcenter, vcenter);

	w = (T_TextWidth(text) + 16) & ~15;
	h = (T_TextHeight(text) + 16) & ~15;
	if (w > 304)
		w = 304;
	if (h > 184)
		h = 184;
	x = (320 - w) / 2;
	y = (200 - h) / 2;

	R_FillRectWithFlat(x, y, w, h, 'floor04');
	GetClGame().DrawBorder(x, y, w, h);

	gc.DrawText(160, 100, text);
}

void DrawWindow(GC gc)
{
	int i;
	int x;
	int y;
	int w;

	slist = GetSlist();

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	for (i = 0; i < slist->Count; i++)
	{
		gc.DrawText(16, 32 + 10 * i, slist->Cache[i].Name);
		gc.DrawText(16 + 128, 32 + 10 * i, slist->Cache[i].Map);
		if (slist->Cache[i].MaxUsers)
		{
			gc.DrawText(16 + 256, 32 + 10 * i, va("%d/%d",
				slist->Cache[i].Users, slist->Cache[i].MaxUsers));
		}
	}
	gc.DrawText(8, 32 + Cursor * 10, ">");

	if (slist->ReturnReason)
		gc.DrawText(16, 116, slist->ReturnReason);

	if (slist->Count)
	{
		x = 8;
		y = 124;
		for (i = 0; i < 20 && slist->Cache[Cursor].WadFiles[i]; i++)
		{
			w = T_TextWidth(slist->Cache[Cursor].WadFiles[i]);
			if (x + w > 312)
			{
				x = 8;
				y += 9;
				if (y > 190)
					break;
			}
			gc.DrawText(x, y, slist->Cache[Cursor].WadFiles[i]);
			x += w + 8;
		}
	}

	if (slist->bInProgress)
	{
		DrawTextBox(gc, "Searching...");
	}
	else if (!slist->Count)
	{
		DrawTextBox(gc, "No servers found");
	}
}

bool Key(int key)
{
	slist = GetSlist();

	if (slist->bInProgress)
	{
		return true;
	}

	switch (key)
	{
	case K_DOWNARROW:
		if (slist->Count)
		{
			Cursor++;
			if (Cursor >= slist->Count)
				Cursor = 0;
			LocalSound('menu/cursor');
		}
		return true;

	case K_UPARROW:
		if (slist->Count)
		{
			Cursor--;
			if (Cursor < 0)
				Cursor = slist->Count - 1;
			LocalSound('menu/cursor');
		}
		return true;

	case K_ENTER:
	case K_PADENTER:
		if (slist->Count)
		{
			LocalSound('menu/choose');
			CmdBuf_AddText("connect \"%s\"\n", slist->Cache[Cursor].CName);
		}
		return true;

	case K_SPACE:
		Cursor = 0;
		StartSearch();
		return true;
	}
	return false;
}

defaultproperties
{
}
