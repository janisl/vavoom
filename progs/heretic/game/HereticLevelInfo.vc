//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class HereticLevelInfo : LineSpecialLevelInfo;

const int MAX_BOSS_SPOTS	= 8;

const int MAX_MACE_SPOTS	= 8;

const int BODYQUESIZE		= 32;

const int
	MTF_EASY		= 0x0001,	// Skill flags.
	MTF_NORMAL		= 0x0002,
	MTF_HARD		= 0x0004,
	MTF_AMBUSH		= 0x0008,	// Deaf monsters/do not react to sound.
	MTF_DORMANT		= 0x0010,	// The thing is dormant
	MTF_FIGHTER		= 0x0020,	// Thing appearing in player classes
	MTF_CLERIC		= 0x0040,
	MTF_MAGE		= 0x0080,
	MTF_GSINGLE		= 0x0100,	// Appearing in game modes
	MTF_GCOOP		= 0x0200,
	MTF_GDEATHMATCH	= 0x0400;

const int
	STROBEBRIGHT	= 5,
	FASTDARK		= 15,
	SLOWDARK		= 35;

Actor GLavaInflictor;

Actor bodyque[BODYQUESIZE];
int bodyqueslot;

int BossSpotCount;
TVec BossSpot[MAX_BOSS_SPOTS];
float BossSpot_angle[MAX_BOSS_SPOTS];

int MaceSpotCount;
float MaceSpot_x[MAX_MACE_SPOTS];
float MaceSpot_y[MAX_MACE_SPOTS];

//==========================================================================
//
//  SpawnSpecials
//
//==========================================================================

void SpawnSpecials()
{
	sector_t *sector;
	int i;

	InitLava();
	CloseWeapons();

	//
	//  Init special SECTORs
	//
	for (i = 0; i < XLevel.NumSectors; i++)
	{
		sector = &XLevel.Sectors[i];
		if (!sector->special)
			continue;
		if (sector->special & SECSPEC_SECRET_MASK)
		{
			//	Secret sector.
			Game.level->totalsecret++;
		}
		switch (sector->special & SECSPEC_BASE_MASK)
		{
		case SECSPEC_LightPhased:
			//	Hardcoded base, use sector->lightlevel as the index
			SpawnPhasedLight(sector, 80, -1);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_LightSequenceStart:
			SpawnLightSequence(sector, 1.0);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
			// Specials 3 & 4 are used by the phased light sequences
		case SECSPEC_LightFlicker:
			SpawnLightFlash(sector);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_LightStrobeFast:
			SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_LightStrobeSlow:
			SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 0);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_LightStrobeFastDamage:
			SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
			break;
		case SECSPEC_LightGlow:
			SpawnGlowingLight(sector);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_DoorCloseIn30:
			SpawnDoorCloseIn30(sector);
			break;
		case SECSPEC_LightSyncStrobeSlow:
			SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 1);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_LightSyncStrobeFast:
			SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 1);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_DoorRaiseIn5Minutes:
			SpawnDoorRaiseIn5Mins(sector);
			break;
		case SECSPEC_LightFireFlicker:
			SpawnFireFlicker(sector);
			sector->special &= ~SECSPEC_BASE_MASK;
			break;
		case SECSPEC_ScrollEastLavaDamage:
			SpawnScrollingFloor(sector, -1, 0, 3);
			break;
		case SECSPEC_ScrollNorthSlow:
		case SECSPEC_ScrollNorthMedium:
		case SECSPEC_ScrollNorthFast:
			SpawnScrollingFloor(sector, 0, 1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthSlow);
			break;
		case SECSPEC_ScrollEastSlow:
		case SECSPEC_ScrollEastMedium:
		case SECSPEC_ScrollEastFast:
			SpawnScrollingFloor(sector, -1, 0, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollEastSlow);
			break;
		case SECSPEC_ScrollSouthSlow:
		case SECSPEC_ScrollSouthMedium:
		case SECSPEC_ScrollSouthFast:
			SpawnScrollingFloor(sector, 0, -1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthSlow);
			break;
		case SECSPEC_ScrollWestSlow:
		case SECSPEC_ScrollWestMedium:
		case SECSPEC_ScrollWestFast:
			SpawnScrollingFloor(sector, 1, 0, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollWestSlow);
			break;
		case SECSPEC_ScrollNorthWestSlow:
		case SECSPEC_ScrollNorthWestMedium:
		case SECSPEC_ScrollNorthWestFast:
			SpawnScrollingFloor(sector, 1, 1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthWestSlow);
			break;
		case SECSPEC_ScrollNorthEastSlow:
		case SECSPEC_ScrollNorthEastMedium:
		case SECSPEC_ScrollNorthEastFast:
			SpawnScrollingFloor(sector, -1, 1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthEastSlow);
			break;
		case SECSPEC_ScrollSouthEastSlow:
		case SECSPEC_ScrollSouthEastMedium:
		case SECSPEC_ScrollSouthEastFast:
			SpawnScrollingFloor(sector, -1, -1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthEastSlow);
			break;
		case SECSPEC_ScrollSouthWestSlow:
		case SECSPEC_ScrollSouthWestMedium:
		case SECSPEC_ScrollSouthWestFast:
			SpawnScrollingFloor(sector, 1, -1, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthWestSlow);
			break;
		case SECSPEC_ScrollEast5:
		case SECSPEC_ScrollEast10:
		case SECSPEC_ScrollEast25:
		case SECSPEC_ScrollEast30:
		case SECSPEC_ScrollEast35:
			SpawnScrollingFloor(sector, -1, 0, (sector->special &
				SECSPEC_BASE_MASK) - SECSPEC_ScrollEast5);
			break;
		}
	}

	//
	//  Init line EFFECTs
	//
	for (i = 0; i < XLevel.NumLines; i++)
	{
		switch (XLevel.Lines[i].special)
		{
		case LNSPEC_ScrollTextureLeft:
			SpawnWallScroller(&XLevel.Lines[i], 1, 0);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureRight:
			SpawnWallScroller(&XLevel.Lines[i], -1, 0);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureUp:
			SpawnWallScroller(&XLevel.Lines[i], 0, 1);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureDown:
			SpawnWallScroller(&XLevel.Lines[i], 0, -1);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureBoth:
			SpawnTextureBothScroller(&XLevel.Lines[i]);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureModel:
			SpawnScrollTextureModel(&XLevel.Lines[i]);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollFloor:
			SpawnScrollFloor(&XLevel.Lines[i]);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollCeiling:
			SpawnScrollCeiling(&XLevel.Lines[i]);
			XLevel.Lines[i].special = 0;
			break;
		case LNSPEC_ScrollTextureOffsets:
			SpawnWallOffsetsScroller(&XLevel.Lines[i]);
			XLevel.Lines[i].special = 0;
			break;
		}
	}
	P_SpawnPushers();

	CreateTIDList();
}

//==========================================================================
//
//  FindLine
//
//==========================================================================

line_t* FindLine(int lineTag, int *searchPosition)
{
	int i;

	for (i = *searchPosition + 1; i < MainGameInfo(Game).TaggedLineCount; i++)
	{
		if (MainGameInfo(Game).TaggedLines[i].lineTag == lineTag)
		{
			*searchPosition = i;
			return MainGameInfo(Game).TaggedLines[i].line;
		}
	}
	*searchPosition = -1;
	return NULL;
}

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(Entity A, TVec thrustDir, polyobj_t * po)
{
	float force;
	PolyobjThinker pe;

	if (!Actor(A).bShootable && !A.bIsPlayer)
	{
		return;
	}

	pe = PolyobjThinker(po->SpecialData);
	if (pe)
	{
		force = pe.thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 128.0)
		{
			force = 128.0;
		}
	}
	else
	{
		force = 1.0;
	}

	A.Velocity += force * thrustDir;
	if (po->bCrush)
	{
		TVec testPos;

		testPos = A.Origin + force * thrustDir * Game.frametime;
		if (!A.CheckPosition(testPos))
		{
			Actor(A).Damage(none, none, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

bool PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = XLevel.GetPolyobj(polyobj);
	if (!poly->SpecialData)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//==========================================================================
//
//	ThingCount
//
//==========================================================================

int ThingCount(int type, int tid)
{
	int count;
	int searcher;
	Actor Ent;
	classid moType;

	if (!(type + tid))
	{
		// Nothing to count
		return 0;
	}
	moType = FindClassFromScriptId(type);
	count = 0;
	searcher = -1;
	if (tid)
	{
		// Count TID things
		for (Ent = Actor(FindMobjFromTID(tid, &searcher)); Ent != none;
			Ent = Actor(FindMobjFromTID(tid, &searcher)))
		{
			if (type == 0)
			{
				// Just count TIDs
				count++;
			}
			else if (moType == Ent.Class)
			{
				if (Ent.bCountKill && Ent.Health <= 0)
				{
					// Don't count dead monsters
					continue;
				}
				count++;
			}
		}
	}
	else
	{
		// Count only types
		FOREACH(Actor, Ent)
		{
			if (Ent.Class != moType)
			{
				// Doesn't match
				continue;
			}
			if (Ent.bCountKill && Ent.Health <= 0)
			{
				// Don't count dead monsters
				continue;
			}
			count++;
		}
	}
	return count;
}

//==========================================================================
//
//  SetSectorGravity
//
//==========================================================================

void SetSectorGravity(int tag, float integer, float fraction)
{
	int SecNum;
	float gravity;

	if (fraction > 99.0)
		fraction = 99.0;

	gravity = integer + fraction * 0.01;

	for (SecNum = XLevel.FindSectorFromTag(tag, -1);
		SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(tag, SecNum))
		XLevel.Sectors[SecNum].Gravity = gravity;
}

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;
	Actor A;

	A = Actor(E);
	buttonSuccess = false;
	switch (Special)
	{
	case LNSPEC_PolyStartLine:
		break;
	case LNSPEC_PolyRotateLeft:
		buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1,
			false);
		break;
	case LNSPEC_PolyRotateRight:
		buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, -1,
			false);
		break;
	case LNSPEC_PolyMove:
		buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			false, false);
		break;
	case LNSPEC_PolyExplicitLine: // Only used in initialization
		break;
	case LNSPEC_PolyMoveTimes8:
		buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			true, false);
		break;
	case LNSPEC_PolyDoorSwing:
		buttonSuccess = EV_OpenPolyDoor(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			PODOOR_SWING);
		break;
	case LNSPEC_PolyDoorSlide:
		buttonSuccess = EV_OpenPolyDoor(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			PODOOR_SLIDE);
		break;
	case LNSPEC_PillarBuild: // (no crushing)
		buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, false);
		break;
	case LNSPEC_PillarOpen:
		buttonSuccess = EV_OpenPillar(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_ForceField:
		buttonSuccess = EV_ForceField(Arg1, Arg2, Arg3, Arg4, Arg5, A);
		break;
	case LNSPEC_ClearForceField:
		buttonSuccess = EV_RemoveForceField(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportZombieChanger:
		if (Side == 0)
		{
			//	Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line,
				true);
			A.SetState(A.PainState);
		}
		break;
	case LNSPEC_Teleport:
		if (Side == 0)
		{
			// Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line,
				true);
		}
		break;
	case LNSPEC_TeleportNoFog:
		if (Side == 0)
		{
			// Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line,
				false);
		}
		break;
	case LNSPEC_ThingThrust:
		if (!Side) // Only thrust on side 0
		{
			A.Thrust(itof(Arg1) * (90.0 / 64.0), itof(Arg2));
			buttonSuccess = 1;
		}
		break;
	case LNSPEC_ThingDamage:
		if (Arg1)
		{
			A.Damage(none, none, Arg1);
		}
		else
		{
			// If arg1 is zero, then guarantee a kill
			A.Damage(none, none, 10000);
		}
		buttonSuccess = 1;
		break;
	case LNSPEC_TeleportNewMap:
		if (Side == 0)
		{
			// Only teleport when crossing the front side of a line
			// Players must be alive to teleport
			if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD))
			{
				G_Completed(Arg1, Arg2, Arg3);
				buttonSuccess = true;
			}
		}
		break;
	case LNSPEC_TeleportEndGame:
		if (Side == 0)
		{
			// Only teleport when crossing the front side of a line
			// Players must be alive to teleport
			if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD))
			{
				buttonSuccess = true;
				if (Level.Game.deathmatch)
				{
					// Winning in deathmatch just goes back to map 1
					G_Completed(1, 0, 0);
				}
				else
				{
					// Passing -1, -1 to G_Completed() starts the Finale
					G_Completed(-1, -1, 0);
				}
			}
		}
		break;
	case LNSPEC_TeleportOther:
		buttonSuccess = EV_TeleportOther(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportGroup:
		buttonSuccess = EV_TeleportGroup(Arg1, Arg2, Arg3, Arg4, Arg5, A);
		break;
	case LNSPEC_TeleportSector:
		buttonSuccess = EV_TeleportSector(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_ACSExecute:
		buttonSuccess = StartACS(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, Side,
			false, false);
		break;
	case LNSPEC_ACSSuspend:
		buttonSuccess = SuspendACS(Arg1, Arg2);
		break;
	case LNSPEC_ACSTerminate:
		buttonSuccess = TerminateACS(Arg1, Arg2);
		break;
	case LNSPEC_ACSLockedExecute:
		buttonSuccess = StartLockedACS(Line, Arg1, Arg2, Arg3, Arg4, Arg5, A,
			Side);
		break;
	case LNSPEC_ACSExecuteWithResult:
		buttonSuccess = StartACS(Arg1, 0, Arg2, Arg3, Arg4, A, Line, Side,
			true, true);
		break;
	case LNSPEC_PolyRotateLeftOverride:
		buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1,
			true);
		break;
	case LNSPEC_PolyRotateRightOverride:
		buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, -1,
			true);
		break;
	case LNSPEC_PolyMoveOverride:
		buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			false, true);
		break;
	case LNSPEC_PolyMoveTimes8Override:
		buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5,
			true, true);
		break;
	case LNSPEC_PillarBuildCrush:
		buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, true);
		break;
	case LNSPEC_FloorAndCeilingLowerByValue:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Lower, Line);
		break;
	case LNSPEC_FloorAndCeilingRaiseByValue:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Raise, Line);
		break;
	case LNSPEC_LightForceLightning:
		buttonSuccess = true;
		P_ForceLightning();
		break;
	case LNSPEC_LightRaiseByValue:
		buttonSuccess = EV_LightRaiseByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightLowerByValue:
		buttonSuccess = EV_LightLowerByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightChangeToValue:
		buttonSuccess = EV_LightChangeToValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightFade:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Fade);
		break;
	case LNSPEC_LightGlow:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Glow);
		break;
	case LNSPEC_LightFlicker:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Flicker);
		break;
	case LNSPEC_LightStrobe:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Strobe);
		break;
	case LNSPEC_LightStop:
		buttonSuccess = EV_LightStop(Arg1);
		break;
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
/*	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(Arg1, Arg2, Arg3, Arg4,
			Arg5, A);
		break;*/
	case LNSPEC_ThingActivate:
		buttonSuccess = EV_ThingActivate(Arg1);
		break;
	case LNSPEC_ThingDeactivate:
		buttonSuccess = EV_ThingDeactivate(Arg1);
		break;
	case LNSPEC_ThingRemove:
		buttonSuccess = EV_ThingRemove(Arg1);
		break;
	case LNSPEC_ThingDestroy:
		buttonSuccess = EV_ThingDestroy(Arg1);
		break;
	case LNSPEC_ThingProjectile:
		buttonSuccess = EV_ThingProjectile(Arg1, Arg2, Arg3, Arg4, Arg5, 0, 0);
		break;
	case LNSPEC_ThingSpawn:
		buttonSuccess = EV_ThingSpawn(Arg1, Arg2, Arg3, Arg4, Arg5, 1);
		break;
	case LNSPEC_ThingProjectileGravity:
		buttonSuccess = EV_ThingProjectile(Arg1, Arg2, Arg3, Arg4, Arg5, 1, 0);
		break;
	case LNSPEC_ThingSpawnNoFog:
		buttonSuccess = EV_ThingSpawn(Arg1, Arg2, Arg3, Arg4, Arg5, 0);
		break;
	case LNSPEC_SectorSoundChange:
		buttonSuccess = EV_SectorSoundChange(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_NoiseAlert:
		buttonSuccess = EV_NoiseAlert(A, Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_SectorSetDamage:
		buttonSuccess = EV_SectorSetDamage(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportLine:
		buttonSuccess = EV_SilentLineTeleport(Line, Side, A, Arg2, Arg3);
		break;
	case LNSPEC_SectorSetWind:
		buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, Line,
			PUSHER_Wind);
		break;
	case LNSPEC_SectorSetFriction:
		MainGameInfo(Game).SetSectorFriction(XLevel, Arg1, Arg2, true);
		buttonSuccess = true;
		break;
	case LNSPEC_SectorSetCurrent:
		buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, Line,
			PUSHER_Current);
		break;
	case LNSPEC_SectorSetGravity:
		SetSectorGravity(Arg1, itof(Arg2), itof(Arg3));
		buttonSuccess = true;
		break;
	case LNSPEC_ACSExecuteAlways:
		buttonSuccess = StartACS(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, Side,
			true, false);
		break;
	case LNSPEC_LightStrobeDoom:
		buttonSuccess = EV_StartLightStrobing(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightMinNeighbor:
		buttonSuccess = EV_TurnTagLightsOff(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightMaxNeighbor:
		buttonSuccess = EV_TagLightTurnOn(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorTransferTrigger:
		buttonSuccess = EV_FloorTransferTrigger(Arg1, Arg2, Arg3, Arg4, Arg5,
			Line);
		break;
	case LNSPEC_FloorTransferNumeric:
		buttonSuccess = EV_FloorTransferNumeric(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_ExitNormal:
		buttonSuccess = true;
		G_ExitLevel(Arg1);
		break;
	case LNSPEC_ExitSecret:
		buttonSuccess = true;
		G_SecretExitLevel(Arg1);
		break;
	case LNSPEC_ElevatorRaiseToNearest:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Up, Line);
		break;
	case LNSPEC_ElevatorMoveToFloor:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Current, Line);
		break;
	case LNSPEC_ElevatorLowerToNearest:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Down, Line);
		break;

	// Line specials only processed during level initialization
	// LNSPEC_ScrollTextureLeft:
	// LNSPEC_ScrollTextureRight:
	// LNSPEC_ScrollTextureUp:
	// LNSPEC_ScrollTextureDown:
	// LNSPEC_LineSetIdentification:
	// LNSPEC_3DFloor:
	// LNSPEC_Contents:
	// LNSPEC_PlaneAlign:
	// LNSPEC_LineTranslucent:
	// LNSPEC_TransferHeights:
	// LNSPEC_ScrollTextureBoth:
	// LNSPEC_ScrollTextureModel:
	// LNSPEC_ScrollFloor:
	// LNSPEC_ScrollCeiling:
	// LNSPEC_ScrollTextureOffsets:
	// LNSPEC_PointPushSetForce:

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, Actor A)
{
	int lineActivation;
	bool noway;

	noway = true;
	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
			case LNSPEC_PlatDownWaitUpStay:
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
			case 206://Plat_DownWaitUpStayLip:
			case LNSPEC_TeleportLine:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
				if (line->arg1 == 0)
					noway = false;
				break;
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
				noway = false;
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//==========================================================================
//
//  ActivateLine
//
//==========================================================================

bool ActivateLine(line_t* Line, Actor A, int Side, int ActivationType)
{
	int lineActivation;
	bool repeat;
	bool buttonSuccess;

	if (!CheckActivation(ActivationType, Line, A))
	{
		return false;
	}

	lineActivation = GET_SPAC(Line->flags);
	if (lineActivation == SPAC_PTOUCH)
	{
		lineActivation = ActivationType;
	}
	repeat = Line->flags & ML_REPEAT_SPECIAL;
	buttonSuccess = ExecuteActionSpecial(Line->special, Line->arg1,
		Line->arg2, Line->arg3, Line->arg4, Line->arg5, Line, Side, A);

	if ((lineActivation == SPAC_USE || lineActivation == SPAC_IMPACT ||
		lineActivation == SPAC_USETHROUGH) && buttonSuccess)
	{
		P_ChangeSwitchTexture(Line, repeat,
			Line->special == LNSPEC_ExitNormal ||
			Line->special == LNSPEC_ExitSecret ||
			Line->special == LNSPEC_TeleportNewMap ||
			Line->special == LNSPEC_TeleportEndGame
			? 'switches/exitbutn' : 'switches/normbutn');
	}
	if (!repeat && buttonSuccess)
	{
		// clear the special on non-retriggerable lines
		Line->special = 0;
	}
	return true;
}

//==========================================================================
//
//  StartPlaneWatcher
//
//==========================================================================

void StartPlaneWatcher(Entity it, line_t* line, int lineSide, bool ceiling,
	int tag, int height, int special, int arg0, int arg1, int arg2, int arg3,
	int arg4)
{
	PlaneWatcher	PW;

	PW = PlaneWatcher(NewSpecialThinker(PlaneWatcher));
	PW.Start(Actor(it), line, lineSide, ceiling, tag, height, special, arg0, arg1,
		arg2, arg3, arg4);
}

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Entity user, int lock)
{
	if (!user.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}
	if (!(Player(user.Player).Keys & (1 << (lock - 1))))
	{
		user.Player.centreprint(MainGameInfo(Game).keymsg[lock - 1]);
		user.PlaySound('*usefail', CHAN_VOICE);
		return false;
	}
	return true;
}

//==========================================================================
//==========================================================================
//
//                              EVENTS
//
//  Events are operations triggered by using, crossing, or shooting special
// lines, or by timed thinkers
//
//==========================================================================
//==========================================================================

//==========================================================================
//
//  StartLockedACS
//
//==========================================================================

bool StartLockedACS(line_t* Line, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, Actor A, int Side)
{
	if (!CheckLock(A, Arg5))
	{
		return false;
	}
	return StartACS(Arg1, Arg2, Arg3, Arg4, 0, A, Line, Side, false, false);
}

//=========================================================================
//
// EV_SectorSoundChange
//
//=========================================================================

bool EV_SectorSoundChange(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int secNum;
	bool rtn;

	if (!Arg1)
	{
		return false;
	}
	rtn = false;
	for (secNum = XLevel.FindSectorFromTag(Arg1, -1); secNum >= 0;
		secNum = XLevel.FindSectorFromTag(Arg1, secNum))
	{
		XLevel.Sectors[secNum].seqType = Arg2;
		rtn = true;
	}
	return rtn;
}

//=========================================================================
//
//	EV_SectorSetDamage
//
//=========================================================================

bool EV_SectorSetDamage(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int		SecNum;
	bool	Rtn;

	if (!Arg1)
	{
		return false;
	}
	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		XLevel.Sectors[SecNum].Damage = Arg2;
		//FIXME Arg3 is MOD
		Rtn = true;
	}
	return Rtn;
}

//==========================================================================
//
//  EV_NoiseAlert
//
//==========================================================================

bool EV_NoiseAlert(Actor A, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	Actor	ASource;
	Actor	ATarget;
	int		Search;

	if (!Arg1)
	{
		ASource = A;
	}
	else
	{
		Search = -1;
		ASource = Actor(FindMobjFromTID(Arg1, &Search));
	}

	if (!Arg2)
	{
		ATarget = A;
	}
	else
	{
		Search = -1;
		ATarget = Actor(FindMobjFromTID(Arg2, &Search));
	}

	NoiseAlert(ASource, ATarget);
	return true;
}

//==========================================================================
//
//  EV_ForceField
//
//==========================================================================

bool EV_ForceField(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Actor A)
{
	A.Damage(none, none, 10);
	A.Velocity.x += 5.0 * cos(A.Angles.yaw + 180.0) * 35.0;
	A.Velocity.y += 5.0 * sin(A.Angles.yaw + 180.0) * 35.0;

	return true;
}

//==========================================================================
//
//  EV_RemoveForceField
//
//==========================================================================

bool EV_RemoveForceField(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int i;
	int secnum;
	sector_t *sec;
	line_t *secline;

	for (secnum = XLevel.FindSectorFromTag(Arg1, -1); secnum >= 0;
		secnum = XLevel.FindSectorFromTag(Arg1, secnum))
	{
		sec = &XLevel.Sectors[secnum];
		for (i = 0; i < sec->linecount; i++)
		{
			secline = sec->lines[i];
			if (secline->special != LNSPEC_ForceField)
				continue;
			if (!(secline->flags & ML_TWOSIDED))
				continue;

			XLevel.SetLineTexture(secline->sidenum[0], 1, 0);
			XLevel.SetLineTexture(secline->sidenum[1], 1, 0);
			secline->special = 0;
			secline->flags &= ~ML_BLOCKING;
		}
	}
	return true;
}

//**************************************************************************
//
//  PILLAR
//
//**************************************************************************

//==========================================================================
//
//	EV_BuildPillar
//
//==========================================================================

int EV_BuildPillar(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	bool Crush)
{
	int			SecNum;
	sector_t*	Sec;
	Pillar		pillar;
	int			Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		if (Sec->FloorData || Sec->CeilingData)
			continue;	// already moving
		Rtn = true;
		pillar = Pillar(NewSpecialThinker(Pillar));
		pillar.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Crush);
	}
	return Rtn;
}

//==========================================================================
//
//	EV_OpenPillar
//
//==========================================================================

int EV_OpenPillar(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	Pillar		pillar;
	int			Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		if (Sec->FloorData || Sec->CeilingData)
			continue;	// already moving
		Rtn = true;
		pillar = Pillar(NewSpecialThinker(Pillar));
		pillar.InitOpen(Sec, Arg1, Arg2, Arg3, Arg4, Arg5);
	}
	return Rtn;
}

//==========================================================================
//
//	EV_FloorTransferTrigger
//
//==========================================================================

bool EV_FloorTransferTrigger(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, line_t* Line)
{
	int			SecNum;
	bool		Rtn;
	sector_t*	Sec;

	if (!Line)
	{
		return false;
	}

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Rtn = true;

		Sec->floor.pic = Line->frontsector->floor.pic;
		Sec->special = (Sec->special & SECSPEC_SECRET_MASK) |
			(Line->frontsector->special & ~SECSPEC_SECRET_MASK);
	}
	return Rtn;
}

//==========================================================================
//
//	EV_FloorTransferNumeric
//
//==========================================================================

bool EV_FloorTransferNumeric(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5)
{
	int			SecNum;
	bool		Rtn;
	sector_t*	Sec;
	sector_t*	MdlSec;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Rtn = true;

		MdlSec = FindModelFloorSector(Sec, GetPlanePointZ(&Sec->floor,
			Sec->soundorg));
		if (MdlSec)
		{
			Sec->floor.pic = MdlSec->floor.pic;
			Sec->special = MdlSec->special;
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_DoElevator
//
//==========================================================================

int EV_DoElevator(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;
	Elevator	Elev;

	if (!Line && (Type == ELEVEV_Current))
	{
		return false;
	}

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];

		//	Skip if already busy.
		if (Sec->FloorData || Sec->CeilingData)
			continue;

		//	New elevator thinker
		Rtn = true;
		Elev = Elevator(NewSpecialThinker(Elevator));
		Elev.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
	}
	return Rtn;
}

// ===== Polyobj Event Code =====

//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================

bool EV_RotatePoly(line_t * line, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int direction, bool overRide)
{
	int mirror;
	int polyNum;
	PolyobjRotator pe;
	polyobj_t *poly;

	polyNum = Arg1;
	poly = XLevel.GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = PolyobjRotator(NewSpecialThinker(PolyobjRotator));
	pe.polyobj = polyNum;
	if (Arg3)
	{
		if (Arg3 == 255)
		{
			pe.dist = -1.0;
		}
		else
		{
			pe.dist = itof(Arg3) * (90.0 / 64.0);	// Angle
		}
	}
	else
	{
		pe.dist = 360.0;
	}
	pe.speed = AngleMod180(32.0 * itof(Arg2) * itof(direction) * 90.0 / 64.0 / 8.0);

	//THRUST
	pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

	poly->SpecialData = pe;
	PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

	for (mirror = XLevel.GetPolyobjMirror(polyNum); mirror;
		mirror = XLevel.GetPolyobjMirror(polyNum))
	{
		poly = XLevel.GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = PolyobjRotator(NewSpecialThinker(PolyobjRotator));
		poly->SpecialData = pe;
		pe.polyobj = mirror;
		if (Arg3)
		{
			if (Arg3 == 255)
			{
				pe.dist = -1.0;
			}
			else
			{
				pe.dist = itof(Arg3) * (90.0 / 64.0);	// Angle
			}
		}
		else
		{
			pe.dist = 360.0;
		}
		poly = XLevel.GetPolyobj(polyNum);
		if (poly)
		{
			poly->SpecialData = pe;
		}
		else
		{
			Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
		}
		direction = -direction;
		pe.speed = AngleMod180(32.0 * itof(Arg2) * itof(direction) *
			90.0 / 64.0 / 8.0);

		//THRUST
		pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

		polyNum = mirror;
		PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
	}
	return true;
}

//==========================================================================
//
// EV_MovePoly
//
//==========================================================================

bool EV_MovePoly(line_t * line, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, bool timesEight, bool overRide)
{
	int mirror;
	int polyNum;
	PolyobjMover pe;
	polyobj_t *poly;
	float an;

	polyNum = Arg1;
	poly = XLevel.GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_MovePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = PolyobjMover(NewSpecialThinker(PolyobjMover));
	pe.polyobj = polyNum;
	if (timesEight)
	{
		pe.dist = itof(Arg4) * 8.0;
	}
	else
	{
		pe.dist = itof(Arg4);	// Distance
	}
	pe.speed = itof(Arg2) * 4.0;

	//THRUST
	pe.thrust_force = pe.speed / 8.0;

	poly->SpecialData = pe;

	an = itof(Arg3) * (90.0 / 64.0);

	pe.angle = an;
	PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

	for (mirror = XLevel.GetPolyobjMirror(polyNum); mirror;
		mirror = XLevel.GetPolyobjMirror(polyNum))
	{
		poly = XLevel.GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = PolyobjMover(NewSpecialThinker(PolyobjMover));
		pe.polyobj = mirror;
		poly->SpecialData = pe;
		if (timesEight)
		{
			pe.dist = itof(Arg4) * 8.0;
		}
		else
		{
			pe.dist = itof(Arg4);	// Distance
		}
		pe.speed = itof(Arg2) * 4.0;

		//THRUST
		pe.thrust_force = pe.speed / 8.0;

		an = AngleMod360(an + 180.0);	// reverse the angle
		pe.angle = an;
		polyNum = mirror;
		PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
	}
	return true;
}

//==========================================================================
//
// EV_OpenPolyDoor
//
//==========================================================================

bool EV_OpenPolyDoor(line_t * line, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int type)
{
	int mirror;
	int polyNum;
	PolyobjDoor pd;
	polyobj_t *poly;
	float an = 0.0;

	polyNum = Arg1;
	poly = XLevel.GetPolyobj(polyNum);
	if (poly)
	{
		if (poly->SpecialData)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_OpenPolyDoor:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pd = PolyobjDoor(NewSpecialThinker(PolyobjDoor));
	pd.type = type;
	pd.polyobj = polyNum;
	if (type == PODOOR_SLIDE)
	{
		pd.waitTime = itof(Arg5) / 35.0;
		pd.speed = itof(Arg2) * 4.0;
		pd.totalDist = itof(Arg4);	// Distance
		pd.dist = pd.totalDist;
		an = itof(Arg3) * (90.0 / 64.0);
		pd.xSpeed = cos(an);
		pd.ySpeed = sin(an);

		//THRUST
		pd.thrust_force = pd.speed / 8.0;

		PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
	}
	else if (type == PODOOR_SWING)
	{
		pd.waitTime = itof(Arg4) / 35.0;
		pd.speed = AngleMod180(4.0 * itof(Arg2) * (90.0 / 64.0));
		pd.totalDist = itof(Arg3) * (90.0 / 64.0);
		pd.dist = pd.totalDist;

		//THRUST
		pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

		PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
	}

	poly->SpecialData = pd;

	for (mirror = XLevel.GetPolyobjMirror(polyNum); mirror;
		mirror = XLevel.GetPolyobjMirror(polyNum))
	{
		poly = XLevel.GetPolyobj(mirror);
		if (poly && poly->SpecialData)
		{	// mirroring poly is already in motion
			break;
		}
		pd = PolyobjDoor(NewSpecialThinker(PolyobjDoor));
		pd.polyobj = mirror;
		pd.type = type;
		poly->SpecialData = pd;
		if (type == PODOOR_SLIDE)
		{
			pd.waitTime = itof(Arg5) / 35.0;
			pd.speed = itof(Arg2) * 4.0;
			pd.totalDist = itof(Arg4);	// Distance
			pd.dist = pd.totalDist;
			an = AngleMod360(an + 180.0);	// reverse the angle
			pd.xSpeed = cos(an);
			pd.ySpeed = sin(an);

			//THRUST
			pd.thrust_force = pd.speed / 8.0;

			PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
		}
		else if (type == PODOOR_SWING)
		{
			pd.waitTime = itof(Arg4) / 35.0;
			pd.speed = AngleMod180(4.0 * itof(-Arg2) * (90.0 / 64.0));
			pd.totalDist = itof(Arg3) * (90.0 / 64.0);
			pd.dist = pd.totalDist;

			//THRUST
			pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

			PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
		}
		polyNum = mirror;
	}
	return true;
}

//==========================================================================
//
//  SpawnFireFlicker
//
//==========================================================================

void SpawnFireFlicker(sector_t* sector)
{
	FireFlicker Flick;

	Flick = FireFlicker(NewSpecialThinker(FireFlicker));
	Flick.Init(sector);
}

//==========================================================================
//
//  SpawnGlowingLight
//
//  Spawn glowing light
//
//==========================================================================

void SpawnGlowingLight(sector_t* sector)
{
	GlowingLight G;

	G = GlowingLight(NewSpecialThinker(GlowingLight));
	G.Init(sector);
}

//==========================================================================
//
//  SpawnLightFlash
//
//==========================================================================

void SpawnLightFlash(sector_t* sector)
{
	LightFlash Flash;

	Flash = LightFlash(NewSpecialThinker(LightFlash));
	Flash.Init(sector);
}

//**************************************************************************
//
//                          STROBE LIGHT FLASHING
//
//**************************************************************************

//==========================================================================
//
//  SpawnStrobeFlash
//
//==========================================================================

void SpawnStrobeFlash(sector_t* sector, int fastOrSlow, int maxtime,
	int inSync)
{
	Strobe Flash;

	Flash = Strobe(NewSpecialThinker(Strobe));
	Flash.Init(sector, fastOrSlow, maxtime, inSync);
}

//==========================================================================
//
//	SpawnPhasedLight
//
//==========================================================================

void SpawnPhasedLight(sector_t * sector, int base, int index)
{
	PhasedLight Phase;

	Phase = PhasedLight(NewSpecialThinker(PhasedLight));
	Phase.Init(sector, base, index);
}

//==========================================================================
//
//  SpawnLightSequence
//
//==========================================================================

void SpawnLightSequence(sector_t * sector, float indexStep)
{
	sector_t *sec;
	sector_t *nextSec;
	sector_t *tempSec;
	int seqSpecial;
	int i;
	float count;
	float index;
	float indexDelta;
	int base;

	seqSpecial = SECSPEC_LightSequence;	// look for Light_Sequence, first
	sec = sector;
	count = 1.0;
	do
	{
		nextSec = NULL;
		//	Make sure that the search doesn't back up.
		sec->special = (sec->special & ~SECSPEC_BASE_MASK) |
			SECSPEC_LightSequenceStart;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) == seqSpecial)
			{
				if (seqSpecial == SECSPEC_LightSequence)
				{
					seqSpecial = SECSPEC_LightSequenceAlt;
				}
				else
				{
					seqSpecial = SECSPEC_LightSequence;
				}
				nextSec = tempSec;
				count += 1.0;
			}
		}
		sec = nextSec;
	}
	while (sec);

	sec = sector;
	count *= indexStep;
	index = 0.0;
	indexDelta = 64.0 / count;
	base = sector->params.lightlevel;
	do
	{
		nextSec = NULL;
		if (sec->params.lightlevel)
		{
			base = sec->params.lightlevel;
		}
		SpawnPhasedLight(sec, base, ftoi(index));
		//	Clear sector special.
		sec->special &= ~SECSPEC_BASE_MASK;
		index += indexDelta;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) ==
				SECSPEC_LightSequenceStart)
			{
				nextSec = tempSec;
			}
		}
		sec = nextSec;
	}
	while (sec);
}

//==========================================================================
//
//  EV_StartLightStrobing
//
//  Start strobing lights (usually from a trigger)
//
//==========================================================================

int EV_StartLightStrobing(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			Ret;
	int			SecNum;
	sector_t*	Sec;
	Strobe		Flash;

	Ret = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		if (Sec->LightingData)
			continue;

		Ret = true;
		Flash = Strobe(NewSpecialThinker(Strobe));
		Flash.Init(Sec, Arg3, Arg2, Arg4);
	}
	return Ret;
}

//**************************************************************************
//
//  TURN LINE'S TAG LIGHTS ON / OFF
//
//**************************************************************************

//==========================================================================
//
//  EV_TagLightTurnOn
//
//==========================================================================

int EV_TagLightTurnOn(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	int			j;
	sector_t*	TSec;
	int			Max;

	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Max = 0;
		for (j = 0; j < Sec->linecount; j++)
		{
			TSec = getNextSector(Sec->lines[j], Sec);
			if (!TSec)
				continue;
			if (TSec->params.lightlevel > Max)
				Max = TSec->params.lightlevel;
		}
		Sec->params.lightlevel = Max;
	}
	return 1;
}

//==========================================================================
//
//  EV_TurnTagLightsOff
//
//==========================================================================

int EV_TurnTagLightsOff(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	int			i;
	int			Min;
	sector_t*	TSec;

	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Min = Sec->params.lightlevel;
		for (i = 0; i < Sec->linecount; i++)
		{
			TSec = getNextSector(Sec->lines[i], Sec);
			if (!TSec)
				continue;
			if (TSec->params.lightlevel < Min)
				Min = TSec->params.lightlevel;
		}
		Sec->params.lightlevel = Min;
	}
	return 1;
}

//============================================================================
//
//  EV_LightRaiseByValue
//
//============================================================================

bool EV_LightRaiseByValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Sec->params.lightlevel += Arg2;
		if (Sec->params.lightlevel > 255)
		{
			Sec->params.lightlevel = 255;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//  EV_LightLowerByValue
//
//============================================================================

bool EV_LightLowerByValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Sec->params.lightlevel -= Arg2;
		if (Sec->params.lightlevel < 0)
		{
			Sec->params.lightlevel = 0;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//	EV_LightChangeToValue
//
//============================================================================

bool EV_LightChangeToValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Sec->params.lightlevel = Arg2;
		if (Sec->params.lightlevel < 0)
		{
			Sec->params.lightlevel = 0;
		}
		else if (Sec->params.lightlevel > 255)
		{
			Sec->params.lightlevel = 255;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//  EV_SpawnLight
//
//============================================================================

bool EV_SpawnLight(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type)
{
	LightEffect	Light;
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];
		Light = LightEffect(NewSpecialThinker(LightEffect));
		Light.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		Rtn = true;
	}
	return Rtn;
}

//==========================================================================
//
//	EV_LightStop
//
//==========================================================================

bool EV_LightStop(int Tag)
{
	Lighting		L;

	FOREACH(Lighting, L)
	{
		if (L.Sector->tag == Tag)
		{
			if (L.Sector->LightingData == L)
				L.Sector->LightingData = none;
			RemoveSpecialThinker(L);
		}
	}
	return true;
}

//==========================================================================
//
//  SpawnScrollingFloor
//
//==========================================================================

void SpawnScrollingFloor(sector_t* Sector, int XDir, int YDir, int Speed)
{
	Scroller	Scroll;

	Scroll = Scroller(NewSpecialThinker(Scroller));
	Scroll.InitFloor(Sector, XDir, YDir, Speed);
}

//==========================================================================
//
//  SpawnWallScroller
//
//==========================================================================

void SpawnWallScroller(line_t* Line, int XDir, int YDir)
{
	Scroller	Scroll;

	Scroll = Scroller(NewSpecialThinker(Scroller));
	Scroll.InitWall(Line, XDir, YDir);
}

//==========================================================================
//
//  SpawnWallOffsetsScroller
//
//==========================================================================

void SpawnWallOffsetsScroller(line_t* Line)
{
	Scroller	Scroll;

	Scroll = Scroller(NewSpecialThinker(Scroller));
	Scroll.InitWallOffsets(Line);
}

//==========================================================================
//
//  SpawnTextureBothScroller
//
//==========================================================================

void SpawnTextureBothScroller(line_t* Line)
{
	Scroller	Scroll;

	Scroll = Scroller(NewSpecialThinker(Scroller));
	Scroll.InitTextureBoth(Line);
}

//==========================================================================
//
//  SpawnScrollCeiling
//
//==========================================================================

void SpawnScrollCeiling(line_t* Line)
{
	Scroller	Scroll;
	int			SecNum;

	for (SecNum = XLevel.FindSectorFromTag(Line->arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Line->arg1, SecNum))
	{
		Scroll = Scroller(NewSpecialThinker(Scroller));
		Scroll.InitGen(SCROLLEV_Ceiling, Line, SecNum);
	}
}

//==========================================================================
//
//  SpawnScrollFloor
//
//==========================================================================

void SpawnScrollFloor(line_t* Line)
{
	Scroller	Scroll;
	int			SecNum;

	for (SecNum = XLevel.FindSectorFromTag(Line->arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Line->arg1, SecNum))
	{
		if (Line->arg3 != 1)
		{
			//	Scroll the floor texture
			Scroll = Scroller(NewSpecialThinker(Scroller));
			Scroll.InitGen(SCROLLEV_Floor, Line, SecNum);
		}

		if (Line->arg3 > 0)
		{
			//	Carry objects on the floor
			Scroll = Scroller(NewSpecialThinker(Scroller));
			Scroll.InitGen(SCROLLEV_Carry, Line, SecNum);
		}
	}
}

//==========================================================================
//
//  SpawnScrollTextureModel
//
//	Scroll wall according to linedef
// (same direction and speed as scrolling floors)
//
//==========================================================================

void SpawnScrollTextureModel(line_t* Line)
{
	Scroller	Scroll;
	int			Searcher;
	line_t*		Other;

	Searcher = -1;
	for (Other = FindLine(Line->arg1, &Searcher); Other;
		Other = FindLine(Line->arg1, &Searcher))
	{
		if (Line != Other)
		{
			Scroll = Scroller(NewSpecialThinker(Scroller));
			Scroll.InitTextureModel(Other, Line);
		}
	}
}

//==========================================================================
//
//	P_GetPushThing
//
//	Returns a pointer to an MT_PUSH or MT_PULL thing, NULL otherwise.
//
//==========================================================================

Actor P_GetPushThing(int s)
{
	Actor		thing;
	sector_t*	sec;

	sec = &XLevel.Sectors[s];
	FOREACH(Actor, thing)
	{
		if (PointPusher(thing) || PointPuller(thing))
		{
			return thing;
		}
	}
	return none;
}

//==========================================================================
//
//	P_SpawnPushers
//
//	Initialise the sectors where pushers are present
//
//==========================================================================

void P_SpawnPushers()
{
	int			i;
	line_t*		l;
	int			s;
	Pusher		P;
	Actor		thing;
	int			searcher;

	for (i = 0; i < XLevel.NumLines; i++)
	{
		l = &XLevel.Lines[i];
		switch (l->special)
		{
		case LNSPEC_SectorSetWind: // wind
			for (s = XLevel.FindSectorFromTag(l->arg1, -1); s >= 0; s = XLevel.FindSectorFromTag(l->arg1, s))
			{
				P = Pusher(NewSpecialThinker(Pusher));
				P.Init(PUSHER_Wind, l->arg4 ? l : NULL, l->arg2, l->arg3, none, s);
			}
			break;

		case LNSPEC_SectorSetCurrent: // current
			for (s = XLevel.FindSectorFromTag(l->arg1, -1); s >= 0; s = XLevel.FindSectorFromTag(l->arg1, s))
			{
				P = Pusher(NewSpecialThinker(Pusher));
				P.Init(PUSHER_Current, l->arg4 ? l : NULL, l->arg2, l->arg3, none, s);
			}
			break;

		case LNSPEC_PointPushSetForce: // push/pull
			if (l->arg1)
			{
				// [RH] Find thing by sector
				for (s = XLevel.FindSectorFromTag(l->arg1, -1); s >= 0;
					s = XLevel.FindSectorFromTag(l->arg1, s))
				{
					thing = P_GetPushThing(s);
					if (thing)
					{
						// No MT_P* means no effect
						// [RH] Allow narrowing it down by tid
						if (!l->arg2 || l->arg2 == thing.TID)
						{
							P = Pusher(NewSpecialThinker(Pusher));
							P.Init(PUSHER_Push, l->arg4 ? l : NULL, l->arg3,
								0, thing, s);
						}
					}
				}
			}
			else
			{
				// [RH] Find thing by tid
				searcher = -1;
				for (thing = Actor(FindMobjFromTID(l->arg2, &searcher)); thing;
					thing = Actor(FindMobjFromTID(l->arg2, &searcher)))
				{
					if (PointPuller(thing) || PointPusher(thing))
					{
						for (s = 0; s < XLevel.NumSectors; s++)
							if (&XLevel.Sectors[s] == thing.Sector)
								break;
						P = Pusher(NewSpecialThinker(Pusher));
						P.Init(PUSHER_Push, l->arg4 ? l : NULL, l->arg3, 0,
							thing, s);
					}
				}
			}
			break;
		}
	}
}

//==========================================================================
//
//	AdjustPusher
//
//==========================================================================

bool AdjustPusher(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, int Type)
{
	int		tag;
	int		magnitude;
	int		angle;
	Pusher	Collection;
	Pusher	P;
	int		secnum;

	if (Line || Arg4)
	{
		return false;
	}
	tag = Arg1;
	magnitude = Arg2;
	angle = Arg3;
	Collection = none;
	// Find pushers already attached to the sector, and change their parameters.
	FOREACH(Pusher, P)
	{
		if (P.CheckForSectorMatch(Type, tag) >= 0)
		{
			P.ChangeValues(magnitude, angle);
			P.AdjustLink = Collection;
			Collection = P;
		}
	}

	// Now create pushers for any sectors that don't already have them.
	for (secnum = XLevel.FindSectorFromTag(tag, -1); secnum >= 0;
		secnum = XLevel.FindSectorFromTag(tag, secnum))
	{
		for (P = Collection; P; P = P.AdjustLink)
		{
			if (P.Affectee == secnum)
				break;
		}
		if (!P)
		{
			P = Pusher(NewSpecialThinker(Pusher));
			P.Init(Type, NULL, magnitude, angle, none, secnum);
		}
	}
	return true;
}

//==========================================================================
//
//	EV_Teleport
//
//==========================================================================

bool EV_Teleport(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	Actor thing, line_t* Line, bool fog)
{
	int			i;
	int			count;
	Actor		A;
	int			searcher;
	int			SecTag;
	int			SecNum;
	sector_t*	Sec;
	bool		SrcFog;
	bool		KeepOrient;
	TVec		DstOrg;
	float		Angle;
	TVec		OldVel;

	if (!thing)
	{
		// Teleport function called with an invalid mobj
		return false;
	}
	if (thing.bNoTeleport)
	{
		return false;
	}

	A = none;
	if (fog)
	{
		SecTag = Arg2;
		SrcFog = !Arg3;
		KeepOrient = false;
	}
	else
	{
		SecTag = Arg3;
		SrcFog = false;
		KeepOrient = !Arg2;
	}
	if (Arg1)
	{
		count = 0;
		searcher = -1;
		for (A = Actor(FindMobjFromTID(Arg1, &searcher)); A;
			A = Actor(FindMobjFromTID(Arg1, &searcher)))
		{
			if (SecTag == 0 || A.Sector->tag == SecTag)
			{
				count++;
			}
		}
		if (count == 0)
		{
			return false;
		}
		count = 1 + (P_Random() % count);
		searcher = -1;
		for (i = 0; i < count; i++)
		{
			do
			{
				A = Actor(FindMobjFromTID(Arg1, &searcher));
			}
			while (A && SecTag != 0 && A.Sector->tag != SecTag);
		}
	}
	else if (SecTag)
	{
		for (SecNum = XLevel.FindSectorFromTag(SecTag, -1); SecNum >= 0;
			SecNum = XLevel.FindSectorFromTag(SecTag, SecNum))
		{
			Sec = &XLevel.Sectors[SecNum];
			FOREACH(Actor, A)
			{
				if (!TeleportSpot(A))
				{
					//	Not a teleportman
					continue;
				}
				if (A.Sector != Sec)
				{
					//	Wrong sector
					continue;
				}
				break;
			}
			if (A)
			{
				break;
			}
		}
	}
	if (!A)
	{
		return false;
	}

	DstOrg = A.Origin;
	// Lee Killough's changes for silent teleporters from BOOM
	if (KeepOrient && Line)
	{
		// Get the angle between the exit thing and source linedef.
		// Rotate 180 degrees, so that walking perpendicularly across
		// teleporter linedef causes thing to exit in the direction
		// indicated by the exit thing.
		Angle = atan2(Line->normal.y, Line->normal.x) - A.Angles.yaw + 180.0;

		// Momentum of thing crossing teleporter linedef
		OldVel = thing.Velocity;
	}
	if (!TeleportSpot2(A))
	{
		DstOrg.z = Actor::ONFLOORZ;
	}
	if (thing.Teleport(DstOrg, A.Angles.yaw, fog, SrcFog, KeepOrient))
	{
		// Lee Killough's changes for silent teleporters from BOOM
		if (!fog && Line && KeepOrient)
		{
			// Rotate thing according to difference in angles
			thing.Angles.yaw = AngleMod360(thing.Angles.yaw + Angle);

			// Rotate thing's momentum to come out of exit just like it entered
			thing.Velocity.x = OldVel.x * cos(Angle) - OldVel.y * sin(Angle);
			thing.Velocity.y = OldVel.y * cos(Angle) + OldVel.x * sin(Angle);
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//	EV_TeleportOther
//
//	Teleport anything matching other_tid to dest_tid
//
//==========================================================================

bool EV_TeleportOther(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	bool		Ret;
	int			Searcher;
	Actor		A;

	Ret = false;
	if (Arg1 && Arg2)
	{
		Searcher = -1;
		for (A = Actor(FindMobjFromTID(Arg1, &Searcher)); A;
			A = Actor(FindMobjFromTID(Arg1, &Searcher)))
		{
			Ret |= EV_Teleport(Arg2, 0, 0, 0, 0, A, NULL, !!Arg3);
		}
	}
	return Ret;
}

//==========================================================================
//
//	DoGroupForOne
//
//==========================================================================

bool DoGroupForOne(Actor victim, Actor source, Actor dest, bool floorz,
	bool fog)
{
	float an = dest.Angles.yaw - source.Angles.yaw;
	float offX = victim.Origin.x - source.Origin.x;
	float offY = victim.Origin.y - source.Origin.y;
	float offAngle = victim.Angles.yaw - source.Angles.yaw;
	float newX = offX * cos(an) - offY * sin(an);
	float newY = offX * sin(an) + offY * cos(an);
	bool res;

	res = victim.Teleport(vector(dest.Origin.x + newX,
		dest.Origin.y + newY, floorz ? Actor::ONFLOORZ : dest.Origin.z +
		victim.Origin.z - source.Origin.z), 0.0, fog, fog, !fog);
	// P_Teleport only changes angle if fog is true
	victim.Angles.yaw = AngleMod360(dest.Angles.yaw + offAngle);

	return res;
}

//==========================================================================
//
//	EV_TeleportGroup
//
//	[RH] Teleport a group of actors centred around source_tid so
// that they become centred around dest_tid instead.
//
//==========================================================================

bool EV_TeleportGroup(int group_tid, int source_tid, int dest_tid,
	bool moveSource, bool fog, Actor victim)
{
	Actor		sourceOrigin;
	Actor		destOrigin;
	int			Searcher;
	bool		didSomething;
	bool		floorz;

	Searcher = -1;
	sourceOrigin = Actor(FindMobjFromTID(source_tid, &Searcher));
	if (!sourceOrigin)
	{
		//	If there is no source origin, behave like TeleportOther
		return EV_TeleportOther(group_tid, dest_tid, fog, 0, 0);
	}

	Searcher = -1;
	do
	{
		destOrigin = Actor(FindMobjFromTID(dest_tid, &Searcher));
	}
	while (destOrigin && !TeleportSpot(destOrigin));
	if (!destOrigin)
	{
		return false;
	}

	didSomething = false;
	floorz = !TeleportSpot2(destOrigin);

	// Use the passed victim if group_tid is 0
	if (group_tid == 0 && victim)
	{
		didSomething = DoGroupForOne(victim, sourceOrigin, destOrigin,
			floorz, fog);
	}
	else
	{
		// For each actor with tid matching arg0, move it to the same
		// position relative to destOrigin as it is relative to
		// sourceOrigin before the teleport.
		Searcher = -1;
		for (victim = Actor(FindMobjFromTID(group_tid, &Searcher)); victim;
			victim = Actor(FindMobjFromTID(group_tid, &Searcher)))
		{
			didSomething |= DoGroupForOne(victim, sourceOrigin, destOrigin,
				floorz, fog);
		}
	}

	if (moveSource && didSomething)
	{
		didSomething |= sourceOrigin.Teleport(vector(destOrigin.Origin.x,
			destOrigin.Origin.y, floorz ? Actor::ONFLOORZ : destOrigin.Origin.z),
			0.0, false, false, true);
		sourceOrigin.Angles.yaw = destOrigin.Angles.yaw;
	}

	return didSomething;
}

//==========================================================================
//
//	EV_TeleportSector
//
//	[RH] Teleport a group of actors in a sector. Source_tid is used as a
// reference point so that they end up in the same position relative to
// dest_tid. Group_tid can be used to not teleport all actors in the sector.
//
//==========================================================================

bool EV_TeleportSector(int tag, int source_tid, int dest_tid, bool fog,
	int group_tid)
{
	Actor		sourceOrigin;
	Actor		destOrigin;
	int			Searcher;
	bool		didSomething;
	bool		floorz;
	int			secnum;
	sector_t*	sec;
	Actor		A;

	Searcher = -1;
	sourceOrigin = Actor(FindMobjFromTID(source_tid, &Searcher));
	if (!sourceOrigin)
	{
		return false;
	}

	Searcher = -1;
	do
	{
		destOrigin = Actor(FindMobjFromTID(dest_tid, &Searcher));
	}
	while (destOrigin && !TeleportSpot(destOrigin));
	if (!destOrigin)
	{
		return false;
	}

	didSomething = false;
	floorz = !TeleportSpot2(destOrigin);

	for (secnum = XLevel.FindSectorFromTag(tag, -1); secnum >= 0;
		secnum = XLevel.FindSectorFromTag(tag, secnum))
	{
		sec = &XLevel.Sectors[secnum];

		FOREACH(Actor, A)
		{
			// possibly limit actors by group
			if (A.Sector == sec && (group_tid == 0 || A.TID == group_tid))
			{
				didSomething |= DoGroupForOne(A, sourceOrigin, destOrigin,
					floorz, fog);
			}
		}
	}
	return didSomething;
}

//==========================================================================
//
//	EV_SilentLineTeleport
//
// Silent linedef-based TELEPORTATION, by Lee Killough
// Primarily for rooms-over-rooms etc.
// This is the complete player-preserving kind of teleporter.
// It has advantages over the teleporter with thing exits.
//
// [RH] Modified to support different source and destination ids.
//
//==========================================================================

bool EV_SilentLineTeleport(line_t *line, int side, Actor thing, int id,
							bool reverse)
{
	int searcher;
	line_t *l;

	if (side || thing.bNoTeleport || !line)
	{
		return false;
	}

	searcher = -1;
	for (l = FindLine(id, &searcher); l; l = FindLine(id, &searcher))
	{
		TVec SrcXAxis;
		TVec SrcYAxis;
		TVec DstXAxis;
		TVec DstYAxis;
		TVec newPos;
		TVec TempV;
		TAVec TempA;
		float pos;
		float TempX;
		float TempY;
		float oldZ;

		if (l == line || !l->backsector)
		{
			continue;
		}

		// Get the thing's position along the source linedef
		SrcXAxis = Normalise(*line->v2 - *line->v1);
		SrcYAxis = -line->normal;
		pos = DotProduct(SrcXAxis, thing.Origin - *line->v1);
		oldZ = thing.Origin.z;

		// Interpolate position across the exit linedef
		if (reverse)
		{
			DstXAxis = Normalise(*l->v2 - *l->v1);
			DstYAxis = -l->normal;
			newPos = *l->v1 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->frontsector->botregion->floor, newPos);
		}
		else
		{
			DstXAxis = Normalise(*l->v1 - *l->v2);
			DstYAxis = l->normal;
			newPos = *l->v2 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->backsector->botregion->floor, newPos);
		}

		// Attempt to teleport, aborting if blocked
		if (!thing.TeleportMove(newPos))
		{
			return false;
		}

		// Rotate thing's orientation according to difference in linedef angles
		TempV.x = DotProduct(DstXAxis, SrcXAxis);
		TempV.y = DotProduct(DstYAxis, SrcXAxis);
		TempV.z = 0.0;
		VectorAngles(&TempV, &TempA);
		thing.Angles.yaw = AngleMod360(thing.Angles.yaw - TempA.yaw);

		// Rotate thing's momentum to come out of exit just like it entered
		TempX = DotProduct(thing.Velocity, SrcXAxis);
		TempY = DotProduct(thing.Velocity, SrcYAxis);
		thing.Velocity.x = TempX * DstXAxis.x + TempY * DstYAxis.x;
		thing.Velocity.y = TempX * DstXAxis.y + TempY * DstYAxis.y;

		// Adjust a player's view, in case there has been a height change
		if (thing.bIsPlayer)
		{
			thing.Player.ViewOrg.z += thing.Origin.z - oldZ;

			thing.Player.bFixAngle = true;
		}
		return true;
	}
	return false;
}

//**************************************************************************
//
//  Thing line specials
//
//**************************************************************************

//==========================================================================
//
//	EV_ThingProjectile
//
//==========================================================================

bool EV_ThingProjectile(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	bool gravity, int newtid)
{
	int tid;
	float angle;
	float speed;
	float vspeed;
	classid moType;
	Actor A;
	Actor newA;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	tid = Arg1;
	moType = FindClassFromScriptId(Arg2);
	angle = itof(Arg3) * (360.0 / 256.0);
	speed = itof(Arg4) / 8.0;
	vspeed = itof(Arg5) / 8.0;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		newA = Spawn(moType, A.Origin);
		if (newA.SightSound)
		{
			newA.PlaySound(newA.SightSound, CHAN_VOICE);
		}
		newA.Instigator = A;	// Originator
		newA.Angles.yaw = angle;
		newA.Velocity.x = speed * cos(angle) * 35.0;
		newA.Velocity.y = speed * sin(angle) * 35.0;
		newA.Velocity.z = vspeed * 35.0;
		newA.bDropped = true;	// Don't respawn
		if (gravity)
		{
			newA.bNoGravity = false;
			newA.Mass = 12.5;
		}
		if (newtid)
			newA.InsertIntoTIDList(newtid);
		if (newA.CheckMissileSpawn())
		{
			success = true;
		}
	}
	return success;
}

//==========================================================================
//
//	EV_ThingSpawn
//
//==========================================================================

bool EV_ThingSpawn(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, bool fog)
{
	int tid;
	float angle;
	Actor A;
	Actor newAct;
	Actor fogAct;
	classid moType;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	tid = Arg1;
	moType = FindClassFromScriptId(Arg2);
	angle = itof(Arg3) * 360.0 / 256.0;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		newAct = Spawn(moType, A.Origin);
		if (newAct.bFloatBob)
		{
			newAct.Origin.z = A.Origin.z - A.FloorZ;
			newAct.SetOrigin2(newAct.Origin);
		}
		if (newAct.TestLocation() == false)
		{
			// Didn't fit
			newAct.Remove();
		}
		else
		{
			newAct.Angles.yaw = angle;
			if (Arg4)
				newAct.InsertIntoTIDList(Arg4);
			if (fog == true)
			{
				fogAct = Spawn(TeleportFog, A.Origin + vector(0.0, 0.0,
					Actor::TELEFOGHEIGHT));
				fogAct.PlaySound('Teleport', CHAN_VOICE);
			}
			newAct.bDropped = true;	// Don't respawn
			if (newAct.bFloatBob)
			{
				newAct.Special1f = newAct.Origin.z - newAct.FloorZ;
			}
			success = true;
		}
	}
	return success;
}

//==========================================================================
//
//	EV_ThingActivate
//
//==========================================================================

bool EV_ThingActivate(int tid)
{
	Actor A;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		if (A.Activate())
		{
			success = true;
		}
	}
	return success;
}

//==========================================================================
//
//	EV_ThingDeactivate
//
//==========================================================================

bool EV_ThingDeactivate(int tid)
{
	Actor A;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		if (A.Deactivate())
		{
			success = true;
		}
	}
	return success;
}

//==========================================================================
//
//	EV_ThingRemove
//
//==========================================================================

bool EV_ThingRemove(int tid)
{
	Actor A;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		A.RemoveThing();
		success = true;
	}
	return success;
}

//==========================================================================
//
//	EV_ThingDestroy
//
//==========================================================================

bool EV_ThingDestroy(int tid)
{
	Actor A;
	int searcher;
	bool success;

	success = false;
	searcher = -1;
	for (A = Actor(FindMobjFromTID(tid, &searcher)); A;
		A = Actor(FindMobjFromTID(tid, &searcher)))
	{
		if (A.bShootable)
		{
			A.Damage(none, none, 10000);
			success = true;
		}
	}
	return success;
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	Actor target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = Actor(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//**************************************************************************
//
//      NOISE ALERT
//
//**************************************************************************

//==========================================================================
//
//  RecursiveSound
//
//  Called by NoiseAlert. Recursively traverse adjacent sectors, sound
// blocking lines cut off traversal.
//
//==========================================================================

void RecursiveSound(sector_t * sec, int soundblocks, Actor soundtarget)
{
	int i;
	line_t *check;
	sector_t *other;

	// wake up all monsters in this sector
	if (sec->validcount == *Game.validcount &&
		sec->soundtraversed <= soundblocks + 1)
	{
		return;	// already flooded
	}

	sec->validcount = *Game.validcount;
	sec->soundtraversed = soundblocks + 1;
	sec->SoundTarget = soundtarget;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		if (check->sidenum[1] == -1	||
		    !(check->flags & ML_TWOSIDED))
			continue;

		// Early out for intra-sector lines
		if (XLevel.Sides[check->sidenum[0]].sector == XLevel.Sides[check->sidenum[1]].sector)
			continue;

		if (!LineOpenings(check, *check->v1))
		{
			if (!LineOpenings(check, *check->v2))
				continue;	// closed door
		}

		if (XLevel.Sides[check->sidenum[0]].sector == sec)
			other = XLevel.Sides[check->sidenum[1]].sector;
		else
			other = XLevel.Sides[check->sidenum[0]].sector;

		if (check->flags & ML_SOUNDBLOCK)
		{
			if (!soundblocks)
				RecursiveSound(other, 1, soundtarget);
		}
		else
			RecursiveSound(other, soundblocks, soundtarget);
	}
}

//==========================================================================
//
//  NoiseAlert
//
//  If a monster yells at a player, it will alert other monsters to the
// player.
//
//==========================================================================

void NoiseAlert(Actor target, Actor emmiter)
{
	(*Game.validcount)++;
	RecursiveSound(emmiter.Sector, 0, target);
}

//==========================================================================
//
//  SpawnMapThing
//
//==========================================================================

void SpawnMapThing(mthing_t * mthing)
{
	int bit;
	Actor A;
	int spawnMask;
	classid moClass;

	if (mthing->type <= 0)
	{
		return;
	}

	// count deathmatch start positions
	if (mthing->type == 11)
	{
		if (NumDeathmatchStarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing, &DeathmatchStarts[NumDeathmatchStarts]);
			NumDeathmatchStarts++;
		}
		return;
	}

	// check for players specially
	if (mthing->type <= 4)
	{
		// save spots for respawning in network games
		CopyMThing(mthing, &PlayerStarts[mthing->arg1 * MAXPLAYERS +
			mthing->type - 1]);
		return;
	}

	if (mthing->type >= 1400 && mthing->type < 1410)
	{
		XLevel.PointInSector(vector(mthing->x,
			mthing->y, 0.0))->seqType = mthing->type - 1400;
		return;
	}

	// Check for boss spots
	if (mthing->type == 56)	// Monster_BossSpot
	{
		AddBossSpot(mthing->x, mthing->y, itof(45 * (mthing->angle / 45)));
		return;
	}

	// Check current game type with spawn flags
	if (Level.Game.netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if (Level.Game.deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// check for apropriate skill level
	if (Game.gameskill == sk_baby)
		bit = 1;
	else if (Game.gameskill == sk_nightmare)
		bit = 4;
	else
		bit = 1 << (Game.gameskill - 1);
	if (!(mthing->options & bit))
		return;

	// find which type to spawn
	moClass = FindClassFromEditorId(mthing->type);
	if (!moClass)
	{
		dprint("SpawnMapThing: Unknown type %i at (%f, %f)",
			mthing->type, mthing->x, mthing->y);
		return;
	}

	// spawn it
	if (MainGameInfo(Game).shareware)
	{
		// Special stuff
		if (moClass == ItemWeaponSkullRod ||
			moClass == ItemWeaponPhoenixRod ||
			moClass == ItemAmmoSkullRodWimpy ||
			moClass == ItemAmmoSkullRodHefty ||
			moClass == ItemAmmoPhoenixWimpy ||
			moClass == ItemAmmoPhoenixHefty ||
			moClass == ItemAmmoMaceWimpy ||
			moClass == ItemAmmoMaceHefty ||
			moClass == ArtifactSuperHeal ||
			moClass == ArtifactTeleport ||
			moClass == ItemShield2 ||
			moClass == ItemWeaponMace)
		{
			// Don't place on map in shareware version
			return;
		}
	}
	if (moClass == ItemWeaponMace)
	{
		// Put in the mace spot list
		AddMaceSpot(mthing->x, mthing->y);
		return;
	}

	A = Actor(NewMobjThinker(moClass));
	A.OnMapSpawn(mthing);
}

//===========================================================================
//
//  AddMaceSpot
//
//===========================================================================

void AddMaceSpot(float x, float y)
{
	if (MaceSpotCount == MAX_MACE_SPOTS)
	{
		Error("Too many mace spots.");
	}
	MaceSpot_x[MaceSpotCount] = x;
	MaceSpot_y[MaceSpotCount] = y;
	MaceSpotCount++;
}

//===========================================================================
//
//  CloseWeapons
//
//  Called at level load after things are loaded.
//
//===========================================================================

void CloseWeapons()
{
	int spot;

	if (!MaceSpotCount)
	{
		// No maces placed
		return;
	}
	if (!Level.Game.deathmatch && P_Random() < 64)
	{
		// Sometimes doesn't show up if not in deathmatch
		return;
	}
	spot = P_Random() % MaceSpotCount;
	Spawn(ItemWeaponMace, vector(MaceSpot_x[spot], MaceSpot_y[spot],
		Actor::ONFLOORZ));
}

//==========================================================================
//
//  P_AddBossSpot
//
//==========================================================================

void AddBossSpot(float x, float y, float angle)
{
	if (BossSpotCount == MAX_BOSS_SPOTS)
	{
		Error("Too many boss spots.");
	}
	BossSpot[BossSpotCount].x = x;
	BossSpot[BossSpotCount].y = y;
	BossSpot[BossSpotCount].z = 0.0;	//FIXME
	BossSpot_angle[BossSpotCount] = angle;
	BossSpotCount++;
}

//===========================================================================
//
//  Spawn
//
//===========================================================================

Actor Spawn(classid type, TVec AOrigin)
{
	Actor A;

	A = Actor(NewMobjThinker(type));

	A.Origin = AOrigin;
	A.OnMapSpawn(NULL);
	return A;
}

//==========================================================================
//
//  InitLava
//
//==========================================================================

void InitLava()
{
	GLavaInflictor = LavaInflictor(NewMobjThinker(LavaInflictor));
}

//==========================================================================
//
//  P_Massacre
//
//  Kills all monsters.
//
//==========================================================================

void P_Massacre()
{
	Actor mo;

	FOREACH(Actor, mo)
	{
		if (mo.bCountKill && mo.Health > 0)
		{
			mo.Damage(none, none, 10000);
		}
	}
}

defaultproperties
{
	DefaultDoorSound = 'HereticDoor';
	DefaultCeilingSound = 'CeilingNormal';
	DefaultSilentCeilingSound = 'CeilingSemiSilent';
	DefaultFloorSound = 'Floor';
	DefaultFloorAltSound = 'FloorAlt';
	DefaultStairStepSound = 'FloorStairStep';
	DefaultPlatformSound = 'Platform';
}
