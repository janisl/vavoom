//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Class for Actor state action methods.
//**
//**************************************************************************

class Actor : EntityEx
	abstract;

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//**************************************************************************
//	Monster AI
//**************************************************************************

//==========================================================================
//
//	A_Look
//
//	Stay in state until a player is sighted or has a goal.
//
//==========================================================================

final void A_Look()
{
	EntityEx	targ;
	Entity		Ent;

	//	Set goal now if appropriate.
	if (Special == LNSPEC_ThingSetGoal && Args[0] == 0)
	{
		int Searcher = -1;
		Goal = none;
		for (Ent = Level.FindMobjFromTID(Args[1], &Searcher); Ent;
			Ent = Level.FindMobjFromTID(Args[1], &Searcher))
		{
			if (!Ent.IsA('PatrolPoint'))
			{
				continue;
			}
			Goal = EntityEx(Ent);
			break;
		}
		Special = 0;
		ReactionTime = itof(Args[2]) + XLevel.Time;
		bChaseGoal = !!Args[3];
	}

	Threshold = 0;	// any shot will wake up
	if (TIDToHate)
	{
		targ = Target;
	}
	else
	{
		targ = EntityEx(Sector->SoundTarget);
		//	If it's dead, don't chase it.
		if (targ && targ.Health <= 0)
		{
			targ = none;
		}
		if (targ && targ.bIsPlayer && PlayerEx(targ.Player).bNoTarget)
		{
			return;
		}
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (targ && targ.bShootable)
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForPlayers(false))
					return;
			}
		}
	}
	else
	{
		if (!LookForPlayers(bLookAllAround))
			return;
	}

	//	Go into chase state
	//	Don't start chasing after a goal if it isn't time yet.
	if (Target == Goal)
	{
		if (ReactionTime > XLevel.Time)
		{
			Target = none;
		}
	}
	else if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (Target)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Look2
//
//==========================================================================

final void A_Look2()
{
	EntityEx	targ;

	Threshold = 0;	// any shot will wake up
	targ = EntityEx(Sector->SoundTarget);

	if (!bNeutral && targ && targ.bShootable)
	{
		if (bFriendly != targ.bFriendly || Level.bNoAllies)
		{
			Target = targ;
			if (!bStandMustSeeTarget || CanSee(targ))
			{
				Threshold = 10;
				SetState(SeeState);
				return;
			}
		}
		else
		{
			if (LookForPlayers(bLookAllAround))
			{
				SetState(SeeState);
				bInCombat = true;
				return;
			}
		}
	}
	if (P_Random() < 30)
	{
		if (!(P_Random() & 1))
			SetState(FindState('LookRight'));
		else
			SetState(FindState('LookLeft'));
	}
	if (!bStanding && P_Random() < 40)
	{
		SetState(FindState('Walk'));
	}
}

//==========================================================================
//
//	A_TurretLook
//
//	Stay in state untill alarm is triggered.
//
//==========================================================================

final void A_TurretLook()
{
	EntityEx targ;
	int sound;

	Threshold = 0;
	targ = EntityEx(Sector->SoundTarget);
	if (targ && targ.bShootable)
	{
		Target = targ;
		// go into chase state
		if (SightSound)
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
		Threshold = 10;
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Wander
//
//==========================================================================

final void A_Wander()
{
	float	delta;

	bInCombat = false;
	if (bStanding)
		return;

	if (Threshold != 0)
	{
		Threshold--;
		return;
	}

	// turn towards movement direction if not there yet
	if (MoveDir < DI_NODIR)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (--MoveCount < 0 || !StepMove())
	{
		RandomChaseDir();
		MoveCount += 5;
	}
}

//==========================================================================
//
//	DoChase
//
//	Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

void DoChase(bool FastChase, state AMeleeState, state AMissileState,
	bool NightmareFast, bool PlayActive, bool DontMove)
{
	float		delta;
	float		dist;
	float		ang;
	float		oldX;
	float		oldY;
	int			oldFloor;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (ReactionCount)
	{
		ReactionCount--;
	}

	bInCombat = true;
	//	Modify target threshold.
	if (Threshold)
	{
		if (!Target || Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (NightmareFast && Level.Game.fastparm)
	{
		//	Monsters move faster in nightmare mode.
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	//	Turn towards movement direction if not there yet.
	// killough 9/7/98: keep facing towards target if strafing or backing out
	if (strafecount)
	{
		A_FaceTarget();
	}
	else
	{
		if (MoveDir < 8)
		{
			Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
			delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

			if (delta > 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw - 45.0);
			}
			else if (delta < 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw + 45.0);
			}
		}
	}

	//	If the target is dead and not a goal, stop chasing it.
	if (Target && Target != Goal && Target.Health <= 0)
	{
		Target = none;
	}

	if (!Target || !Target.bShootable)
	{
		//	Look for a new target.
		if (LookForPlayers(true) && Target != Goal)
		{
			//	Got a new target.
			return;
		}
		if (!Target)
		{
			if (bFriendly)
			{
				A_Look();
				if (!Target)
				{
					if (!DontMove)
					{
						A_Wander();
					}
					return;
				}
			}
			else
			{
				SetState(IdleState);
				bInCombat = false;
				return;
			}
		}
	}

	//	Do not attack twice in a row.
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!IsFast() && !DontMove)
		{
			NewChaseDir();
		}
		return;
	}

	//	Don't attack if just moving toward goal
	if (Target == Goal || (bChaseGoal && Goal))
	{
		EntityEx SavedTarget = Target;
		Target = Goal;
		bool Result = CheckMeleeRange();
		Target = SavedTarget;

		if (Result)
		{
			// reached the goal

			// Execute the specials of any PatrolSpecials with the same TID
			// as the goal.
			Entity Ent;
			int Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.TID, &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.TID, &Searcher))
			{
				if (Ent.Class != PatrolSpecial)
				{
					continue;
				}
				Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
					Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
					NULL, 0, self);
			}

			float LastGoalAng = Goal.Angles.yaw;
			int Delay;
			EntityEx NewGoal = none;
			Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher))
			{
				if (!Ent.IsA('PatrolPoint'))
				{
					continue;
				}
				NewGoal = EntityEx(Ent);
				break;
			}
			if (NewGoal && Goal == Target)
			{
				Delay = NewGoal.Args[1];
				ReactionTime = itof(Delay) + XLevel.Time;
			}
			else
			{
				Delay = 0;
				ReactionTime = default.ReactionTime;
				Angles.yaw = LastGoalAng;		// Look in direction of last goal
			}
			if (Target == Goal)
			{
				Target = none;
			}
			bJustAttacked = true;
			if (NewGoal && Delay != 0)
			{
				bInCombat = true;
				SetState(IdleState);
			}
			Goal = NewGoal;
			return;
		}
	}

	if (Goal != Target)
	{
		if (FastChase && !DontMove)
		{
			//	Strafe
			if (FastChaseStrafeCount > 0)
			{
				FastChaseStrafeCount--;
			}
			else
			{
				FastChaseStrafeCount = 0;
				Velocity.x = 0.0;
				Velocity.y = 0.0;
				dist = DistTo(Target);
				if (dist < 640.0)
				{
					if (P_Random() < 100)
					{
						ang = atan2(Target.Origin.y - Origin.y,
							Target.Origin.x - Origin.x);
						if (P_Random() < 128)
							ang = AngleMod360(ang + 90.0);
						else
							ang = AngleMod360(ang - 90.0);
						Velocity.x = 13.0 * cos(ang) * 35.0;
						Velocity.y = 13.0 * sin(ang) * 35.0;
						FastChaseStrafeCount = 3;	// strafe time
					}
				}
			}
		}

		//	Check for melee attack.
		if (AMeleeState && CheckMeleeRange())
		{
			if (AttackSound)
			{
				PlaySound(AttackSound, CHAN_WEAPON);
			}
			SetState(AMeleeState);
			return;
		}

		//	Check for missile attack.
		if (AMissileState)
		{
			if (IsFast() || !MoveCount)
			{
				if (CheckMissileRange())
				{
					SetState(AMissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
	}

	//	Possibly choose another target.
	if ((Level.Game.netgame || TIDToHate) && !Threshold)
	{
		if (!CanSee(Target))
		{
			bool PrevNoSightCheck = bNoSightCheck;
			bNoSightCheck = false;
			bool GotNew = LookForPlayers(true);
			bNoSightCheck = PrevNoSightCheck;
			if (GotNew)
			{
				//	Got a new target.
				return;
			}
		}
	}

	if (strafecount)
	{
		strafecount--;
	}

	//	Chase towards player.
	if ((!FastChase || !FastChaseStrafeCount) && !DontMove)
	{
		oldX = Origin.x;
		oldY = Origin.y;
		oldFloor = Sector->floor.pic;
		if (--MoveCount < 0 || !StepMove())
		{
			NewChaseDir();
		}
		if (bCantLeaveFloorpic && Sector->floor.pic != oldFloor)
		{
			TryMove(vector(oldX, oldY, Origin.z));
			NewChaseDir();
		}
	}
	else if (DontMove && MoveCount > 0)
	{
		MoveCount = 0;
	}

	//	Make active sound.
	if (PlayActive && P_Random() < 3)
	{
		PlayActiveSound();
	}
}

//==========================================================================
//
//  CheckForResurrect
//
//  Check for ressurecting a body.
//
//==========================================================================

final bool CheckForResurrect(bool UseVileStates)
{
	float viletryx;
	float viletryy;
	Entity Other;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + Speed / 35.0 * LineSpecialGameInfo(Level.Game).xspeed[MoveDir];
		viletryy = Origin.y + Speed / 35.0 * LineSpecialGameInfo(Level.Game).yspeed[MoveDir];

		//	For all things in radius check whether object is a corpse
		// that can be raised.
		foreach RadiusThings(Other, vector(viletryx, viletryy, 0.0), MAXRADIUS)
		{
			//  Detect a corpse that could be raised.
			float maxdist;
			bool check;

			if (!Other.bCorpse)
			{
				continue;	// not a monster
			}

			if (Other.StateTime != -1.0)
			{
				continue;	// not lying still yet
			}

			state RaiseState = Other.FindState('Raise');
			if (!RaiseState)
			{
				continue;	// monster doesn't have a raise state
			}

			maxdist = Other.Radius + Radius;

			if (fabs(Other.Origin.x - viletryx) > maxdist ||
				fabs(Other.Origin.y - viletryy) > maxdist)
			{
				continue;	// not actually touching
			}

			if (!CanSee(Other))
			{
				continue;	//  Con't see, possibly in other region
			}

			EntityEx CorpseHit = EntityEx(Other);
			CorpseHit.Velocity.x = 0.0;
			CorpseHit.Velocity.y = 0.0;
			float OldHeight = CorpseHit.Height;
			bool OldSolid = CorpseHit.bSolid;
			CorpseHit.bSolid = true;
			CorpseHit.Height = CorpseHit.default.Height;
			check = CorpseHit.CheckPosition(CorpseHit.Origin);
			CorpseHit.bSolid = OldSolid;
			CorpseHit.Height = OldHeight;

			if (!check)
			{
				continue;	// doesn't fit here
			}

			// got one!
			EntityEx temp = Target;
			Target = CorpseHit;
			A_FaceTarget();
			Target = temp;

			//	Enter heal state.
			state HealState = FindState('Heal');
			if (!HealState && UseVileStates)
			{
				//	For DeHackEd compatibility use Arch-vile heal states if
				// this one doesn't have it's own.
				HealState = FindClassState(Archvile, 'Heal');
			}
			if (HealState)
			{
				SetState(HealState);
			}
			CorpseHit.PlaySound('vile/raise', CHAN_BODY);

			CorpseHit.SetState(RaiseState);
			CorpseHit.Height = CorpseHit.default.Height;
			CorpseHit.bShootable = true;
			CorpseHit.bFloat = CorpseHit.default.bFloat;
			CorpseHit.bNoGravity = CorpseHit.default.bNoGravity;
			CorpseHit.bDropOff = false;
			CorpseHit.bSolid = true;
			CorpseHit.bCorpse = false;
			CorpseHit.Health = CorpseHit.default.Health;
			CorpseHit.Target = none;
			CorpseHit.LastEnemy = none;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	A_Chase
//
//==========================================================================

final void A_Chase()
{
	DoChase(false, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
}

//==========================================================================
//
//	decorate_A_Chase
//
//==========================================================================

final void decorate_A_Chase(optional state AMeleeState,
	optional state AMissileState, optional int Flags)
{
	if (specified_AMeleeState)
	{
		if ((Flags & 8) && CheckForResurrect(false))
		{
			return;
		}
		DoChase(!!(Flags & 1), AMeleeState, AMissileState, !!(Flags & 4),
			!(Flags & 2), !!(Flags & 16));
	}
	else
	{
		DoChase(false, MeleeState, MissileState,
			LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
	}
}

//============================================================================
//
//  A_FastChase
//
//============================================================================

final void A_FastChase()
{
	DoChase(true, MeleeState, MissileState, true, true, false);
}

//==========================================================================
//
//  A_VileChase
//
//==========================================================================

final void A_VileChase()
{
	if (!CheckForResurrect(true))
	{
		// Return to normal attack.
		A_Chase();
	}
}

//==========================================================================
//
//	A_ExtChase
//
//==========================================================================

final void A_ExtChase(bool UseMelee, bool UseMissile,
	optional bool PlayActive, optional bool NightmareFast)
{
	if (!specified_PlayActive)
	{
		PlayActive = true;
	}
	state Melee = MeleeState;
	if (!UseMelee)
	{
		Melee = none;
	}
	state Missile = MissileState;
	if (!UseMissile)
	{
		Missile = none;
	}
	DoChase(false, Melee, Missile, NightmareFast, PlayActive, false);
}

//==========================================================================
//
//	A_FaceTarget
//
//==========================================================================

final void A_FaceTarget()
{
	if (!Target)
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	Angles.yaw = atan2(Target.Origin.y - Origin.y,
		Target.Origin.x - Origin.x);

	if (Target.bShadow)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//==========================================================================
//
//	A_Die
//
//==========================================================================

final void A_Die()
{
	Damage(none, none, Health);
}

//==========================================================================
//
//	A_CentaurDefend
//
//==========================================================================

final void A_CentaurDefend()
{
	A_FaceTarget();
	if (CheckMeleeRange() && Random() < 0.125)
	{
		A_UnSetInvulnerable();
		SetState(MeleeState);
	}
}

//==========================================================================
//
//	A_AlertMonsters
//
//==========================================================================

final void A_AlertMonsters()
{
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//	A_ClearTarget
//
//==========================================================================

final void A_ClearTarget()
{
	Target = none;
	LastEnemy = none;
}

//==========================================================================
//
//	A_ClearSoundTarget
//
//==========================================================================

final void A_ClearSoundTarget()
{
	Sector->SoundTarget = none;
}

//==========================================================================
//
//	A_KillMaster
//
//==========================================================================

final void A_KillMaster()
{
	if (Master)
	{
		Master.Damage(self, self, Master.Health,, true);
	}
}

//==========================================================================
//
//	A_KillChildren
//
//==========================================================================

final void A_KillChildren()
{
	Actor A;
	foreach AllThinkers(Actor, A)
	{
		if (A.Master == self)
		{
			A.Damage(self, self, A.Health,, true);
		}
	}
}

//==========================================================================
//
//	A_SentinelBob
//
//==========================================================================

final void A_SentinelBob()
{
	float minz, maxz;

	if (bInFloat)
	{
		Velocity.z = 0.0;
		return;
	}

	if (Threshold)
		return;

	maxz = CeilingZ - Height - 16.0;
	minz = FloorZ + 96.0;
	if (minz > maxz)
	{
		minz = maxz;
	}

	if (minz < Origin.z)
	{
		Velocity.z -= 1.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 * 35.0;
	}
	ReactionCount = (minz >= Origin.z) ? 4 : 0;
}

//==========================================================================
//
//	A_Burst
//
//==========================================================================

final void A_Burst(class<Actor> ChunkType)
{
	if (!ChunkType)
	{
		return;
	}

	//	Stop the thing and reset it's height.
	Velocity = vector(0.0, 0.0, 0.0);
	Height = default.Height;

	//	Calculate number of chunks based on the size of the thing.
	int NumChunks = ftoi(Radius * Height) / 32;
	if (NumChunks < 4)
	{
		NumChunks = 4;
	}
	int i = NumChunks + ((P_Random() - P_Random()) % (NumChunks / 4));
	if (i < 24)
	{
		i = 24;
	}
	for (; i >= 0; i--)
	{
		Actor A = Spawn(ChunkType, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			A.RenderStyle = RenderStyle;
			A.Alpha = Alpha;
			A.bFriendly = bFriendly;
		}
	}

	//	If it's a boss, execute special boss death actions.
	if (bBossDeath)
	{
		A_BossDeath();
	}

	//	Drop items and go away.
	A_NoBlocking();
	Destroy();
}

//**************************************************************************
//	Generic monster attacks
//**************************************************************************

//==========================================================================
//
//	A_CustomMissile
//
//==========================================================================

final void A_CustomMissile(class<Actor> MissileType, float SpawnHeight,
	int SpawnXYOffset, optional float Angle, optional int AimMode,
	optional float Pitch)
{
	int Flags = AimMode & ~3;
	AimMode &= 3;

	if (Target || AimMode == 2)
	{
		if (MissileType)
		{
			TVec Offs = itof(SpawnXYOffset) * vector(cos(Angles.yaw - 90.0),
				sin(Angles.yaw - 90.0), 0.0);
			EntityEx A;

			switch (AimMode)
			{
			default:
				Origin += Offs;
				A = SpawnMissile(Target, MissileType, SpawnHeight);
				Origin -= Offs;
				break;

			case 1:
				Offs.z = SpawnHeight;
				A = SpawnMissileXYZ(Origin + Offs, Target, MissileType);
				break;

			case 2:
				Origin += Offs;
				A = SpawnMissileAngles(MissileType, Angles.yaw, Pitch,
					SpawnHeight);
				Origin -= Offs;
			}

			if (A)
			{
				VectorRotateAroundZ(&A.Velocity, Angle);
				//	Find correct shooter for projectiles shooting projectiles.
				if (IsMissile(!!(Flags & 4)))
				{
					EntityEx Own = self;
					while (Own.IsMissile(!!(Flags & 4)) && Own.Target)
					{
						Own = Own.Target;
					}
					A.Target = Own;
					if (A.bSeekerMissile)
					{
						A.Tracer = Tracer;
					}
				}
				else if (A.bSeekerMissile)
				{
					A.Tracer = Target;
				}
			}
		}
	}
	else if (Flags & 8)
	{
		if (SeeState)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//	A_CustomBulletAttack
//
//==========================================================================

final void A_CustomBulletAttack(float SpreadHoriz, float SpreadVert,
	int NumBullets, int DamagePerBullet, class<Actor> PuffType,
	optional float Range, optional bool AimFacing)
{
	if (!Range)
	{
		Range = MISSILERANGE;
	}
	if (!PuffType)
	{
		PuffType = BulletPuff;
	}

	if (!Target && !AimFacing)
	{
		return;
	}

	if (!AimFacing)
	{
		A_FaceTarget();
	}

	if (AttackSound)
	{
		PlaySound(AttackSound, CHAN_WEAPON);
	}

	TVec aimDir;
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	int i;
	for (i = 0; i < NumBullets; i++)
	{
		TAVec rot;
		rot.pitch = (Random() - Random()) * SpreadVert;
		rot.yaw = (Random() - Random()) * SpreadHoriz;
		rot.roll = 0.0;
		TVec dir = RotateDirectionVector(aimDir, rot);
		int damage = ((P_Random() % 3) + 1) * DamagePerBullet;
		LineAttack(dir, Range, damage, PuffType,,,
			PuffType.default.DamageType);
	}
}

//===========================================================================
//
//  A_CustomRailgun
//
//===========================================================================

final void A_CustomRailgun(int RailDamage, optional float Offset,
	optional string Colour1, optional string Colour2, optional bool Silent,
	optional bool DoAim, optional float MaxDiff,
	optional class<Actor> PuffType)
{
	if (DoAim && !Target)
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	if (DoAim)
	{
		Angles.yaw = atan2(Target.Origin.y - Origin.y,
			Target.Origin.x - Origin.x);
	}

	TVec Dir;
	AimLineAttack(Dir, Angles, MISSILERANGE);
	TAVec Ang;
	VectorAngles(&Dir, &Ang);

	if (DoAim)
	{
		//	Trail a little bit behind the target
		Ang.yaw = atan2(
			Target.Origin.y - Target.Velocity.y * 3.0 / 35.0 - Origin.y,
			Target.Origin.x - Target.Velocity.y * 3.0 / 35.0 - Origin.x);

		if (Target.bShadow)
		{
			Ang.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
		}
		Angles.yaw = Ang.yaw;
	}

	AngleVector(&Ang, &Dir);
	int Col1 = ParseColour(Colour1);
	int Col2 = ParseColour(Colour2);
	RailAttack(Dir, Offset, RailDamage, Col1, Col2, MaxDiff, PuffType,
		Silent);
}

//==========================================================================
//
//	A_CustomMeleeAttack
//
//==========================================================================

final void A_CustomMeleeAttack(int MeleeDamage, optional name MeleeSound,
	optional name MissSound, optional name DamageType, optional bool Bleed)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		if (!DamageType)
		{
			DamageType = 'Melee';
		}
		if (MeleeSound)
		{
			PlaySound(MeleeSound, CHAN_WEAPON);
		}
		Target.Damage(self, self, MeleeDamage, DamageType);
	}
	else
	{
		if (MissSound)
		{
			PlaySound(MissSound, CHAN_WEAPON);
		}
	}
}

//==========================================================================
//
//	A_CustomComboAttack
//
//==========================================================================

final void A_CustomComboAttack(class<Actor> MissileType, float MissileHeight,
	int MeleeDamage, optional name MeleeSound, optional name DamageType,
	optional bool Bleed)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		if (!DamageType)
		{
			DamageType = 'Melee';
		}
		if (MeleeSound)
		{
			PlaySound(MeleeSound, CHAN_WEAPON);
		}
		Target.Damage(self, self, MeleeDamage, DamageType);
		return;
	}

	if (MissileType)
	{
		EntityEx A = SpawnMissile(Target, MissileType, MissileHeight);
		if (A)
		{
			if (A.bSeekerMissile)
			{
				A.Tracer = Target;
			}
		}
	}
}

//==========================================================================
//
//	DoAttack
//
//==========================================================================

final void DoAttack(bool DoMelee, bool DoMissile, int MeleeDamage,
	name MeleeSound, class<Actor> MissileType, float MissileHeight)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (DoMelee && MeleeDamage > 0 && CheckMeleeRange())
	{
		if (MeleeSound)
		{
			PlaySound(MeleeSound, CHAN_WEAPON);
		}
		int damage = (P_Random() % 8 + 1) * MeleeDamage;
		Target.Damage(self, self, damage, 'Melee');
		return;
	}

	if (DoMissile && MissileType)
	{
		EntityEx A = SpawnMissile(Target, MissileType, MissileHeight);
		if (A)
		{
			if (A.bSeekerMissile)
			{
				A.Tracer = Target;
			}
		}
	}
}

//==========================================================================
//
//	A_MeleeAttack
//
//==========================================================================

final void A_MeleeAttack()
{
	DoAttack(true, false, MeleeDamage, MeleeSound, MissileType,
		MissileHeight);
}

//==========================================================================
//
//	A_MissileAttack
//
//==========================================================================

final void A_MissileAttack()
{
	DoAttack(false, true, MeleeDamage, MeleeSound, MissileType,
		MissileHeight);
}

//==========================================================================
//
//	A_ComboAttack
//
//==========================================================================

final void A_ComboAttack()
{
	DoAttack(true, true, MeleeDamage, MeleeSound, MissileType,
		MissileHeight);
}

//==========================================================================
//
//	A_BasicAttack
//
//==========================================================================

final void A_BasicAttack(int AMeleeDamage, name AMeleeSound,
	class<Actor> AMissileType, float AMissileHeight)
{
	DoAttack(true, true, AMeleeDamage, AMeleeSound, AMissileType,
		AMissileHeight);
}

//==========================================================================
//
//	A_BulletAttack
//
//==========================================================================

final void A_BulletAttack()
{
	if (!Target)
	{
		return;
	}

	if (AttackSound)
	{
		PlaySound(AttackSound, CHAN_WEAPON);
	}
	A_FaceTarget();
	TVec aimDir;
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	int i;
	int NumBullets = GetMissileDamage(0, 1);
	for (i = 0; i < NumBullets; i++)
	{
		TVec dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		int damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, BulletPuff);
	}
}

//===========================================================================
//
//  A_MonsterRail
//
//===========================================================================

final void A_MonsterRail()
{
	if (!Target)
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	Angles.yaw = atan2(Target.Origin.y - Origin.y,
		Target.Origin.x - Origin.x);

	TVec Dir;
	AimLineAttack(Dir, Angles, MISSILERANGE);
	TAVec Ang;
	VectorAngles(&Dir, &Ang);

	//	Trail a little bit behind the target
	Ang.yaw = atan2(
		Target.Origin.y - Target.Velocity.y * 3.0 / 35.0 - Origin.y,
		Target.Origin.x - Target.Velocity.y * 3.0 / 35.0 - Origin.x);

	if (Target.bShadow)
	{
		Ang.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
	Angles.yaw = Ang.yaw;

	AngleVector(&Ang, &Dir);
	RailAttack(Dir, 0.0, GetMissileDamage(0, 1));
}

//==========================================================================
//
//  DoExplode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void DoExplode(int damage, float distance, bool damageSelf)
{
	int			i;

	RadiusAttack(Target, damage, distance, damageSelf, DamageType);
	if (Origin.z <= FloorZ + distance)
	{
		HitFloorType();
	}

	if (bExplodeParticles)
	{
		//  Spawn explosion effects - dynamic light and particles
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!Level.Game.Players[i])
				continue;
			if (!Level.Game.Players[i].bSpawned)
				continue;
			PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(
				DLightColour, DLightRadius, Origin + vector(0.0, 0.0, Height * 0.5));
		}
	}
	else if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, DLightRadius, Origin);
	}

	//  Clear old dynamic light and trail effects
	bDynamicLight = false;
	bLeaveTrail = false;
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void A_Explode()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = 128;
	distance = 128.0;
	damageSelf = true;

	PreExplode();
	GetExplodeParms(damage, distance, damageSelf);

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  A_ExplodeAndAlert
//
//==========================================================================

final void A_ExplodeAndAlert()
{
	A_Explode();
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//  A_ExplodeParms
//
//==========================================================================

final void A_ExplodeParms()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = ExplosionDamage;
	distance = itof(ExplosionRadius);
	damageSelf = !bExplosionDontHurtSelf;

	if (!damage)
	{
		damage = 128;
	}
	if (!distance)
	{
		distance = itof(damage);
	}

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  decorate_A_Explode
//
//==========================================================================

final void decorate_A_Explode(optional int damage, optional int distance,
	optional bool damageSelf)
{
	if (specified_damage)
	{
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = 128;
		}
		if (!specified_damageSelf)
		{
			damageSelf = true;
		}
	}
	else
	{
		damage = ExplosionDamage;
		distance = ExplosionRadius;
		damageSelf = !bExplosionDontHurtSelf;
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = damage;
		}
	}

	DoExplode(damage, itof(distance), damageSelf);
}

//==========================================================================
//
//  A_RadiusThrust
//
//==========================================================================

final void A_RadiusThrust(optional int Force, optional int Distance,
	optional bool AffectSelf)
{
	if (!Force)
	{
		Force = 128;
	}
	if (!Distance)
	{
		Distance = Force;
	}
	if (!specified_AffectSelf)
	{
		AffectSelf = true;
	}

	RadiusAttack(Target, Force, itof(Distance), AffectSelf, DamageType, false);
	if (Origin.z <= FloorZ + itof(Distance))
	{
		HitFloorType();
	}
}

//==========================================================================
//
//  A_Detonate
//
//==========================================================================

final void A_Detonate()
{
	int damage = GetMissileDamage(0, 1);
	DoExplode(damage, itof(damage), true);
}

//==========================================================================
//
//  A_ThrowGrenade
//
//==========================================================================

final void A_ThrowGrenade(class<Actor> ItemType, optional float SpawnHeight,
	optional float XYVel, optional float ZVel, optional bool UseAmmo)
{
	if (!specified_UseAmmo)
	{
		UseAmmo = true;
	}

	//	If called from weapon, then use ammo.
	if (bIsPlayer &&
		(XLevel.CallingState == Player.ViewStates[ps_weapon].State ||
		XLevel.CallingState == Player.ViewStates[ps_flash].State))
	{
		Weapon Wpn = PlayerEx(Player).ReadyWeapon;
		if (!Wpn)
		{
			return;
		}
		if (UseAmmo && !Wpn.DepleteAmmo())
		{
			return;
		}
	}

	Actor A = Spawn(ItemType, Owner.Origin +
		vector(0.0, 0.0, SpawnHeight + 35.0 - Owner.FloorClip));
	if (A)
	{
		A.PlayMissileSpawnSound(self);
		if (XYVel)
		{
			A.Speed = XYVel * 35.0;
		}
		A.Angles.yaw = AngleMod360(Owner.Angles.yaw +
			(Random() * 2.0 - 1.0) * 45.0 / 8.0);
		A.Velocity.z = (ZVel + 2.0 * sin(Owner.Angles.pitch)) * 35.0;
		A.Origin.z += 2.0 * sin(Owner.Angles.pitch);
		A.Velocity.x += A.Speed * cos(A.Angles.yaw);
		A.Velocity.y += A.Speed * sin(A.Angles.yaw);
		A.Velocity.x += Velocity.x / 2.0;
		A.Velocity.y += Velocity.y / 2.0;
		A.Target = self;
		if (A.bRandomise)
		{
			A.StateTime -= Random() * 0.1;
			if (A.StateTime < 1.0 / 35.0)
			{
				A.StateTime = 1.0 / 35.0;
			}
		}
		A.CheckMissileSpawn();
	}
	else if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//**************************************************************************
//	Freeze death functions
//**************************************************************************

//============================================================================
//
//	A_FreezeDeath
//
//============================================================================

final void A_FreezeDeath()
{
	StateTime = 2.0 + Random() * 8.0 + Random() * 8.0;
	bSolid = true;
	bShootable = true;
	bNoBlood = true;
	bPushable = true;
	bTelestomp = true;
	bSlide = true;
	bPassMobj = true;
	Height *= 4.0;
	PlaySound('misc/freeze', CHAN_VOICE);
	Translation = 0;	//no translation
	bIceCorpse = true;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		Alpha = 1.0;
		VisDir = 0;
	}

	if (bIsPlayer)
	{
		PlayerEx(Player).DamageFlash = 0.0;
		PlayerEx(Player).PoisonCount = 0;
		PlayerEx(Player).BonusFlash = 0.0;
	}
	else
	{
		if (bMonster && Special)
		{
			// Initiate monster death actions
			Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
				Args[3], Args[4], NULL, 0, self);
		}
	}
}

//============================================================================
//
//	A_GenericFreezeDeath
//
//============================================================================

final void A_GenericFreezeDeath()
{
	A_FreezeDeath();
	Translation = (TRANSL_Standard << TRANSL_TYPE_SHIFT) + 7;
}

//============================================================================
//
//  A_FreezeDeathChunks
//
//============================================================================

final void A_FreezeDeathChunks()
{
	int i;
	Actor A;

	if (Length(Velocity) > 1.0)
	{
		StateTime = 3.0;
		return;
	}
	PlaySound('misc/icebreak', CHAN_VOICE);

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i])
			continue;
		if (!Level.Game.Players[i].bSpawned)
			continue;
		PlayerEx(Level.Game.Players[i]).ParticleEffect(256,
			LineSpecialLevelInfo::pt_static,
			LineSpecialLevelInfo::pt_ice_chunk, Origin + vector(0.0, 0.0,
			Height * 0.5), 20.0, vector(64.0, 64.0, 96.0), 0.6, 6.0, 80.0,
			RGB(127, 130, 240), 10.0, 16.0);
	}

	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	if (bIsPlayer)
	{
		// attach the player's view to a chunk of ice
		A = Spawn(IceChunkHead, Origin +
			vector(0.0, 0.0, PlayerPawn(self).ViewHeight));
		A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
		A.Player = Player;
		A.bIsPlayer = true;
		A.ObtainInventory(EntityEx(Player.MO));
		Player = none;
		bIsPlayer = false;
		A.Health = Health;
		A.Angles.yaw = Angles.yaw;
		A.Player.MO = A;
		A.Player.Camera = A;
		A.Angles.pitch = 0.0;
	}
	RemoveFromTIDList();
	if (bBossDeath)
	{
		A_BossDeath();
	}
	SetState(FindState('FreeTargMobj'));
	bInvisible = true;
}

//==========================================================================
//
//	A_IceGuyDie
//
//==========================================================================

final void A_IceGuyDie()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Height *= 4.0;
	A_FreezeDeathChunks();
}

//**************************************************************************
//	Sound functions
//**************************************************************************

//==========================================================================
//
//  A_PlaySound
//
//==========================================================================

final void A_PlaySound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_BODY);
}

//==========================================================================
//
//  A_PlaySoundEx
//
//==========================================================================

final void A_PlaySoundEx(string Sound, string Channel, optional bool Loop,
	optional int Attenuation)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	//	Attenuation
	float Atten = ATTN_NORMAL;
	switch (Attenuation)
	{
	case -1:
		Atten = ATTN_STATIC;
		break;
	case 1:
		Atten = ATTN_NONE;
		break;
	case 2:
		Atten = ATTN_SURROUND;
		break;
	}

	PlaySound(StrToName(Sound), Chan,, Atten, Loop);
}

//==========================================================================
//
//  A_PlayWeaponSound
//
//==========================================================================

final void A_PlayWeaponSound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_WEAPON);
}

//==========================================================================
//
//	A_ActiveSound
//
//==========================================================================

final void A_ActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_LoopActiveSound
//
//==========================================================================

final void A_LoopActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE,,, true);
	}
}

//==========================================================================
//
//	A_FLoopActiveSound
//
//==========================================================================

final void A_FLoopActiveSound()
{
	if (ActiveSound && !GetSoundPlayingInfo(self, GetSoundID(ActiveSound)))
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_StopSound
//
//==========================================================================

final void A_StopSound()
{
	StopSound(CHAN_VOICE);
}

//==========================================================================
//
//	A_StopSoundEx
//
//==========================================================================

final void A_StopSoundEx(string Channel)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	StopSound(Chan);
}

//==========================================================================
//
//  A_Pain
//
//==========================================================================

final void A_Pain()
{
	if (bIsPlayer && !PlayerEx(Player).MorphTime)
	{
		if (Health < 25)
		{
			PlaySound('*pain25', CHAN_VOICE);
		}
		else if (Health < 50)
		{
			PlaySound('*pain50', CHAN_VOICE);
		}
		else if (Health < 75)
		{
			PlaySound('*pain75', CHAN_VOICE);
		}
		else
		{
			PlaySound('*pain100', CHAN_VOICE);
		}
	}
	else if (PainSound)
	{
		PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Scream
//
//  Death sound.
//
//==========================================================================

final void A_Scream()
{
	//  Remove muzzle flash & other light effects
	bDynamicLight = false;

	if (DeathSound)
	{
		// Make boss death sounds full volume
		PlaySound(DeathSound, CHAN_VOICE, 1.0, bBoss ? ATTN_NONE : ATTN_NORMAL);
	}
}

//==========================================================================
//
//	A_XScream
//
//  Explode death sound.
//
//==========================================================================

final void A_XScream()
{
	if (bIsPlayer)
	{
		PlaySound('*gibbed', CHAN_BODY);
	}
	else
	{
		PlaySound('misc/gibbed', CHAN_BODY);
	}
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

final void A_VileStart()
{
	PlaySound('vile/start', CHAN_WEAPON);
}

//==========================================================================
//
//  A_BrainPain
//
//  Brain pain sound.
//
//==========================================================================

final void A_BrainPain()
{
	PlaySound('brain/pain', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_BrainAwake
//
//  Init boss spawner.
//
//==========================================================================

final void A_BrainAwake()
{
	//	Do just a sound, like in Boom.
	PlaySound('brain/sight', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_PlayerScream
//
//==========================================================================

final void A_PlayerScream()
{
	if (!bIsPlayer || DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
		return;
	}

	name Sound;
	int Chan = CHAN_VOICE;

	// Handle the different player death screams
	if ((Level.bFallingDamage || Level.bOldFallingDamage ||
		Level.bStrifeFallingDamage) && Velocity.z <= -39.0 * 35.0 &&
		IsSoundPresent('*splat'))
	{
		// Falling splat
		Sound = '*splat';
		Chan = CHAN_BODY;
	}
	if (!Sound && Special1 < 10 && IsSoundPresent('*wimpydeath'))
	{
		// Wimpy death sound
		Sound = '*wimpydeath';
	}
	if (!Sound && Health <= -50)
	{
		if (Health > -100 && IsSoundPresent('*crazydeath'))
		{
			// Crazy death sound
			Sound = '*crazydeath';
		}
		if (!Sound && IsSoundPresent('*xdeath'))
		{
			// Extreme death sound
			Sound = '*xdeath';
		}
		if (!Sound && IsSoundPresent('*gibbed'))
		{
			// Extreme death sound
			Sound = '*gibbed';
			Chan = CHAN_BODY;
		}
	}
	if (!Sound)
	{
		// Normal death sound
		Sound = '*death';
	}

	PlaySound(Sound, Chan);
}

//**************************************************************************
//	Special actions
//**************************************************************************

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

final void A_BossDeath()
{
	name Cls = GetClassName(Class);
	if (!((Cls == 'BaronOfHell' && Level.bBaronSpecial) ||
		(Cls == 'Cyberdemon' && Level.bCyberDemonSpecial) ||
		(Cls == 'SpiderMastermind' && Level.bSpiderMastermindSpecial) ||
		(Cls == 'Arachnotron' && Level.bMap07Special) ||
		(Cls == 'Fatso' && Level.bMap07Special) ||
		(Cls == 'Ironlich' && Level.bIronLichSpecial) ||
		(Cls == 'Minotaur' && Level.bMinotaurSpecial) ||
		(Cls == 'Sorcerer2' && Level.bDSparilSpecial)))
	{
		return;
	}

	if (!CheckBossDeath())
	{
		return;
	}

	// victory!
	if (Level.bSpecialActionKillMonsters)
	{
		// Kill any remaining monsters
		LineSpecialLevelInfo(Level).P_Massacre();
	}

	if (Level.bMap07Special)
	{
		if (GetClassName(Class) == 'Fatso')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
		if (GetClassName(Class) == 'Arachnotron')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorRaiseByTexture, 667, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
	}
	else if (Level.bSpecialActionOpenDoor)
	{
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 64, 150, 0, 0,
			NULL, 0, none);
		return;
	}
	else if (Level.bSpecialActionLowerFloor)
	{
		Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8, 0, 0,
			0, NULL, 0, none);
		return;
	}
	Level.ExitLevel(0);
}

//==========================================================================
//
//  A_KeenDie
//
//  DOOM II special, map 32. Uses special tag 666.
//
//==========================================================================

final void A_KeenDie()
{
	EntityEx		Other;

	A_Fall();

	// scan the remaining thinkers to see if all Keens are dead
	foreach AllThinkers(class<Thinker>(Class), Other)
	{
		if (Other != self && Other.Health > 0)
		{
			// other mobj of the same Class not dead
			return;
		}
	}
	Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 16, 150, 0, 0, NULL, 0,
		none);
}

//==========================================================================
//
//  A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

final void A_BrainDie()
{
	Level.ExitLevel(0);
}

//==========================================================================
//
//	A_GetHurt
//
//==========================================================================

final void A_GetHurt()
{
	bInCombat = true;
	if ((P_Random() % 5) == 0)
	{
		PlaySound(PainSound, CHAN_VOICE);
		Health--;
	}
	if (Health <= 0)
	{
		Died(Target, none);
	}
}

//==========================================================================
//
//	A_KlaxonBlare
//
//==========================================================================

final void A_KlaxonBlare()
{
	ReactionCount--;
	if (ReactionCount <= 0)
	{
		Target = none;
		ReactionCount = 60;
		if (Target == none)
		{
			SetState(IdleState);
		}
	}
	if (ReactionCount == 2)
	{
		// Should make enemies go to Idle state again
		LineSpecialLevelInfo(Level).NoiseAlert(none, self);
	}
	else if (ReactionCount > 50)
	{
		PlaySound('misc/alarm', CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_CheckTerrain
//
//==========================================================================

final void A_CheckTerrain()
{
	int anglespeed;
	float speed;
	float finean;

	if (Origin.z == GetPlanePointZ(Floor, Origin))
	{
		if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_DamageInstantDeath)
		{
			Damage(none, none, 999);
		}
		else if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_ScrollCurrent)
		{
			anglespeed = Sector->tag - 100;
			speed = itof(anglespeed % 10) / 16.0 * 35.0;
			finean = itof(anglespeed / 10) * 45.0;
			Velocity.x += speed * cos(finean);
			Velocity.y += speed * sin(finean);
		}
	}
}

//============================================================================
//
//  A_Print
//
//============================================================================

final void A_Print(string Text, optional float Time, optional string FontName)
{
	BasePlayer Plr;
	if (bIsPlayer)
	{
		Plr = Player;
	}
	else if (Target && Target.bIsPlayer)
	{
		Plr = Target.Player;
	}
	else
	{
		return;
	}

	if (!Time)
	{
		Time = 7.0;
	}
	Plr.ClientHudMessage(Text, StrToName(FontName), 0, 123456, CR_UNTRANSLATED,
		"", 0.5, 0.2, 0, 0, Time, 0.0, 0.0);
}

//============================================================================
//
//  A_SetBlend
//
//============================================================================

final void A_SetBlend(string Col1, float A, int Tics, optional string Col2)
{
	int C1 = ParseColour(Col1);
	int C2 = ParseColour(Col2);
	if (A < 0.0)
	{
		A = 0.0;
	}
	else if (A > 1.0)
	{
		A = 1.0;
	}

	//	Huh?
	if (C1 == 0xffffffff)
	{
		C1 = 0;
	}
	if (C2 == 0xffffffff)
	{
		C2 = 0;
	}
	if (!specified_Col2)
	{
		C2 = C1;
	}

	FlashFader F = Spawn(FlashFader);
	F.Init(itof((C1 >> 16) & 0xff) / 255.0, itof((C1 >> 8) & 0xff) / 255.0,
		itof(C1 & 0xff) / 255.0, A, itof((C2 >> 16) & 0xff) / 255.0,
		itof((C2 >> 8) & 0xff) / 255.0, itof(C2 & 0xff) / 255.0, 0.0,
		itof(Tics) / 35.0, self);
}

//============================================================================
//
//  A_CheckSight
//
//============================================================================

final void A_CheckSight(state Label)
{
	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	int i;
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i] || !Level.Game.Players[i].bSpawned)
		{
			continue;
		}
		if (Level.Game.Players[i].Camera.CanSee(self))
		{
			return;
		}
	}

	DoJump(Label);
}

//==========================================================================
//
//  A_CheckFloor
//
//  Checks if an object hit the floor
//
//==========================================================================

final void A_CheckFloor(state Label)
{
	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	if (Origin.z <= FloorZ)
	{
		DoJump(Label);
	}
}

//============================================================================
//
//  A_CheckPlayerDone
//
//============================================================================

final void A_CheckPlayerDone()
{
	if (!bIsPlayer)
	{
		Destroy();
	}
}

//==========================================================================
//
//  A_SkullPop
//
//==========================================================================

final void A_SkullPop(optional class<Actor> SpawnType)
{
	EntityEx A;

	if (!class<PlayerChunk>(SpawnType))
	{
		SpawnType = BloodySkull;
	}
	bSolid = false;
	A = Spawn(SpawnType, Origin + vector(0.0, 0.0, 48.0),,, false);
	A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
	A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
	A.Velocity.z = (2.0 + Random() / 4.0) * 35.0;
	A.Health = Health;
	A.Angles.yaw = Angles.yaw;

	if (bIsPlayer)
	{
		// Attach player mobj to bloody skull
		A.Player = Player;
		A.bIsPlayer = true;
		A.ObtainInventory(EntityEx(Player.MO));
		Player = none;
		bIsPlayer = false;
		A.Player.MO = A;
		if (A.Player.Camera == self)
		{
			A.Player.Camera = A;
		}
		PlayerEx(A.Player).DamageFlash = 1.0;
		LineSpecialLevelInfo(Level).AddPlayerCorpse(self);
	}
}

//**************************************************************************
//	Spawn functions
//**************************************************************************

//==========================================================================
//
//	A_TossGib
//
//==========================================================================

final void A_TossGib()
{
	EntityEx gib;
	float an;
	float speed;
	class<EntityEx> tp;

	if (bNoBlood)
	{
		tp = Junk;
	}
	else
	{
		tp = Meat;
	}
	gib = Spawn(tp, Origin + vector(0.0, 0.0, 24.0));
	if (!gib)
	{
		return;
	}

	an = Random() * 360.0;
	gib.Angles.yaw = an;
	speed = Random() * 16.0 * 35.0;
	gib.Velocity.x = speed * cos(an);
	gib.Velocity.y = speed * sin(an);
	gib.Velocity.z = Random() * 16.0 * 35.0;
}

//==========================================================================
//
//	A_SpawnDebris
//
//==========================================================================

final void A_SpawnDebris(class<Actor> SpawnType, optional bool TransTransl,
	optional float MultH, optional float MultV)
{
	if (!SpawnType)
	{
		return;
	}
	if (MultH <= 0.0)
	{
		MultH = 1.0;
	}
	if (MultV <= 0.0)
	{
		MultV = 1.0;
	}

	int i;
	for (i = 0; i < SpawnType.default.Health; i++)
	{
		EntityEx A = Spawn(SpawnType, Origin + vector((Random() - 0.5) * 16.0,
			(Random() - 0.5) * 16.0, Random() * Height));
		if (A && TransTransl)
		{
			A.Translation = Translation;
		}
		//	The way it uses states sucks big time.
		if (A && i < GetClassNumOwnedStates(SpawnType))
		{
			A.SetState(GetStatePlus(GetClassFirstState(SpawnType), i));
			A.Velocity.x = MultH * (Random() - Random()) * 4.0 * 35.0;
			A.Velocity.y = MultH * (Random() - Random()) * 4.0 * 35.0;
			A.Velocity.z = MultV * (Random() * 8.0 + 5.0) * 35.0;
		}
	}
}

//==========================================================================
//
//	A_SpawnItem
//
//==========================================================================

final void InitSpawnedItem(EntityEx A, bool TransTransl, bool SetMaster,
	bool NoCheckPos)
{
	if (!A)
	{
		return;
	}

	if (TransTransl && !bDontTranslate)
	{
		A.Translation = Translation;
	}

	//	Find instigator for missiles.
	EntityEx Instig = self;
	while (Instig && Instig.IsMissile(true))
	{
		Instig = Instig.Target;
	}

	if (A.bMonster)
	{
		//	Check if thing fits in it's current location.
		if (!NoCheckPos && !A.TestLocation())
		{
			A.Destroy();
			//	Set result for state chain calls.
			if (XLevel.StateCall)
			{
				XLevel.StateCall->Result = false;
			}
			return;
		}

		if (Instig)
		{
			if (Instig.bMonster)
			{
				A.bFriendly = bFriendly;
				if (SetMaster)
				{
					A.Master = self;
				}
			}
			else if (Instig.bIsPlayer)
			{
				//	Make monster friendly.
				A.bFriendly = true;
				EntityEx Atk = PlayerEx(Player).Attacker;
				if (Atk && !Atk.bFriendly)
				{
					//	Make it attack monster who last attacked player.
					A.Target = Atk;
				}
			}
		}
	}
	else
	{
		//	For missiles or anything else set target to instigator.
		if (!Instig)
		{
			Instig = self;
		}
		A.Target = Instig;
	}
}

//==========================================================================
//
//	A_SpawnItem
//
//==========================================================================

final void A_SpawnItem(class<Actor> ItemType, optional float Distance,
	optional float ZHeight, optional bool UseAmmo, optional bool TransTransl)
{
	if (!specified_UseAmmo)
	{
		UseAmmo = true;
	}

	if (!ItemType)
	{
		if (XLevel.StateCall)
		{
			XLevel.StateCall->Result = false;
		}
		return;
	}

	//	Don't spawn monsters if this actor has been massacred
	if (DamageType == 'Massacre' && ItemType.default.bMonster)
	{
		return;
	}

	if (!Distance)
	{
		Distance = Radius + ItemType.default.Radius;
	}

	//	If called from weapon, then use ammo.
	if (bIsPlayer &&
		(XLevel.CallingState == Player.ViewStates[ps_weapon].State ||
		XLevel.CallingState == Player.ViewStates[ps_flash].State))
	{
		Weapon Wpn = PlayerEx(Player).ReadyWeapon;
		if (!Wpn)
		{
			return;
		}
		if (UseAmmo && !Wpn.DepleteAmmo())
		{
			return;
		}
	}

	EntityEx A = Spawn(ItemType, Origin + vector(Distance * cos(Angles.yaw),
		Distance * sin(Angles.yaw), ZHeight - FloorClip));
	InitSpawnedItem(A, TransTransl, UseAmmo, false);
}

//==========================================================================
//
//	A_SpawnItem
//
//==========================================================================

final void A_SpawnItemEx(class<Actor> ItemType, optional float XOffs,
	optional float YOffs, optional float ZOffs, optional float XVel,
	optional float YVel, optional float ZVel, optional float Angle,
	optional int Flags, optional int Chance)
{
	if (!ItemType)
	{
		if (XLevel.StateCall)
		{
			XLevel.StateCall->Result = false;
		}
		return;
	}

	if (Chance > 0 && P_Random() < Chance)
	{
		return;
	}

	//	Don't spawn monsters if this actor has been massacred
	if (DamageType == 'Massacre' && ItemType.default.bMonster)
	{
		return;
	}

	if (!(Flags & 4))
	{
		Angle += Angles.yaw;
	}

	TVec Org = vector(XOffs, YOffs, ZOffs - FloorClip);
	if (!(Flags & 2))
	{
		//	In relative mode negative y values mean 'left' and positive ones
		// mean 'right'. This is the inverse orientation of the absolute mode!
		Org.y = -Org.y;
		VectorRotateAroundZ(&Org, Angle);
	}
	Org += Origin;

	EntityEx A = Spawn(ItemType, Org);
	InitSpawnedItem(A, !!(Flags & 1), !!(Flags & 16), !!(Flags & 32));
	if (A)
	{
		A.Velocity.x = XVel * 35.0;
		A.Velocity.y = YVel * 35.0;
		A.Velocity.z = ZVel * 35.0;
		A.Angles.yaw = Angle;
		if (!(Flags & 8))
		{
			//	The same issue as with offsets.
			A.Velocity.y = -A.Velocity.y;
			VectorRotateAroundZ(&A.Velocity, Angle);
		}
		if (Flags & 64)
		{
			A.TeleportMove(A.Origin, true);
		}
	}
}

//**************************************************************************
//	State jumps
//**************************************************************************

//==========================================================================
//
//  A_Jump
//
//==========================================================================

final void A_Jump(int Chance, state Label1, optional state Label2,
	optional state Label3, optional state Label4, optional state Label5,
	optional state Label6, optional state Label7, optional state Label8)
{
	if (P_Random() < Chance)
	{
		if (!specified_Label2)
		{
			DoJump(Label1);
		}
		else
		{
			array<state> List;
			List[0] = Label1;
			List[1] = Label2;
			if (specified_Label3)
			{
				List[2] = Label3;
			}
			if (specified_Label4)
			{
				List[3] = Label4;
			}
			if (specified_Label5)
			{
				List[4] = Label5;
			}
			if (specified_Label6)
			{
				List[5] = Label6;
			}
			if (specified_Label7)
			{
				List[6] = Label7;
			}
			if (specified_Label8)
			{
				List[7] = Label8;
			}
			DoJump(List[P_Random() % List.Num]);
		}
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIf
//
//==========================================================================

final void A_JumpIf(bool Expr, state Label)
{
	if (Expr)
	{
		DoJump(Label);
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIfCloser
//
//==========================================================================

final void A_JumpIfCloser(float Dist, state Label)
{
	EntityEx Targ;

	if (!bIsPlayer)
	{
		Targ = Target;
	}
	else
	{
		TVec Dir;
		Targ = Aim(Dir, 16.0 * 64.0);
	}

	if (Targ && DistTo2(Targ) < Dist && ((Origin.z > Targ.Origin.z &&
		Origin.z - Target.Origin.z - Target.Height < Dist) ||
		(Origin.z <= Targ.Origin.z &&
		Target.Origin.z - Origin.z - Height < Dist)))
	{
		DoJump(Label);
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIfHealthLower
//
//==========================================================================

final void A_JumpIfHealthLower(int HealthVal, state Label)
{
	if (Health < HealthVal)
	{
		DoJump(Label);
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIfInventory
//
//==========================================================================

final void A_JumpIfInventory(class<Actor> ItemType, int Amount, state Label)
{
	if (ItemType)
	{
		Inventory Item = FindInventory(class<Inventory>(ItemType));
		if (Item)
		{
			if ((Amount > 0 && Item.Amount >= Amount) ||
				(Amount == 0 && Item.Amount >= Item.MaxAmount))
			{
				DoJump(Label);
			}
		}
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIfInTargetInventory
//
//==========================================================================

final void A_JumpIfInTargetInventory(class<Actor> ItemType, int Amount, state Label)
{
	if (ItemType && Target)
	{
		Inventory Item = Target.FindInventory(class<Inventory>(ItemType));
		if (Item)
		{
			if ((Amount > 0 && Item.Amount >= Amount) ||
				(Amount == 0 && Item.Amount >= Item.MaxAmount))
			{
				DoJump(Label);
			}
		}
	}

	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//==========================================================================
//
//  A_JumpIfTargetInLOS
//
//==========================================================================

final void A_JumpIfTargetInLOS(state Label, optional float Fov)
{
	//	State jumps should not affect state chain results.
	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	EntityEx Targ;
	if (!bIsPlayer)
	{
		Targ = Target;
		if (!Targ || !CanSee(Targ))
		{
			return;
		}
		if (Fov && Fov < 360.0)
		{
			float Ang = AngleMod180(atan2(Targ.Origin.y - Origin.y,
				Targ.Origin.x - Origin.x) - Angles.yaw);
			if (fabs(Ang) > Fov / 2.0)
			{
				return;
			}
		}
	}
	else
	{
		TVec Dir;
		Targ = Aim(Dir, 16.0 * 64.0);
	}

	if (Targ)
	{
		DoJump(Label);
	}
}

//**************************************************************************
//	Flags and appearance
//**************************************************************************

//==========================================================================
//
//  A_SetFloorClip
//
//==========================================================================

final void A_SetFloorClip()
{
	bFloorClip = true;
	HandleFloorclip();
}

//==========================================================================
//
//  A_UnSetFloorClip
//
//==========================================================================

final void A_UnSetFloorClip()
{
	bFloorClip = false;
	FloorClip = 0.0;
}

//==========================================================================
//
//  A_HideThing
//
//==========================================================================

final void A_HideThing()
{
	bInvisible = true;
}

//==========================================================================
//
//  A_UnHideThing
//
//==========================================================================

final void A_UnHideThing()
{
	bInvisible = false;
}

//==========================================================================
//
//  A_SetInvulnerable
//
//==========================================================================

final void A_SetInvulnerable()
{
	bInvulnerable = true;
}

//==========================================================================
//
//  A_UnSetInvulnerable
//
//==========================================================================

final void A_UnSetInvulnerable()
{
	bInvulnerable = false;
}

//==========================================================================
//
//	A_SetReflective
//
//==========================================================================

final void A_SetReflective()
{
	bReflective = true;
}

//==========================================================================
//
//	A_UnSetReflective
//
//==========================================================================

final void A_UnSetReflective()
{
	bReflective = false;
}

//==========================================================================
//
//	A_SetReflectiveInvulnerable
//
//==========================================================================

final void A_SetReflectiveInvulnerable()
{
	bReflective = true;

	A_SetInvulnerable();
}

//==========================================================================
//
//	A_UnSetReflectiveInvulnerable
//
//==========================================================================

final void A_UnSetReflectiveInvulnerable()
{
	bReflective = false;

	A_UnSetInvulnerable();
}

//==========================================================================
//
//	A_SetShootable
//
//==========================================================================

final void A_SetShootable()
{
	bNonShootable = false;
	bShootable = true;
}

//==========================================================================
//
//	A_UnSetShootable
//
//==========================================================================

final void A_UnSetShootable()
{
	bNonShootable = true;
	bShootable = false;
}

//===========================================================================
//
//  A_NoGravity
//
//===========================================================================

final void A_NoGravity()
{
	bNoGravity = true;
}

//===========================================================================
//
//  A_Gravity
//
//===========================================================================

final void A_Gravity()
{
	bNoGravity = false;
	Gravity = 1.0;
}

//===========================================================================
//
//  A_LowGravity
//
//===========================================================================

final void A_LowGravity()
{
	bNoGravity = false;
	Gravity = 0.125;
}

//==========================================================================
//
//  A_NoBlocking
//
//  Unset blocking.
//
//==========================================================================

final void A_NoBlocking()
{
	int					SpeechNum;
	RogueConSpeech*		Speech;
	class<EntityEx>		DropItemType;
	int					i;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		Alpha = 1.0;
		VisDir = 0;
	}

	// actor is on ground, it can be walked over
	bSolid = false;

	SpeechNum = GetSpeech();
	if (SpeechNum)
	{
		//	Drop stuff as determined by conversation.
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		DropItemType = LineSpecialLevelInfo(Level).GetClassFromID(Speech->DropItem);
		if (DropItemType)
		{
			DropItem(DropItemType, 0, 1.0);
			return;
		}
	}

	// Check for monsters dropping things
	if (ShouldDropItems())
	{
		if (DropItemList.Num)
		{
			for (i = 0; i < DropItemList.Num; i++)
			{
				if (DropItemList[i].Type)
				{
					DropItem(class<EntityEx>(DropItemList[i].Type),
						DropItemList[i].Amount, DropItemList[i].Chance);
				}
			}
		}
		else
		{
			NoBlockingSet();
		}
	}
}

//==========================================================================
//
//	A_Fall
//
//	For compatibility
//
//==========================================================================

final void A_Fall()
{
	A_NoBlocking();
}

//==========================================================================
//
//	A_SetSolid
//
//==========================================================================

final void A_SetSolid()
{
	bSolid = true;
}

//==========================================================================
//
//	A_UnsetSolid
//
//==========================================================================

final void A_UnsetSolid()
{
	bSolid = false;
}

//==========================================================================
//
//	A_SetFloat
//
//==========================================================================

final void A_SetFloat()
{
	bFloat = true;
}

//==========================================================================
//
//	A_UnsetFloat
//
//==========================================================================

final void A_UnsetFloat()
{
	bFloat = false;
	bInFloat = false;
}

//==========================================================================
//
//	A_ScreamAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ScreamAndUnblock()
{
	A_Scream();
	A_NoBlocking();
}

//==========================================================================
//
//	A_ActiveAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ActiveAndUnblock()
{
	A_ActiveSound();
	A_NoBlocking();
}

//==========================================================================
//
//	A_SetShadow
//
//==========================================================================

final void A_SetShadow()
{
	bUnknown2 = true;
	bShadow = true;
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
}

//==========================================================================
//
//	A_ClearShadow
//
//==========================================================================

final void A_ClearShadow()
{
	bUnknown2 = false;
	bShadow = false;
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;
}

//==========================================================================
//
//	A_SetTranslucent
//
//==========================================================================

final void A_SetTranslucent(float AlphaVal, optional int Mode)
{
	if (AlphaVal < 0.0)
	{
		AlphaVal = 0.0;
	}
	else if (AlphaVal > 1.0)
	{
		AlphaVal = 1.0;
	}

	Alpha = 1.0;
	RenderStyle = Mode == 0 ? STYLE_Translucent : Mode == 2 ?
		STYLE_Fuzzy : STYLE_Add;
}

//==========================================================================
//
//	A_FadeIn
//
//==========================================================================

final void A_FadeIn(optional float Val)
{
	if (!Val)
	{
		Val = 0.1;
	}
	Alpha += Val;
}

//==========================================================================
//
//	A_FadeOut
//
//==========================================================================

final void A_FadeOut(optional float Val)
{
	if (!Val)
	{
		Val = 0.1;
	}
	Alpha -= Val;
	if (Alpha <= 0.0)
	{
		Destroy();
	}
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (LineSpecialLevelInfo(Level).corpseQueueSlot >=
		LineSpecialLevelInfo(Level).CorpseQueSize)
	{
		// Too many corpses - remove an old one
		corpse = LineSpecialLevelInfo(Level).corpseQueue[
			LineSpecialLevelInfo(Level).corpseQueueSlot %
			LineSpecialLevelInfo(Level).CorpseQueSize];
		if (corpse)
		{
			corpse.Destroy();
		}
	}
	LineSpecialLevelInfo(Level).corpseQueue[
		LineSpecialLevelInfo(Level).corpseQueueSlot %
		LineSpecialLevelInfo(Level).CorpseQueSize] = self;
	LineSpecialLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < LineSpecialLevelInfo(Level).CorpseQueSize; slot++)
	{
		if (LineSpecialLevelInfo(Level).corpseQueue[slot] == self)
		{
			LineSpecialLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//**************************************************************************
//	Missile movement
//**************************************************************************

//==========================================================================
//
//  A_SeekerMissile
//
//==========================================================================

final void A_SeekerMissile(int Threshold, int TurnMax)
{
	if (Threshold < 0)
	{
		Threshold = 0;
	}
	else if (Threshold > 90)
	{
		Threshold = 90;
	}
	if (TurnMax < 0)
	{
		TurnMax = 0;
	}
	else if (TurnMax > 90)
	{
		TurnMax = 90;
	}
	SeekerMissile(itof(Threshold), itof(TurnMax));
}

//==========================================================================
//
//  A_Tracer
//
//  Ravenant missile tracer.
//
//==========================================================================

const float TRACEADJUST = 0.2865921825;

final void A_Tracer()
{
	EntityEx A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (XLevel.TicTime & 3)
	{
		return;
	}

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin, MISSILERANGE, BulletPuff, false);

	A = Spawn(RevenantTracerSmoke, Origin - Velocity * Level.Game.frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
	{
		A.StateTime = 0.1;
	}

	// adjust direction
	if (!Tracer || Tracer.Health <= 0)
	{
		return;
	}

	wishdir = Normalise(Tracer.GetCentre() - Origin);
	currdir = Normalise(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > TRACEADJUST)
	{
		adjustlen = TRACEADJUST;
	}
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//	A_Tracer2
//
//==========================================================================

const float TRACE2ANGLE	= (7.0 * 45.0 / 16.0);

final void A_Tracer2()
{
	EntityEx dest;
	float exact;
	float dist;
	float slope;

	dest = Tracer;

	if (!dest || dest.Health <= 0)
		return;

	// change angle
	exact = atan2(dest.Origin.y - Origin.y, dest.Origin.x - Origin.x);

	if (exact != Angles.yaw)
	{
		if (AngleMod360(exact - Angles.yaw) > 180.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - TRACE2ANGLE);
			if (AngleMod360(exact - Angles.yaw) < 180.0)
				Angles.yaw = exact;
		}
		else
		{
			Angles.yaw = AngleMod360(Angles.yaw + TRACE2ANGLE);
			if (AngleMod360(exact - Angles.yaw) > 180.0)
				Angles.yaw = exact;
		}
	}

	exact = Angles.yaw;
	Velocity.x = Speed * cos(exact);
	Velocity.y = Speed * sin(exact);

	// change slope
	dist = DistTo2(dest);
	dist /= Speed;

	if (dist < 1.0)
	{
		dist = 1.0;
	}
	slope = (dest.Origin.z + 40.0 - Origin.z) / dist;
	if (slope < Velocity.z)
	{
		Velocity.z -= 1.0 / 8.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 / 8.0 * 35.0;
	}
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

final void A_Fire()
{
	if (!Target || !Tracer)
	{
		return;
	}

	// don't move it if the vile lost sight
	if (!Target.CanSee(Tracer))
	{
		return;
	}

	UnlinkFromWorld();
	Origin.x = Tracer.Origin.x + 24.0 * cos(Tracer.Angles.yaw);
	Origin.y = Tracer.Origin.y + 24.0 * sin(Tracer.Angles.yaw);
	Origin.z = Tracer.Origin.z;
	LinkToWorld();
}

//==========================================================================
//
//	A_BishopMissileWeave
//
//==========================================================================

final void A_BishopMissileWeave()
{
	int WeaveXY = Special2 >> 16;
	int WeaveZ = Special2 & 0xffff;
	float angle = AngleMod360(Angles.yaw + 90.0);
	float newX = Origin.x - cos(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 2.0;
	float newY = Origin.y - sin(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 2.0;
	WeaveXY = (WeaveXY + 2) & 63;
	newX += cos(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 2.0;
	newY += sin(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 2.0;
	TryMove(vector(newX, newY, Origin.z));
	Origin.z -= Level.Game.FloatBobOffsets[WeaveZ];
	WeaveZ = (WeaveZ + 2) & 63;
	Origin.z += Level.Game.FloatBobOffsets[WeaveZ];
	Special2 = (WeaveXY << 16) | WeaveZ;
}

//============================================================================
//
//  A_CStaffMissileSlither
//
//============================================================================

final void A_CStaffMissileSlither()
{
	int WeaveXY = Special2;
	float angle = AngleMod360(Angles.yaw + 90.0);
	float newX = Origin.x - cos(angle) * Level.Game.FloatBobOffsets[WeaveXY];
	float newY = Origin.y - sin(angle) * Level.Game.FloatBobOffsets[WeaveXY];
	WeaveXY = (WeaveXY + 3) & 63;
	newX += cos(angle) * Level.Game.FloatBobOffsets[WeaveXY];
	newY += sin(angle) * Level.Game.FloatBobOffsets[WeaveXY];
	TryMove(vector(newX, newY, Origin.z));
	Special2 = WeaveXY;
}

//==========================================================================
//
//	A_Countdown
//
//==========================================================================

final void A_Countdown()
{
	if (--ReactionCount <= 0)
	{
		ExplodeMissile();
		bSkullFly = false;
	}
}

//==========================================================================
//
//	A_CountdownArg
//
//==========================================================================

final void A_CountdownArg(int Index)
{
	if (Index <= 0 || Index > 5)
	{
		return;
	}
	if (!Args[Index - 1]--)
	{
		if (bMissile)
		{
			ExplodeMissile();
		}
		else if (bShootable)
		{
			Damage(none, none, Health);
		}
		else
		{
			SetState(FindState('Death'));
		}
	}
}

//============================================================================
//
//  A_Stop
//
//============================================================================

final void A_Stop()
{
	Velocity = vector(0.0, 0.0, 0.0);
}

//**************************************************************************
//	Inventory functions
//**************************************************************************

//==========================================================================
//
//	DoGiveInventory
//
//==========================================================================

final void DoGiveInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (!Amount)
	{
		Amount = 1;
	}
	bool Ret = true;
	if (ItemType)
	{
		Inventory Item = Spawn(ItemType,,,, false);
		if (Health(Item))
		{
			Item.Amount *= Amount;
		}
		else
		{
			Item.Amount = Amount;
		}
		Item.bDropped = true;
		if (!Item.TryPickup(Receiver))
		{
			Item.Destroy();
			Ret = false;
		}
	}
	else
	{
		Ret = false;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = Ret;
	}
}

//==========================================================================
//
//	A_GiveInventory
//
//==========================================================================

final void A_GiveInventory(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_GiveToTarget
//
//==========================================================================

final void A_GiveToTarget(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	DoTakeInventory
//
//==========================================================================

final void DoTakeInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	Inventory Item = Receiver.FindInventory(ItemType);
	if (Item && !HexenArmor(Item))
	{
		if (Item.Amount > 0 && XLevel.StateCall)
		{
			XLevel.StateCall->Result = true;
		}
		if (!Amount || Item.Amount <= Amount)
		{
			if (Item.bKeepDepleted)
			{
				Item.Amount = 0;
			}
			else
			{
				Item.Destroy();
			}
		}
		else
		{
			Item.Amount -= Amount;
		}
	}
}

//==========================================================================
//
//	A_TakeInventory
//
//==========================================================================

final void A_TakeInventory(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_TakeFromTarget
//
//==========================================================================

final void A_TakeFromTarget(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	A_DropInventory
//
//==========================================================================

final void A_DropInventory(class<Inventory> ItemType)
{
	Inventory Item = FindInventory(ItemType);
	if (Item)
	{
		DropInventory(Item);
	}
}

//==========================================================================
//
//	A_SelectWeapon
//
//==========================================================================

final void A_SelectWeapon(class<Weapon> WeaponType)
{
	if (!bIsPlayer)
	{
		return;
	}

	Weapon Wpn = Weapon(FindInventory(WeaponType));
	if (Wpn)
	{
		if (PlayerEx(Player).ReadyWeapon != Wpn)
		{
			PlayerEx(Player).PendingWeapon = Wpn;
		}
	}
	else if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//**************************************************************************
//	Weapon functions
//**************************************************************************

final void A_Recoil(float Force)
{
	TVec Dir;
	AngleVector(&Angles, &Dir);
	Velocity += Dir * Force * 35.0;
}

//**************************************************************************
//	Weapon attack functions
//**************************************************************************

//===========================================================================
//
//  A_Punch
//
//===========================================================================

final void A_Punch()
{
	int			damage;
	TAVec		aimAngles;
	TVec		dir;
	EntityEx	AimTarget;

	if (bIsPlayer)
	{
		Weapon Wpn = PlayerEx(Player).ReadyWeapon;
		if (Wpn)
		{
			if (!Wpn.DepleteAmmo())
			{
				return;
			}
		}
	}

	damage = (P_Random() % 10 + 1) << 1;

	if (FindInventory(PowerStrength))
		damage *= 10;

	aimAngles = Angles;
	aimAngles.yaw = AngleMod360(aimAngles.yaw + (Random() -
		Random()) * 45.0 / 8.0);
	AimTarget = AimLineAttack(dir, aimAngles, MELEERANGE);
	LineAttack(dir, MELEERANGE, damage, BulletPuff);

	// turn to face target
	if (AimTarget)
	{
		PlaySound('*fist', CHAN_WEAPON);
		Angles.yaw = atan2(AimTarget.Origin.y - Origin.y,
			AimTarget.Origin.x - Origin.x);
		if (bIsPlayer)
		{
			Player.bFixAngle = true;
		}
	}
}

//==========================================================================
//
//	A_FireAssaultGun
//
//==========================================================================

final void A_FireAssaultGun()
{
	TVec dir;
	TAVec angles;
	int damage;

	PlaySound('weapons/assaultgun', CHAN_WEAPON);

	if (bIsPlayer)
	{
		Weapon Wpn = PlayerEx(Player).ReadyWeapon;

		if (!Wpn.DepleteAmmo())
		{
			return;
		}

		SetState(MissileState);

		Aim(dir, 16.0 * 64.0);
		if (PlayerEx(Player).Refire)
		{
			VectorAngles(&dir, &angles);
			angles.yaw = AngleMod360(angles.yaw +
				(Random() - Random()) * 45.0 / 2.0 /
				itof(1 << (PlayerEx(Player).Accuracy * 5 / 100)));
			AngleVector(&angles, &dir);
		}
	}
	else
	{
		Aim(dir, 16.0 * 64.0);
	}

	damage = 4 * (P_Random() % 3 + 1);
	LineAttack(dir, MISSILERANGE, damage, StrifePuff);
}

//**************************************************************************
//	Original Doom/Strife monster attacks
//**************************************************************************

//==========================================================================
//
//  A_PosAttack
//
//  Zombieman attack.
//
//==========================================================================

final void A_PosAttack()
{
	int damage;
	TVec dir;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);

	PlaySound('grunt/attack', CHAN_WEAPON);

	damage = ((P_Random() % 5) + 1) * 3;

	LineAttack(dir, MISSILERANGE, damage, BulletPuff);
}

//==========================================================================
//
//  A_SPosAttack
//
//  For DeHackEd compatibility only.
//
//==========================================================================

final void A_SPosAttack()
{
	if (!Target)
	{
		return;
	}

	PlaySound('shotguy/attack', CHAN_WEAPON);
	DoSPosAttack();
}

//==========================================================================
//
//  A_SPosAttackUseAtkSound
//
//  Shotgun guy, Spider mastermind attack.
//
//==========================================================================

final void A_SPosAttackUseAtkSound()
{
	if (!Target)
	{
		return;
	}

	PlaySound(AttackSound, CHAN_WEAPON);
	DoSPosAttack();
}

//==========================================================================
//
//  DoSPosAttack
//
//==========================================================================

final void DoSPosAttack()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	A_FaceTarget();
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, BulletPuff);
	}
}

//==========================================================================
//
//  A_CPosAttack
//
//  Heavy weapon dude attack.
//
//==========================================================================

final void A_CPosAttack()
{
	int damage;
	TVec dir;

	if (!Target)
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	//FIXME
	PlaySound(AttackSound, CHAN_WEAPON);
	A_FaceTarget();
	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage, BulletPuff);
}

//==========================================================================
//
//  A_CPosRefire
//
//  Heavy weapon dude refire.
//
//==========================================================================

final void A_CPosRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 40)
	{
		return;
	}

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

final void A_SpidRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_TroopAttack
//
//  Imp attack.
//
//==========================================================================

final void A_TroopAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('imp/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 3;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, DoomImpBall);
}

//==========================================================================
//
//  A_SargAttack
//
//  Demon, Spectre attack.
//
//==========================================================================

final void A_SargAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 4;
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_HeadAttack
//
//  Cacodemon attack.
//
//==========================================================================

final void A_HeadAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = (P_Random() % 6 + 1) * 10;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, CacodemonBall);
}

//==========================================================================
//
//  A_BruisAttack
//
//  Hell knight, Baron of hell attack.
//
//==========================================================================

final void A_BruisAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	if (CheckMeleeRange())
	{
		PlaySound('baron/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 10;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, BaronBall);
}

//==========================================================================
//
//  A_SkullAttack
//
//  Lost soul attack. Fly at the player like a missile.
//
//==========================================================================

const float SKULLSPEED = 700.0;

final void A_SkullAttack()
{
	if (!Target)
	{
		return;
	}

	bSkullFly = true;

	PlaySound(AttackSound, CHAN_VOICE);
	A_FaceTarget();
	Velocity = Normalise(Target.GetCentre() - Origin) * SKULLSPEED;
}

//==========================================================================
//
//  A_BspiAttack
//
//  Arachnotron attack.
//
//==========================================================================

final void A_BspiAttack()
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	// launch a missile
	SpawnMissile(Target, ArachnotronPlasma);
}

//==========================================================================
//
//  A_CyberAttack
//
//  Cyberdemon attack.
//
//==========================================================================

final void A_CyberAttack()
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	SpawnMissile(Target, Rocket);
}

//==========================================================================
//
//  A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

final void A_PainAttack()
{
	decorate_A_PainAttack(LostSoul);
}

//==========================================================================
//
//  decorate_A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

final void decorate_A_PainAttack(optional class<Actor> SpawnType)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	PainShootSkull(SpawnType, Angles.yaw);
}

//==========================================================================
//
//  A_DualPainAttack
//
//==========================================================================

final void A_DualPainAttack(optional class<Actor> SpawnType)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	PainShootSkull(SpawnType, Angles.yaw + 45.0);
	PainShootSkull(SpawnType, Angles.yaw - 45.0);
}

//==========================================================================
//
//  A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

final void A_PainDie()
{
	decorate_A_PainDie(LostSoul);
}

//==========================================================================
//
//  decorate_A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

final void decorate_A_PainDie(optional class<Actor> SpawnType)
{
	A_Fall();
	PainShootSkull(SpawnType, Angles.yaw + 90.0);
	PainShootSkull(SpawnType, Angles.yaw + 180.0);
	PainShootSkull(SpawnType, Angles.yaw + 270.0);
}

//==========================================================================
//
//  A_SkelFist
//
//  Ravenant close attack.
//
//==========================================================================

final void A_SkelFist()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 6;
		PlaySound('skeleton/melee', CHAN_WEAPON);
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_SkelMissile
//
//  Ravenant far attack.
//
//==========================================================================

final void A_SkelMissile()
{
	EntityEx A;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	Origin.z += 16.0;	// so missile spawns higher
	A = SpawnMissile(Target, RevenantTracer);
	Origin.z -= 16.0;	// back to normal

	if (A)
	{
		A.Origin = A.Origin + A.Velocity * 0.03;
		A.Tracer = Target;
		A.bSeekerMissile = true;
	}
}

//==========================================================================
//
//  A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

final void A_FatAttack1()
{
	decorate_A_FatAttack1(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

const float FatsoSpreadAngle = 90.0 / 8.0;

final void decorate_A_FatAttack1(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	// Change direction  to ...
	Angles.yaw = AngleMod360(Angles.yaw + FatsoSpreadAngle);
	SpawnMissile(Target, SpawnType);

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw + FatsoSpreadAngle);
		VectorRotateAroundZ(&A.Velocity, FatsoSpreadAngle);
	}
}

//==========================================================================
//
//  A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

final void A_FatAttack2()
{
	decorate_A_FatAttack2(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

final void decorate_A_FatAttack2(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	// Now here choose opposite deviation.
	Angles.yaw = AngleMod360(Angles.yaw - FatsoSpreadAngle);
	SpawnMissile(Target, SpawnType);

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw - FatsoSpreadAngle * 2.0);
		VectorRotateAroundZ(&A.Velocity, -FatsoSpreadAngle * 2.0);
	}
}

//==========================================================================
//
//  A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

final void A_FatAttack3()
{
	decorate_A_FatAttack3(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

final void decorate_A_FatAttack3(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw - FatsoSpreadAngle / 2.0);
		VectorRotateAroundZ(&A.Velocity, -FatsoSpreadAngle / 2.0);
	}

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw + FatsoSpreadAngle / 2.0);
		VectorRotateAroundZ(&A.Velocity, FatsoSpreadAngle / 2.0);
	}
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

final void A_VileTarget()
{
	EntityEx fog;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	fog = Spawn(ArchvileFire, Target.Origin);

	Tracer = fog;
	fog.Target = self;
	fog.Tracer = Target;
	fog.SetState(fog.IdleState);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

final void A_VileAttack()
{
	EntityEx fire;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	if (!CanSee(Target))
	{
		return;
	}

	PlaySound('vile/stop', CHAN_WEAPON);
	Target.Damage(self, self, 20);
	Target.Velocity.z = 1000.0 / Target.Mass * 35.0;

	fire = Tracer;

	if (!fire)
	{
		return;
	}

	// move the fire between the vile and the player
	fire.UnlinkFromWorld();
	fire.Origin.x = Target.Origin.x - 24.0 * cos(Angles.yaw);
	fire.Origin.y = Target.Origin.y - 24.0 * sin(Angles.yaw);
	fire.LinkToWorld();
	fire.RadiusAttack(self, 70, 70.0, true);
}

//==========================================================================
//
//  A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

final void A_BrainSpit()
{
	BrainState		BState;
	EntityEx		targ;
	EntityEx		A;
	float			Frac;

	//	Find brain state object, create it if not found.
	BState = none;
	foreach AllThinkers(BrainState, BState)
	{
		break;
	}
	if (!BState)
	{
		BState = Spawn(BrainState);
		BState.FindTargets();
	}

	if (!BState.Targets.Num)
	{
		//	No brain targets placed on a map.
		return;
	}

	BState.bEasy = !BState.bEasy;
	if (Level.Game.gameskill <= sk_easy && !BState.bEasy)
	{
		return;
	}

	// shoot a cube at current target
	targ = BState.Targets[BState.TargetOn];
	BState.TargetOn = (BState.TargetOn + 1) % BState.Targets.Num;

	// spawn brain missile
	A = SpawnMissile(targ, SpawnShot);
	if (A)
	{
		A.Target = targ;
		//	Prevent division by 0
		if (!A.Velocity.x && !A.Velocity.y)
		{
			Frac = 0.0;
		}
		else if (fabs(A.Velocity.x) > fabs(A.Velocity.y))
		{
			Frac = (targ.Origin.x - Origin.x) / A.Velocity.x;
		}
		else
		{
			Frac = (targ.Origin.y - Origin.y) / A.Velocity.y;
		}
		A.ReactionCount = ftoi(Frac / GetStateDuration(A.State));
	}

	PlaySound('brain/spit', CHAN_WEAPON, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_SpawnFly
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

final void A_SpawnFly()
{
	EntityEx newmobj;
	EntityEx fog;
	int r;
	class<EntityEx> type;

	if (--ReactionCount)
		return;	// still flying

	// First spawn teleport fog.
	fog = Spawn(SpawnFire, Target.Origin, vector(0.0, 0.0, 0.0));
	fog.PlaySound('brain/spawn', CHAN_VOICE);

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = DoomImp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Spectre;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = Archvile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Fatso;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Target.Origin, vector(0.0, 0.0, 0.0));
	if (newmobj.LookForPlayers(true))
		newmobj.SetState(newmobj.SeeState);

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);

	// remove self (i.e., cube).
	Destroy();
}

//==========================================================================
//
//  A_SpawnSound
//
//  Travelling cube sound.
//
//==========================================================================

final void A_SpawnSound()
{
	PlaySound('brain/cube', CHAN_VOICE);
	A_SpawnFly();
}

//==========================================================================
//
//  A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

final void A_BrainScream()
{
	TVec org;
	EntityEx A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(Rocket, org);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.SetState(FindClassState(BossBrain, 'BrainExplode'));

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	PlaySound('brain/death', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_BrainExplode
//
//  Brain explosions.
//
//==========================================================================

final void A_BrainExplode()
{
	TVec org;
	EntityEx A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(Rocket, org,,, false);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.SetState(FindClassState(BossBrain, 'BrainExplode'));

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//	A_Mushroom
//
//==========================================================================

final void A_Mushroom(class<Actor> SpawnType, optional int Amount)
{
	decorate_A_Mushroom();
}

//==========================================================================
//
//	decorate_A_Mushroom
//
//	killough 9/98: a mushroom explosion effect, sorta :)
//	Original idea: Linguica
//
//==========================================================================

final void decorate_A_Mushroom(optional class<Actor> SpawnType,
	optional int Amount)
{
	int			i;
	int			j;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}
	if (!Amount)
	{
		Amount = GetMissileDamage(0, 1);
	}

	// First make normal explosion
	A_Explode();

	// Now launch mushroom cloud
	// We need something to aim at.
	Actor target = Spawn(MapSpot,,,, false);
	target.Height = Height;
	for (i = -Amount; i <= Amount; i += 8)
	{
		for (j = -Amount; j <= Amount; j += 8)
		{
			// Aim in many directions from source
			target.Origin.x = Origin.x + itof(i);
			target.Origin.y = Origin.y + itof(j);
			// Aim up fairly high
			target.Origin.z = Origin.z + Length(vector(itof(i), itof(j),
				0.0)) * 4.0;
			// Launch fireball
			EntityEx mo = SpawnMissile(target, SpawnType);
			if (mo)
			{
				// Slow it down a bit
				mo.Velocity = mo.Velocity * 0.5;
				// Make debris fall under gravity
				mo.bNoGravity = false;
			}
		}
	}
	target.Destroy();
}

//===========================================================================
//
//  A_M_Saw
//
//===========================================================================

final void A_M_Saw()
{
	float		angle;
	int			damage;
	TAVec		aimAng;
	TVec		dir;
	EntityEx	AimTarget;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = 2 * (P_Random() % 10 + 1);
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw + (Random() -
			Random()) * 45.0 / 8.0);

		// use meleerange + 1 se the puff doesn't skip the flash
		AimTarget = AimLineAttack(dir, aimAng, MELEERANGE + 0.00001);
		LineAttack(dir, MELEERANGE + 0.00001, damage, BulletPuff);

		if (!AimTarget)
		{
			PlaySound('weapons/sawfull', CHAN_WEAPON);
			return;
		}
		PlaySound('weapons/sawhit', CHAN_WEAPON);

		// turn to face target
		angle = atan2(AimTarget.Origin.y - Origin.y,
			AimTarget.Origin.x - Origin.x);
		if (AngleMod360(angle - Angles.yaw) > 180.0)
		{
			if (AngleMod360(angle - Angles.yaw) < -90.0 / 20.0)
				Angles.yaw = angle + 90.0 / 21.0;
			else
				Angles.yaw = Angles.yaw - 90.0 / 20.0;
		}
		else
		{
			if (AngleMod360(angle - Angles.yaw) > 90.0 / 20.0)
				Angles.yaw = angle - 90.0 / 21.0;
			else
				Angles.yaw += 90.0 / 20.0;
		}
		Angles.yaw = AngleMod360(Angles.yaw);
	}
	else
	{
		PlaySound('weapons/sawfull', CHAN_WEAPON);
	}
}

//==========================================================================
//
//	A_SentinelRefire
//
//==========================================================================

final void A_SentinelRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 30)
	{
		return;
	}

	if (!Target || Target.Health <= 0 || !CanSee(Target) || P_Random() < 40)
	{
		SetState(SeeState);
	}
}

//**************************************************************************
//	Monster specific functions for Doom
//**************************************************************************

//==========================================================================
//
//  A_Hoof
//
//  Cyberdemon move with hoof sound.
//
//==========================================================================

final void A_Hoof()
{
	PlaySound('cyber/hoof', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

final void A_Metal()
{
	PlaySound('spider/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_BabyMetal
//
//  Arachnotron move with metal sound.
//
//==========================================================================

final void A_BabyMetal()
{
	PlaySound('baby/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_FatRaise
//
//  Mancubus attack sound.
//
//==========================================================================

final void A_FatRaise()
{
	A_FaceTarget();
	PlaySound('fatso/raiseguns', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SkelWhosh
//
//  Ravenant attack sound.
//
//==========================================================================

final void A_SkelWhoosh()
{
	if (!Target)
	{
		return;
	}
	A_FaceTarget();
	PlaySound('skeleton/swing', CHAN_WEAPON);
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

final void A_StartFire()
{
	PlaySound('vile/firestrt', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

final void A_FireCrackle()
{
	PlaySound('vile/firecrkl', CHAN_VOICE);
	A_Fire();
}

//===========================================================================
//
//  A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

final void A_BFGSpray()
{
	decorate_A_BFGSpray();
}

//===========================================================================
//
//  decorate_A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

final void decorate_A_BFGSpray(optional class<EntityEx> FlashType,
	optional int NumRays, optional int DamageAmount)
{
	int			i;
	int			j;
	int			damage;
	TAVec		aimAng;
	EntityEx	emo;
	TVec		Dir;
	EntityEx	AimTarget;

	if (!FlashType)
	{
		FlashType = BFGExtra;
	}
	if (NumRays <= 0)
	{
		NumRays = 40;
	}
	if (DamageAmount <= 0)
	{
		DamageAmount = 15;
	}

	// offset angles from its attack angle
	for (i = 0; i < NumRays; i++)
	{
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / itof(NumRays) *
			itof(i));

		// target is the originator (player)
		//  of the missile
		AimTarget = Target.AimLineAttack(Dir, aimAng, 16.0 * 64.0);
		if (!AimTarget)
		{
			continue;
		}

		emo = Spawn(FlashType, AimTarget.Origin +
			vector(0.0, 0.0, AimTarget.Height / 4.0));

		damage = 0;
		for (j = 0; j < DamageAmount; j++)
		{
			damage += (P_Random() & 7) + 1;
		}

		AimTarget.Damage(Target, Target, damage);
	}
}

//**************************************************************************
//	Not documented
//**************************************************************************

//===========================================================================
//
//  A_SetGravity
//
//===========================================================================

final void A_SetGravity(float Grav)
{
	Gravity = Grav;
	if (Gravity < 0.0)
	{
		Gravity = 0.0;
	}
	else if (Gravity > 1.0)
	{
		Gravity = 1.0;
	}
}

//===========================================================================
//
//  A_Respawn
//
//===========================================================================

final void A_Respawn(optional bool Fog)
{
	if (!specified_Fog)
	{
		Fog = true;
	}

	TVec Org;
	Org.x = SpawnPoint.x;
	Org.y = SpawnPoint.y;
	Org.z = GetPlanePointZ(&XLevel.PointInSector(Org)->floor, Org);
	SetOrigin(Org);
	bSolid = true;
	Height = default.Height;
	if (TestLocation())
	{
		Health = default.Health;

		//	Restore default flags
		RespawnResetFlags();
		SetState(IdleState);
		bInvisible = false;
		if (Fog)
		{
			EntityEx fog = Spawn(LineSpecialGameInfo(Level.Game).TeleportFogClass,
				Origin + vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
			fog.PlaySound('misc/teleport', CHAN_VOICE);
		}
		if (bCountKill)
		{
			Level.TotalKills++;
		}
	}
	else
	{
		bSolid = false;
	}
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  A_XXScream
//
//  Strife version of A_XScream.
//
//==========================================================================

final void A_XXScream()
{
	if (!bNoBlood || !DeathSound)
	{
		A_XScream();
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_RemoveForceField
//
//==========================================================================

final void A_RemoveForceField()
{
	int i;
	line_t* line;

	bSpecial = false;
	for (i = 0; i < Sector->linecount; i++)
	{
		line = Sector->lines[i];
		if (line->backsector && line->special == LNSPEC_ForceField)
		{
			line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);
			line->special = 0;
			XLevel.Sides[line->sidenum[0]].midtexture = 0;
			XLevel.Sides[line->sidenum[1]].midtexture = 0;
		}
	}
}

//==========================================================================
//
//	A_BeShadowyFoe
//
//==========================================================================

final void A_BeShadowyFoe()
{
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
	bFriendly = false;
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

final void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	Gravity = 1.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bCountKill = false;
	bMonster = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bPassMobj = false;
	RenderStyle = STYLE_None;
	Alpha = 0.0;
	Player = none;
	bIsPlayer = false;
	Health = -1000;	// Don't resurrect
}

//==========================================================================
//
//  A_ExecActionSpecial
//
//==========================================================================

final void A_ExecActionSpecial(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int Special)
{
	Level.ExecuteActionSpecial(Special, Arg1, Arg2, Arg3, Arg4, Arg5, NULL,
		0, self);

}

//==========================================================================
//
//  A_Feathers
//
//==========================================================================

final void A_Feathers()
{
	int i;
	int count;
	EntityEx mo;

	if (Health > 0)
	{
		// Pain
		count = P_Random() < 32 ? 2 : 1;
	}
	else
	{
		// Death
		count = 5 + (P_Random() & 3);
	}
	for (i = 0; i < count; i++)
	{
		mo = Spawn(Feather, Origin + vector(0.0, 0.0, 20.0));
		mo.Target = self;
		mo.Velocity.x = (Random() - Random()) * 35.0;
		mo.Velocity.y = (Random() - Random()) * 35.0;
		mo.Velocity.z = (1.0 + Random() * 2.0) * 35.0;
		mo.SetState(GetStatePlus(mo.IdleState, P_Random() & 7));
	}
}

//==========================================================================
//
//  A_PigPain
//
//==========================================================================

final void A_PigPain()
{
	A_Pain();
	if (Origin.z <= FloorZ)
	{
		Velocity.z = 3.5 * 35.0;
	}
}

//==========================================================================
//
//	A_RocketInFlight
//
//==========================================================================

final void A_RocketInFlight()
{
	EntityEx A;

	PlaySound('misc/missileinflight', CHAN_VOICE);
	SpawnPuff(Origin, MISSILERANGE, MiniMissilePuff, false);
	A = Spawn(RocketTrail, Origin - Velocity / 35.0);
	if (A)
	{
		A.Velocity.z = 1.0 * 35.0;
	}
}

//==========================================================================
//
//	A_Bang4Cloud
//
//==========================================================================

final void A_Bang4Cloud()
{
	Spawn(Bang4Cloud, Origin + vector(
		(Random() - Random()) * 5.0 / 8.0,
		(Random() - Random()) * 5.0 / 8.0, 0.0));
}

//==========================================================================
//
//	A_GiveQuestItem
//
//==========================================================================

final void A_GiveQuestItem()
{
	// This function does a lot more than just this
	if (DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
		PlaySound(DeathSound, 6);
	}

	//	Give quest item for destroying important object.
	//	Basicly all object using this function does this.
	int QuestType = ftoi(Speed / 35.0);
	class<Inventory> QClass = class<Inventory>(FindClass(
		StrToName(va("QuestItem%d", QuestType))));
	if (QClass)
	{
		EntityEx(Level.Game.Players[0].MO).GiveInventoryType(QClass);
		Level.Game.Players[0].cprint(va("$txt_quest_%d", QuestType));
	}
}

//==========================================================================
//
//	A_ItBurnsItBurns
//
//==========================================================================

final void A_ItBurnsItBurns()
{
	DeathSound = 'human/imonfire';
	A_Scream();
	if (bIsPlayer)
	{
		state WaveState = PlayerEx(Player).ReadyWeapon.FindState('BurnWave');
		if (WaveState)
		{
			Player.SetViewState(ps_weapon, WaveState);
			Player.SetViewState(ps_flash, none);
		}
	}
}

//==========================================================================
//
//	A_DropFire
//
//==========================================================================

final void A_DropFire()
{
	Actor A = Spawn(FireDroplet, Origin + vector(0.0, 0.0, 24.0));
	A.Velocity.z = -35.0;
	RadiusAttack(Target, 64, 64.0, false, 'Fire');
}

states
{
FreeTargMobj:
	TNT1 A 1050 A_FreeTargMobj
	Stop
Crunch:
	POL5 A -1
	Stop
GenericFreezeDeath:
	"----" A 5 A_GenericFreezeDeath
	"----" A 1 A_FreezeDeathChunks
	Wait
}

defaultproperties
{
}
