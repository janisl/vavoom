//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

struct sector_t;
struct line_t;
struct subsector_t;

//FIXME
#define classidNone		Object

//==========================================================================
//
//  3D math - vectors and panes
//
//==========================================================================

vector TVec
{
	float x;
	float y;
	float z;
};

vector TAVec
{
	float pitch;
	float yaw;
	float roll;
};

struct TPlane
{
	TVec normal;
	float dist;
	int __type;
	int __signbits;
	int __reserved1;
	int __reserved2;
};

//==========================================================================
//
//  Level
//
//==========================================================================

//
// LineDef
//
struct line_t:TPlane
{
	// Vertices, from v1 to v2.
	TVec *v1;
	TVec *v2;

	// Precalculated v2 - v1 for side checking.
	TVec __dir;

	// Animation related.
	int flags;

	// Visual appearance: SideDefs.
	//  sidenum[1] will be -1 if one sided
	int sidenum[2];

	// Neat. Another bounding box, for the extent
	//  of the LineDef.
	float bbox[4];

	// To aid move clipping.
	int __slopetype;

	// Front and back sector.
	// Note: redundant? Can be retrieved from SideDefs.
	sector_t *frontsector;
	sector_t *backsector;

	// if == validcount, already checked
	int validcount;

	int translucency;

	int special;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;

	addfields 5;
};

//
// The SideDef.
//
struct side_t
{
	// add this to the calculated texture column
	float textureoffset;

	// add this to the calculated texture top
	float rowoffset;

	float __base_textureoffset;
	float __base_rowoffset;

	// Texture indices.
	// We do not maintain names here.
	int toptexture;
	int bottomtexture;
	int midtexture;

	int __base_toptexture;
	int __base_bottomtexture;
	int __base_midtexture;

	// Sector the SideDef is facing.
	sector_t *sector;
};

struct sec_plane_t:TPlane
{
	float minz;
	float maxz;

	int pic;
	int __base_pic;

	float xoffs;
	float yoffs;

	int flags;
	int translucency;

	int LightSourceSector;
};

struct sec_params_t
{
	int lightlevel;
	int LightColor;
	int contents;
};

struct sec_region_t
{
	//  Linked list of regions in bottom to top order
	sec_region_t *prev;
	sec_region_t *next;

	//  Planes
	sec_plane_t *floor;
	sec_plane_t *ceiling;

	sec_params_t *params;
	line_t *extraline;
};

//
//  The SECTORS record, at runtime.
//  Stores things/mobjs.
//
struct sector_t
{
	sec_plane_t floor;
	sec_plane_t ceiling;
	sec_params_t params;

	sec_region_t *topregion;	//  Highest region
	sec_region_t *botregion;	//  Lowest region

	float floorheight;
	float ceilingheight;
	int special;
	int tag;

	float base_floorheight;
	float base_ceilingheight;
	int __base_lightlevel;

	float skyheight;

	// stone, metal, heavy, etc...
	int seqType;

	// mapblock bounding box for height changes
	int blockbox[4];

	// origin for any sounds played by the sector
	TVec soundorg;

	// if == validcount, already checked
	int validcount;

	// list of subsectors in sector
	// used to check if client can see this sector (it needs to be updated)
	void *__subsectors;

	int linecount;
	line_t **lines;	// [linecount] size

	//	Flags.
	bool		bHasExtrafloors;	//	This sector has extrafloors.
	bool		bExtrafloorSource;	//	This sector is a source of an extrafloor.

	addfields 16;
};

//
//  Polyobj data
//
struct polyobj_t
{
	int __numsegs;
	void *__segs;
	TVec startSpot;
	void *__originalPts;	// used as the base for the rotations
	void *__prevPts;		// use to restore the old point values
	float angle;
	int tag;				// reference tag assigned in HereticEd
	int __bbox[4];
	int validcount;
	bool bCrush;			// should the polyobj attempt to crush mobjs?
	int seqType;
	subsector_t *__subsector;
	float __base_x;
	float __base_y;
	float __base_angle;
	int __changed;
	addfields 3;
};

//
// Map thing definition with initialised fields for global use.
//
struct mthing_t
{
	int tid;
	float x;
	float y;
	float height;
	int angle;
	int type;
	int options;
	int special;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;
};

//
//  A SubSector.
//  References a Sector. Basically, this is a list of LineSegs, indicating
// the visible walls that define (all or some) sides of a convex BSP leaf.
//
struct subsector_t
{
	sector_t *sector;
	void *__seclink;
	int __numlines;
	int __firstline;
	polyobj_t *__poly;

	void *__parent;
	int __VisFrame;
	int __SkyVisFrame;
	void *__regions;
};

//
//	Strife conversation scripts
//

struct RogueConChoice
{
	int GiveItem;		//	Item given on success
	int NeedItem1;		//	Required item 1
	int NeedItem2;		//	Required item 2
	int NeedItem3;		//	Required item 3
	int NeedAmount1;	//	Amount of item 1
	int NeedAmount2;	//	Amount of item 2
	int NeedAmount3;	//	Amount of item 3
	int Text[32/4];		//	Text of the answer
	int TextOK[80/4];	//	Message displayed on success
	int Next;			//	Dialog to go on success, negative values to go
						// here immediately
	int Objectives;		//	Mission objectives, LOGxxxx lump
	int TextNo[80/4];	//	Message displayed on failure (player doesn't
						// have needed thing, it haves enough health/ammo,
						// item is not ready, quest is not completed)
};

struct RogueConSpeech
{
	int SpeakerID;		//	Type of the object (MT_xxx)
	int DropItem;		//	Item dropped when killed
	int CheckItem1;		//	Item 1 to check for jump
	int CheckItem2;		//	Item 2 to check for jump
	int CheckItem3;		//	Item 3 to check for jump
	int JumpToConv;		//	Jump to conversation if have certain item(s)
	int Name[16/4];		//	Name of the character
	int Voice[8/4];		//	Voice to play
	int BackPic[8/4];	//	Picture of the speaker
	int Text[320/4];	//	Message
	RogueConChoice Choices[5];	//	Choices
};

struct base_level_t
{
	float		time;
	int			tictime;

	int			totalkills;
	int			totalitems;
	int			totalsecret;	// for intermission
	int			currentkills;
	int			currentitems;
	int			currentsecret;

	int			mapname[3];
	int			levelnum;
	int			cluster;
	int			partime;
	int			__level_name[8];

	int			sky1Texture;
	int			sky2Texture;
	float		sky1ScrollDelta;
	float		sky2ScrollDelta;
	int			doubleSky;
	int			lightning;
	int			skybox[8];
	int			fadetable[3];

	int			cdTrack;
	int			songLump[3];
};

//**************************************************************************
//
//  Server types
//
//**************************************************************************

#ifdef SERVER

class Thinker;
class Entity;
class Actor;
class ViewEntity;
class Player;

struct state_t
{
	int sprite;
	int frame;
	int model_index;
	int model_frame;
	float time;
	int nextstate;
	int __function;
	name statename;
};

struct mobjinfo_t
{
	int doomednum;
	classid class_id;
};

//==========================================================================
//
//  Player
//
//==========================================================================

#define MAXNAME		32
#define MAX_MSGLEN	8000

//==========================================================================
//
//	Level
//
//==========================================================================

struct sv_level_t:base_level_t
{
	// Maintain single and multi player starting spots.
	mthing_t deathmatchstarts[MAXDEATHMATCHSTARTS];	// Player spawn spots for deathmatch.
	int numdeathmatchstarts;
	mthing_t playerstarts[MAX_PLAYER_STARTS * MAXPLAYERS];	// Player spawn spots.
};

//==========================================================================
//
//  Other stuff
//
//==========================================================================

struct opening_t
{
	float top;
	float bottom;
	float range;
	float lowfloor;
	sec_plane_t *floor;
	sec_plane_t *ceiling;
	opening_t *next;
};

#define PT_ADDLINES		1
#define PT_ADDTHINGS	2
#define PT_EARLYOUT		4

struct intercept_t
{
	float frac;	// along trace line
	bool bIsALine;
	Entity Thing;
	line_t *line;
};

addfields sector_t
{
	// 0 = untraversed, 1,2 = sndlines -1
	int			soundtraversed;

	// thing that made a sound (or null)
	Entity		SoundTarget;

	// Thinker for reversable actions
	Thinker		FloorData;
	Thinker		CeilingData;
	Thinker		LightingData;

	int			Damage;

	float		Friction;
	float		MoveFactor;
};

#define GRAVITY			1225.0

struct tmtrace_t
{
	Entity Thing;
	TVec End;
	float BBox[4];
	float FloorZ;
	float CeilingZ;
	float DropOffZ;
	sec_plane_t *Floor;
	sec_plane_t *Ceiling;

	bool bFloatOk;	// if true, move would be ok if
					// within tmtrace.FloorZ - tmtrace.CeilingZ

	// keep track of the line that lowers the ceiling,
	// so missiles don't explode against sky hack walls
	line_t *CeilingLine;

	// keep track of special lines as they are hit,
	// but don't process them until the move is proven valid
	#define MAXSPECIALCROSS	32
	line_t *SpecHit[MAXSPECIALCROSS];
	int NumSpecHit;

	Entity BlockingMobj;
};

//	Variables shared with progs.
struct server_vars_t
{
	Player Players[MAXPLAYERS]; // Bookkeeping on players - state.
};

#endif

//**************************************************************************
//
//  Client types
//
//**************************************************************************

#ifdef CLIENT

struct cl_level_t:base_level_t
{
};

struct model_t;

struct cl_pspdef_t
{
	int sprite;
	int frame;
	model_t *__alias_model;
	int alias_frame;
	int alias_skinnum;
	float sx;
	float sy;
};

struct client_state_t
{
	int clientnum;

	int pclass;	// player class type

	// Determine POV,
	//  including viewpoint bobbing during movement.
	// Focal origin above r.z
	TVec vieworg;
	TAVec viewangles;
	int centering;

	// This is only used between levels,
	// mo->health is used during levels.
	int health;

	int items;

	// Frags, kills of other players.
	int Frags;

	// So gun flashes light up areas.
	int extralight;

	// For lite-amp and invulnarability powers
	int fixedcolormap;

	// Current PLAYPAL index
	//  can be set to REDCOLORMAP for pain, etc.
	int palette;
	int prev_palette;

	int cshifts[NUM_CSHIFTS];	//  color shifts for damage,
	int prev_cshifts[NUM_CSHIFTS];	// powerups and content types

	// Overlay view sprites (gun, etc).
	cl_pspdef_t psprites[NUMPSPRITES];
	float pspriteSY;

	// True if secret level has been done.
	bool bDidSecret;

	bool bPaused;

	int worldTimer;	// total time the player's been playing

	// Overlay view sprites (gun, etc).
	int translucency;

	int maxclients;
	int deathmatch;

	float mtime[2];
	float time;
	float oldtime;

	int serverinfo[MAX_INFO_STRING / 4];

	int intermission;

	//  128 integers for user defined fields in PROGS
	addfields 128;
};

//
//  Server list
//

#define HOSTCACHESIZE		8

struct hostcache_t
{
	int Name[16 / 4];
	int map[16 / 4];
	int cname[32 / 4];
	int wadfiles[20][16 / 4];
	int users;
	int maxusers;
};

struct slist_t
{
	bool bInProgress;
	int count;
	hostcache_t cache[HOSTCACHESIZE];
	int return_reason[32 / 4];
};

struct scores_t
{
	int Name[64 / 4];
	bool bActive;
	int frags[MAXPLAYERS];
	int killcount;
	int itemcount;
	int secretcount;
	float time;
	int userinfo[MAX_INFO_STRING / 4];
};

struct im_t
{
	int leavemap[12 / 4];
	int leavecluster;
	int entermap[12 / 4];
	int entercluster;
	int leave_name[32 / 4];
	int enter_name[32 / 4];
	int totalkills;
	int totalitems;
	int totalsecret;
	float time;
};

struct picinfo_t
{
	int width;
	int height;
	int xoffset;
	int yoffset;
};

struct dlight_t
{
	TVec origin;
	float radius;
	float die;	// stop lighting after this time
	float decay;	// drop this each second
	float minlight;	// don't add when contributing less
	int key;
	int color;
};

struct particle_t
{
	TVec org;
	int color;
	particle_t *next;
	TVec vel;
	float die;
	addfields 7;
};

struct clmobj_t
{
	int in_use;

	TVec origin;	// position
	TAVec angles;	// orientation

	int spritetype;	//  How to draw sprite
	int sprite;	// used to find patch_t and flip value
	int frame;	// might be ORed with FF_FULLBRIGHT

	int model_index;
	model_t *__alias_model;
	int alias_frame;
	int skin[64 / 4];

	int translucency;
	int translation;

	int effects;
};

class ModalWindow;
class RootWindow;

struct ClipRect
{
	float OriginX;		// X origin of rectangle, in absolute coordinates
	float OriginY;		// Y origin of rectangle, in absolute coordinates

	float ClipX;		// Leftmost edge of rectangle relative to origin
	float ClipY;		// Topmost edge of rectangle relative to origin
	float ClipWidth;	// Width of rectangle
	float ClipHeight;	// Height of rectangle
};

#endif

//**************************************************************************
//
//  $Log$
//  Revision 1.54  2005/04/04 07:35:15  dj_jl
//  Palette flash state fix.
//
//  Revision 1.53  2005/03/28 07:48:33  dj_jl
//  Some Boom line specials.
//
//  Revision 1.52  2005/03/01 14:39:22  dj_jl
//  Big update of line specials.
//
//  Revision 1.51  2004/12/27 12:23:09  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.50  2003/11/12 16:48:02  dj_jl
//  Changed player structure into a class
//
//  Revision 1.49  2003/10/02 18:05:22  dj_jl
//  Fully working conversations.
//
//  Revision 1.48  2003/07/03 18:13:45  dj_jl
//  Moving extrafloors
//
//  Revision 1.47  2003/03/08 16:01:44  dj_jl
//  A little multiplayer fix.
//
//  Revision 1.46  2003/03/08 12:15:40  dj_jl
//  Menu code cleanup.
//
//  Revision 1.45  2002/10/26 16:32:14  dj_jl
//  New style of defining classes.
//
//  Revision 1.44  2002/09/07 16:28:22  dj_jl
//  Added Level class.
//
//  Revision 1.43  2002/08/28 16:36:36  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.42  2002/08/24 14:53:06  dj_jl
//  Implemented sloping with vertex heights.
//
//  Revision 1.41  2002/07/27 18:08:12  dj_jl
//  Implementing Strife conversations.
//
//  Revision 1.40  2002/07/23 13:07:28  dj_jl
//  Final touches for switching to floating-point time, beautification.
//
//  Revision 1.39  2002/06/29 15:58:14  dj_jl
//  Added total frags count.
//
//  Revision 1.38  2002/06/14 15:44:44  dj_jl
//  Added state names to the states.
//
//  Revision 1.37  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.36  2002/03/28 18:18:14  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.35  2002/03/12 19:20:24  dj_jl
//  Added native and abstract class modifiers
//
//  Revision 1.34  2002/03/09 17:57:00  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.33  2002/03/02 17:35:55  dj_jl
//  Weapon classes
//
//  Revision 1.32  2002/02/22 18:00:05  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.31  2002/02/16 16:27:44  dj_jl
//  Added bool variables
//
//  Revision 1.30  2002/02/14 19:20:54  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.29  2002/02/06 17:28:50  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.28  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.27  2002/01/21 18:21:32  dj_jl
//  Working on object-oriented menus
//
//  Revision 1.26  2002/01/17 18:15:50  dj_jl
//  Renamed all map object classes
//
//  Revision 1.25  2002/01/15 18:26:58  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.24  2002/01/15 08:12:25  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.23  2002/01/11 08:03:09  dj_jl
//  Renamed 'name' to "Name'
//
//  Revision 1.22  2002/01/07 12:19:56  dj_jl
//  Changed copyright year
//
//  Revision 1.21  2001/12/27 17:52:19  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.20  2001/12/18 18:38:11  dj_jl
//  Base object got some new fields, new thinker list
//
//  Revision 1.19  2001/12/12 19:15:27  dj_jl
//  Some little changes for state methods
//
//  Revision 1.18  2001/12/01 18:10:10  dj_jl
//  Started to use class references
//
//  Revision 1.17  2001/10/22 17:23:08  dj_jl
//  Floatification of angles
//
//  Revision 1.16  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.15  2001/10/12 17:26:06  dj_jl
//  Removed Actor define
//
//  Revision 1.14  2001/10/09 17:38:36  dj_jl
//  Got rid of mobj addfields
//
//  Revision 1.13  2001/10/08 17:23:15  dj_jl
//  Different client and server level structures
//
//  Revision 1.12  2001/10/04 17:28:47  dj_jl
//  Fixed thinkers size in level structure
//
//  Revision 1.11  2001/10/02 17:37:19  dj_jl
//  Removed status bar widgets
//
//  Revision 1.10  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.9  2001/09/25 17:13:50  dj_jl
//  Beautification
//
//  Revision 1.8  2001/09/24 17:11:23  dj_jl
//  Created thinker classes
//
//  Revision 1.7  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.6  2001/08/29 17:42:12  dj_jl
//  Added sound channel
//  
//  Revision 1.5  2001/08/15 17:07:10  dj_jl
//  Fixed finale
//
//  Revision 1.4  2001/08/07 16:42:25  dj_jl
//  Added player models, skins and weapon
//
//  Revision 1.3  2001/08/04 17:20:28  dj_jl
//  Changes to inform new clients about changed textures
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
