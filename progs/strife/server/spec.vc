//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MAX_TAGGED_LINES	64

// TYPES -------------------------------------------------------------------

struct tagged_line_t
{
	line_t *line;
	int lineTag;
};

// DATA DECLARATIONS -------------------------------------------------------

tagged_line_t TaggedLines[MAX_TAGGED_LINES];
int TaggedLineCount;

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Actor user, int lock)
{
	if (!user.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}

	if (lock <= 32)
	{
		//	Regular keys.
		if (!(user.Player.Keys & (1 << (lock - 1))))
		{
			centerprint(user.Player, "You need a key");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
	}
	else if (lock == 102)
	{
		centerprint(user.Player, "That doesn't seem to work");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}
	else if (lock == 103)
	{
		centerprint(user.Player,
			"THIS AREA IS ONLY AVAILABLE IN THE RETAIL VERSION OF STRIFE");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}

	return true;
}

//==========================================================================
//
//  StartLockedACS
//
//==========================================================================

bool StartLockedACS(line_t * line, int *args, Actor A, int side)
{
	if (!CheckLock(A, args[4]))
	{
		return false;
	}
	return StartACS(args[0], args[1], args[2], args[3], args[4], A, line, side,
		false, false);
}

//=========================================================================
//
// EV_SectorSoundChange
//
//=========================================================================

bool EV_SectorSoundChange(int *args)
{
	int secNum;
	bool rtn;

	if (!args[0])
	{
		return false;
	}
	secNum = -1;
	rtn = false;
	for (secNum = FindSectorFromTag(args[0], -1); secNum >= 0;
		secNum = FindSectorFromTag(args[0], secNum))
	{
		GLevel.Sectors[secNum].seqType = args[1];
		rtn = true;
	}
	return rtn;
}

//=========================================================================
//
//	EV_SectorSetDamage
//
//=========================================================================

bool EV_SectorSetDamage(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int		SecNum;
	bool	Rtn;

	if (!Arg1)
	{
		return false;
	}
	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		GLevel.Sectors[SecNum].Damage = Arg2;
		//FIXME Arg3 is MOD
		Rtn = true;
	}
	return Rtn;
}

//==========================================================================
//
//  EV_NoiseAlert
//
//==========================================================================

bool EV_NoiseAlert(Actor A, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	Actor	ASource;
	Actor	ATarget;
	int		Search;

	if (!Arg1)
	{
		ASource = A;
	}
	else
	{
		Search = -1;
		ASource = Actor(FindMobjFromTID(Arg1, &Search));
	}

	if (!Arg2)
	{
		ATarget = A;
	}
	else
	{
		Search = -1;
		ATarget = Actor(FindMobjFromTID(Arg2, &Search));
	}

	P_NoiseAlert(ASource, ATarget);
	return true;
}

//==========================================================================
//
//  EV_ForceField
//
//==========================================================================

bool EV_ForceField(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Actor A)
{
	A.Damage(none, none, 10);
	return true;
}

//==========================================================================
//
//  EV_RemoveForceField
//
//==========================================================================

bool EV_RemoveForceField(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int i;
	int secnum;
	sector_t *sec;
	line_t *secline;

	for (secnum = FindSectorFromTag(Arg1, -1); secnum >= 0;
		secnum = FindSectorFromTag(Arg1, secnum))
	{
		sec = &GLevel.Sectors[secnum];
		for (i = 0; i < sec->linecount; i++)
		{
			secline = sec->lines[i];
			if (secline->special != LNSPEC_ForceField)
				continue;
			if (!(secline->flags & ML_TWOSIDED))
				continue;

			SetLineTexture(secline->sidenum[0], 1, 0);
			SetLineTexture(secline->sidenum[1], 1, 0);
			secline->special = 0;
			secline->flags &= ~ML_BLOCKING;
		}
	}
	return true;
}

//==========================================================================
//
//  EV_SendToCommunicator
//
//==========================================================================

bool EV_SendToCommunicator(Actor A, int *args, int side)
{
	if (args[1] && side)
		return false;

	if (A && A.bIsPlayer && A.Player.Communicator)
	{
		if (!args[3])
		{
			A.Player.SetObjectives(args[0]);
		}

		MSG_Select(MSG_SV_RELIABLE);
		MSG_WriteByte(svc_voice);
		MSG_WriteShort(args[0]);

		if (args[2] == 0)
		{
			cprint(A.Player, "Incoming Message");
		}
		else if (args[2] == 1)
		{
			cprint(A.Player, "Incoming Message from BlackBird");
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//  EV_BreakGlass
//
//==========================================================================

bool EV_BreakGlass(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, Actor A)
{
	bool	switched;
	bool	quest1;
	bool	quest2;
	float	x;
	float	y;
	int		i;
	Actor	glass;
	float	an;
	float	speed;

	if (Line->flags & ML_TWOSIDED)
	{
		Line->flags &= ~(ML_BLOCKING | ML_BLOCKEVERYTHING);
	}
	quest1 = false;
	if (GLevel.Sides[Line->sidenum[0]].midtexture == TextureNumForName("BRNSCN01"))
		quest1 = true;
	P_ChangeSwitchTexture(Line, false);
	switched = true;
	Line->special = 0;
	if (Line->sidenum[1] != -1)
	{
		//switched |= P_ChangeSwitchTexture(&sides[ln->sidenum[1]], false, 0, &quest2);
		SetLineTexture(Line->sidenum[1], 1, GLevel.Sides[Line->sidenum[0]].midtexture);
		quest2 = quest1;
	}
	else
	{
		quest2 = quest1;
	}
	if (switched)
	{
		// Break some glass
		x = Line->v1->x + (Line->v2->x - Line->v1->x) / 2.0;
		y = Line->v1->y + (Line->v2->y - Line->v1->y) / 2.0;
		x += (Line->frontsector->soundorg.x - x) / 5.0;
		y += (Line->frontsector->soundorg.y - y) / 5.0;

		for (i = 0; i < 7; i++)
		{
			glass = Spawn(Blood, vector(x, y, ONFLOORZ));
			glass.bColideWithThings = false;
			glass.bColideWithWorld = false;
			glass.Origin.z += 24.0;
			glass.SetState(Actor::S_SHARD_4 + P_Random() % 3);
			an = Random() * 360.0;
			glass.Angles.yaw = an;
			speed = Random() * 4.0 * 35.0;
			glass.Velocity.x = cos(an) * speed;
			glass.Velocity.y = sin(an) * speed;
			glass.Velocity.z = Random() * 8.0 * 35.0;
		}
		if (quest1 || quest2)
		{
			// Up stats and signal this mission is complete
			if (!A)
			{
				for (i = 0; i < MAXPLAYERS; ++i)
				{
					if (svvars->Players[i] && svvars->Players[i].bSpawned)
					{
						A = svvars->Players[i].MO;
						break;
					}
				}
			}
			if (A && A.bIsPlayer)
			{
				A.Player.GiveQuest(QUEST_FreedWorkers);
				A.Player.Accuracy += 10;
				A.Player.Stamina += 10;
				A.Player.GiveBody(200);
			}
		}
	}
	//	We already changed the switch texture, so don't make the main code
	// switch it back.
	return false;
}

//==========================================================================
//
//  ExecuteLineSpecial
//
//==========================================================================

bool ExecuteLineSpecial(int special, int *args, line_t * line, int side,
	Actor A)
{
	bool buttonSuccess;
	int Arg1;
	int Arg2;
	int Arg3;
	int Arg4;
	int Arg5;

	Arg1 = args[0];
	Arg2 = args[1];
	Arg3 = args[2];
	Arg4 = args[3];
	Arg5 = args[4];
	buttonSuccess = false;
	switch (special)
	{
	case LNSPEC_PolyStartLine:
		break;
	case LNSPEC_PolyRotateLeft:
		buttonSuccess = EV_RotatePoly(line, args, 1, false);
		break;
	case LNSPEC_PolyRotateRight:
		buttonSuccess = EV_RotatePoly(line, args, -1, false);
		break;
	case LNSPEC_PolyMove:
		buttonSuccess = EV_MovePoly(line, args, false, false);
		break;
	case LNSPEC_PolyExplicitLine: // Only used in initialization
		break;
	case LNSPEC_PolyMoveTimes8:
		buttonSuccess = EV_MovePoly(line, args, true, false);
		break;
	case LNSPEC_PolyDoorSwing:
		buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SWING);
		break;
	case LNSPEC_PolyDoorSlide:
		buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SLIDE);
		break;
	case LNSPEC_DoorClose:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			DOOREV_Close, line, A);
		break;
	case LNSPEC_DoorOpen:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			DOOREV_Open, line, A);
		break;
	case LNSPEC_DoorRaise:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			DOOREV_Raise, line, A);
		break;
	case LNSPEC_DoorLockedRaise:
		if (CheckLock(A, args[3]))
		{
			buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
				DOOREV_RaiseLocked, line, A);
		}
		break;
	case LNSPEC_FloorLowerByValue:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerByValue, line);
		break;
	case LNSPEC_FloorLowerToLowest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerToLowest, line);
		break;
	case LNSPEC_FloorLowerToNearest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerToNearest, line);
		break;
	case LNSPEC_FloorRaiseByValue:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseByValue, line);
		break;
	case LNSPEC_FloorRaiseToHighest:
		//WARNING this conflicts with actual Hexen behavior
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseToHighest, line);
		break;
	case LNSPEC_FloorRaiseToNearest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseToNearest, line);
		break;
	case LNSPEC_StairsBuildDownNormal:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			STAIRSEV_DownNormal);
		break;
	case LNSPEC_StairsBuildUpNormal:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			STAIRSEV_UpNormal);
		break;
	case LNSPEC_FloorRaiseAndCrush:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseAndCrush, line);
		break;
	case LNSPEC_PillarBuild: // (no crushing)
		buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, false);
		break;
	case LNSPEC_PillarOpen:
		buttonSuccess = EV_OpenPillar(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_StairsBuildDownSync:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			STAIRSEV_DownSync);
		break;
	case LNSPEC_StairsBuildUpSync:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			STAIRSEV_UpSync);
		break;
	case LNSPEC_ForceField:
		buttonSuccess = EV_ForceField(Arg1, Arg2, Arg3, Arg4, Arg5, A);
		break;
	case LNSPEC_ClearForceField:
		buttonSuccess = EV_RemoveForceField(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorRaiseByValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseByValueTimes8, line);
		break;
	case LNSPEC_FloorLowerByValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerByValueTimes8, line);
		break;
	case LNSPEC_CeilingWaggle:
		buttonSuccess = EV_StartCeilingWaggle(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportZombieChanger:
		if (side == 0)
		{
			//	Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, line,
				true);
			A.SetState(A.PainState);
		}
		break;
	case LNSPEC_CeilingLowerByValue:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerByValue, line);
		break;
	case LNSPEC_CeilingRaiseByValue:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_RaiseByValue, line);
		break;
	case LNSPEC_CeilingCrushAndRaise:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushAndRaise, line);
		break;
	case LNSPEC_CeilingLowerAndCrush:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerAndCrush, line);
		break;
	case LNSPEC_CeilingCrushStop:
		buttonSuccess = EV_CeilingCrushStop(line, args);
		break;
	case LNSPEC_CeilingCrushRaiseAndStay:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushRaiseAndStay, line);
		break;
	case LNSPEC_FloorCrushStop:
		buttonSuccess = EV_FloorCrushStop(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_PlatPerpetualRaise:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_PerpetualRaise, line);
		break;
	case LNSPEC_PlatStop:
		EV_StopPlat(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_PlatDownWaitUpStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_DownWaitUpStay, line);
		break;
	case LNSPEC_PlatDownByValueWaitUpStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_DownByValueWaitUpStay, line);
		break;
	case LNSPEC_PlatUpWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_UpWaitDownStay, line);
		break;
	case LNSPEC_PlatUpByValueWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_UpByValueWaitDownStay, line);
		break;
	case LNSPEC_FloorLowerTimes8Instant:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerTimes8Instant, line);
		break;
	case LNSPEC_FloorRaiseTimes8Instant:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseTimes8Instant, line);
		break;
	case LNSPEC_FloorMoveToValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_MoveToValueTimes8, line);
		break;
	case LNSPEC_CeilingMoveToValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_MoveToValueTimes8, line);
		break;
	case LNSPEC_Teleport:
		if (side == 0)
		{
			// Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, line,
				true);
		}
		break;
	case LNSPEC_TeleportNoFog:
		if (side == 0)
		{
			// Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, line,
				false);
		}
		break;
	case LNSPEC_ThingThrust:
		if (!side)	// Only thrust on side 0
		{
			A.Thrust(itof(args[0]) * (90.0 / 64.0), itof(args[1]));
			buttonSuccess = 1;
		}
		break;
	case LNSPEC_ThingDamage:
		if (args[0])
		{
			A.Damage(none, none, args[0]);
		}
		else
		{
			// If arg1 is zero, then guarantee a kill
			A.Damage(none, none, 10000);
		}
		buttonSuccess = 1;
		break;
	case LNSPEC_TeleportNewMap:
		// Players must be alive to teleport
		if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD))
		{
			G_Completed(Arg1, Arg2, Arg3);
			buttonSuccess = true;
		}
		break;
	case LNSPEC_TeleportEndGame:
		if (side == 0)
		{
			// Only teleport when crossing the front side of a line
			// Players must be alive to teleport
			if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD))
			{
				buttonSuccess = true;
				if (deathmatch)
				{
					// Winning in deathmatch just goes back to map 1
					G_Completed(1, 0, 0);
				}
				else
				{
					// Passing -1, -1 to G_Completed() starts the Finale
					G_Completed(-1, -1, 0);
				}
			}
		}
		break;
	case LNSPEC_TeleportOther:
		buttonSuccess = EV_TeleportOther(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportGroup:
		buttonSuccess = EV_TeleportGroup(Arg1, Arg2, Arg3, Arg4, Arg5, A);
		break;
	case LNSPEC_TeleportSector:
		buttonSuccess = EV_TeleportSector(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_ACSExecute:
		buttonSuccess = StartACS(args[0], args[1], args[2], args[3], args[4],
			A, line, side, false, false);
		break;
	case LNSPEC_ACSSuspend:
		buttonSuccess = SuspendACS(args[0], args[1]);
		break;
	case LNSPEC_ACSTerminate:
		buttonSuccess = TerminateACS(args[0], args[1]);
		break;
	case LNSPEC_ACSLockedExecute:
		buttonSuccess = StartLockedACS(line, args, A, side);
		break;
	case LNSPEC_ACSExecuteWithResult:
		buttonSuccess = StartACS(Arg1, 0, Arg2, Arg3, Arg4, A, line, side,
			true, true);
		break;
	case LNSPEC_PolyRotateLeftOverride:
		buttonSuccess = EV_RotatePoly(line, args, 1, true);
		break;
	case LNSPEC_PolyRotateRightOverride:
		buttonSuccess = EV_RotatePoly(line, args, -1, true);
		break;
	case LNSPEC_PolyMoveOverride:
		buttonSuccess = EV_MovePoly(line, args, false, true);
		break;
	case LNSPEC_PolyMoveTimes8Override:
		buttonSuccess = EV_MovePoly(line, args, true, true);
		break;
	case LNSPEC_PillarBuildCrush:
		buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, true);
		break;
	case LNSPEC_FloorAndCeilingLowerByValue:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Lower, line);
		break;
	case LNSPEC_FloorAndCeilingRaiseByValue:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Raise, line);
		break;
	case LNSPEC_LightForceLightning:
		buttonSuccess = true;
		P_ForceLightning();
		break;
	case LNSPEC_LightRaiseByValue:
		buttonSuccess = EV_LightRaiseByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightLowerByValue:
		buttonSuccess = EV_LightLowerByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightChangeToValue:
		buttonSuccess = EV_LightChangeToValue(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightFade:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Fade);
		break;
	case LNSPEC_LightGlow:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Glow);
		break;
	case LNSPEC_LightFlicker:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Flicker);
		break;
	case LNSPEC_LightStrobe:
		buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5,
			LIGHTEV_Strobe);
		break;
	case LNSPEC_LightStop:
		buttonSuccess = EV_LightStop(Arg1);
		break;
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(args);
		break;
/*	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(line, args, mo);
		break;*/
	case LNSPEC_ThingActivate:
		buttonSuccess = EV_ThingActivate(args[0]);
		break;
	case LNSPEC_ThingDeactivate:
		buttonSuccess = EV_ThingDeactivate(args[0]);
		break;
	case LNSPEC_ThingRemove:
		buttonSuccess = EV_ThingRemove(args[0]);
		break;
	case LNSPEC_ThingDestroy:
		buttonSuccess = EV_ThingDestroy(args[0]);
		break;
	case LNSPEC_ThingProjectile:
		buttonSuccess = EV_ThingProjectile(args, 0, 0);
		break;
	case LNSPEC_ThingSpawn:
		buttonSuccess = EV_ThingSpawn(args, 1);
		break;
	case LNSPEC_ThingProjectileGravity:
		buttonSuccess = EV_ThingProjectile(args, 1, 0);
		break;
	case LNSPEC_ThingSpawnNoFog:
		buttonSuccess = EV_ThingSpawn(args, 0);
		break;
	case LNSPEC_FloorWaggle:
		buttonSuccess = EV_StartFloorWaggle(args[0], args[1],
			args[2], args[3], args[4]);
		break;
	case LNSPEC_SectorSoundChange:
		buttonSuccess = EV_SectorSoundChange(args);
		break;
	case LNSPEC_PlaneUpNearestWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_UpNearestWaitDownStay, line);
		break;
	case LNSPEC_NoiseAlert:
		buttonSuccess = EV_NoiseAlert(A, Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_CeilingLowerToHighestFloor:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerToHighestFloor, line);
		break;
	case LNSPEC_CeilingLowerInstant:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerTimes8Instant, line);
		break;
	case LNSPEC_CeilingRaiseInstant:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_RaiseTimes8Instant, line);
		break;
	case LNSPEC_CeilingCrushRaiseAndStayA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushRaiseAndStayA, line);
		break;
	case LNSPEC_CeilingCrushAndRaiseA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushAndRaiseA, line);
		break;
	case LNSPEC_CeilingCrushAndRaiseSilentA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushAndRaiseSilA, line);
		break;
	case LNSPEC_CeilingRaiseByValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_RaiseByValueTimes8, line);
		break;
	case LNSPEC_CeilingLowerByValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerByValueTimes8, line);
		break;
	case LNSPEC_FloorGeneric:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_Generic, line);
		break;
	case LNSPEC_CeilingGeneric:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_Generic, line);
		break;
	case LNSPEC_DoorGeneric:
		buttonSuccess = EV_GenericDoor(Arg1, Arg2, Arg3, Arg4, Arg5, line, A);
		break;
	case LNSPEC_PlatGeneric:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_Generic, line);
		break;
	case LNSPEC_StairsGeneric:
		buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5,
			true, line);
		break;
	case LNSPEC_CeilingGenericCrush:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_GenericCrush, line);
		break;
	case LNSPEC_PlatDownWaitUpStayLip:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_DownWaitUpStayLip, line);
		break;
	case LNSPEC_PlatPerpetualRaiseLip:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_PerpetualRaiseLip, line);
		break;
	case LNSPEC_SectorSetDamage:
		buttonSuccess = EV_SectorSetDamage(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_TeleportLine:
		buttonSuccess = EV_SilentLineTeleport(line, side, A, args[1], args[2]);
		break;
	case LNSPEC_StairsBuildUpDoom:
		buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5,
			false, line);
		break;
	case LNSPEC_SectorSetWind:
		buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, line,
			PUSHER_Wind);
		break;
	case LNSPEC_SectorSetFriction:
		SetSectorFriction(Arg1, Arg2, true);
		buttonSuccess = true;
		break;
	case LNSPEC_SectorSetCurrent:
		buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, line,
			PUSHER_Current);
		break;
	case LNSPEC_ACSExecuteAlways:
		buttonSuccess = StartACS(Arg1, Arg2, Arg3, Arg4, Arg5, A, line, side,
			true, false);
		break;
	case LNSPEC_FloorRaiseToNearestChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseToNearestChange, line);
		break;
	case LNSPEC_FloorRaiseByValueChangeTex:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseByValueChange2, line);
		break;
	case LNSPEC_PlatToggle:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			PLATEV_Toggle, line);
		break;
	case LNSPEC_LightStrobeDoom:
		buttonSuccess = EV_StartLightStrobing(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightMinNeighbor:
		buttonSuccess = EV_TurnTagLightsOff(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_LightMaxNeighbor:
		buttonSuccess = EV_TagLightTurnOn(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorTransferTrigger:
		buttonSuccess = EV_FloorTransferTrigger(Arg1, Arg2, Arg3, Arg4, Arg5,
			line);
		break;
	case LNSPEC_FloorTransferNumeric:
		buttonSuccess = EV_FloorTransferNumeric(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorRaiseToLowestCeiling:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseToLowestCeiling, line);
		break;
	case LNSPEC_FloorRaiseByValueChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseByValueChange, line);
		break;
	case LNSPEC_FloorRaiseByTexture:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_RaiseByTexture, line);
		break;
	case LNSPEC_FloorLowerToLowestChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerToLowestChange, line);
		break;
	case LNSPEC_FloorLowerToHighest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FLOOREV_LowerToHighest, line);
		break;
	case LNSPEC_ExitNormal:
		buttonSuccess = true;
		G_ExitLevel(Arg1);
		break;
	case LNSPEC_ExitSecret:
		buttonSuccess = true;
		G_SecretExitLevel(Arg1);
		break;
	case LNSPEC_ElevatorRaiseToNearest:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Up, line);
		break;
	case LNSPEC_ElevatorMoveToFloor:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Current, line);
		break;
	case LNSPEC_ElevatorLowerToNearest:
		buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5,
			ELEVEV_Down, line);
		break;
	case LNSPEC_DoorCloseWaitOpen:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			DOOREV_CloseWaitOpen, line, A);
		break;
	case LNSPEC_FloorDonut:
		buttonSuccess = EV_DoDonut(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorAndCeilingLowerRaise:
		buttonSuccess = EV_DoCeiling(Arg1, Arg3, 0, 0, 0,
			CEILEV_RaiseToHighest, line);
		buttonSuccess |= EV_DoFloor(Arg1, Arg2, 0, 0, 0,
			FLOOREV_LowerToLowest, line);
		break;
	case LNSPEC_CeilingRaiseToNearest:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_RaiseToNearest, line);
		break;
	case LNSPEC_CeilingLowerToLowest:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerToLowest, line);
		break;
	case LNSPEC_CeilingLowerToFloor:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_LowerToFloor, line);
		break;
	case LNSPEC_CeilingCrushRaiseAndStaySilentA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CEILEV_CrushRaiseAndStaySilA, line);
		break;

	// Line specials only processed during level initialization
	// LNSPEC_ScrollTextureLeft:
	// LNSPEC_ScrollTextureRight:
	// LNSPEC_ScrollTextureUp:
	// LNSPEC_ScrollTextureDown:
	// LNSPEC_LineSetIdentification:
	// LNSPEC_3DFloor:
	// LNSPEC_Contents:
	// LNSPEC_PlaneAlign:
	// LNSPEC_LineTranslucent:
	// LNSPEC_TransferHeights:
	// LNSPEC_ScrollTextureBoth:
	// LNSPEC_ScrollTextureModel:
	// LNSPEC_ScrollFloor:
	// LNSPEC_ScrollCeiling:
	// LNSPEC_ScrollTextureOffsets:
	// LNSPEC_PointPushSetForce:

	case 14:	//	Door_Animated
		buttonSuccess = EV_TextureChangeDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			line);
		break;
	case 49:	//	Break glass.
		buttonSuccess = EV_BreakGlass(Arg1, Arg2, Arg3, Arg4, Arg5,
			line, A);
		break;
	case 174:	//	SendToCommunicator.
		buttonSuccess = EV_SendToCommunicator(A, args, side);
		break;

	// Inert Line specials
	default:
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  P_SpawnSpecials
//
//==========================================================================

void P_SpawnSpecials(bool spawn_thinkers)
{
	sector_t *sector;
	int i;
	int j;

	TaggedLineCount = 0;
	for (i = 0; i < GLevel.NumLines; i++)
	{
		switch (GLevel.Lines[i].special)
		{
		case LNSPEC_LineSetIdentification:
		case LNSPEC_LineTranslucent:
		case LNSPEC_TeleportLine:
			if (GLevel.Lines[i].arg1)
			{
				if (TaggedLineCount == MAX_TAGGED_LINES)
				{
					Error("P_SpawnSpecials: MAX_TAGGED_LINES exceeded.");
				}
				TaggedLines[TaggedLineCount].line = &GLevel.Lines[i];
				TaggedLines[TaggedLineCount++].lineTag = GLevel.Lines[i].arg1;
			}
			if (GLevel.Lines[i].special == LNSPEC_LineSetIdentification)
			{
				GLevel.Lines[i].special = 0;
			}
			break;
		}
	}

	//	Process translucent lines
	for (i = 0; i < GLevel.NumLines; i++)
	{
		if (GLevel.Lines[i].special == 208)
		{
			int trans = (255 - GLevel.Lines[i].arg2) * 100 / 255;
			if (GLevel.Lines[i].arg1)
			{
				for (j = 0; j < TaggedLineCount; j++)
				{
					if (TaggedLines[j].lineTag == GLevel.Lines[i].arg1)
					{
						SetLineTransluc(TaggedLines[j].line, trans);
					}
				}
			}
			else
			{
				SetLineTransluc(&GLevel.Lines[i], trans);
			}
			GLevel.Lines[i].special = 0;
		}
		else if (GLevel.Lines[i].special == 49 && GLevel.Lines[i].arg2 != 255)
		{
			int trans = (255 - GLevel.Lines[i].arg2) * 100 / 255;
			SetLineTransluc(&GLevel.Lines[i], trans);
		}
	}

	//  Init special SECTORs.
	if (spawn_thinkers)
	{
		for (i = 0; i < GLevel.NumSectors; i++)
		{
			sector = &GLevel.Sectors[i];

			if (!sector->special)
				continue;

			if (sector->special & SECSPEC_SECRET_MASK)
			{
				//	Secret sector.
				level->totalsecret++;
			}
			switch (sector->special & SECSPEC_BASE_MASK)
			{
			case SECSPEC_LightPhased:
				//	Hardcoded base, use sector->lightlevel as the index
				P_SpawnPhasedLight(sector, 80, -1);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_LightSequenceStart:
				P_SpawnLightSequence(sector, 1.0);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
				// Specials 3 & 4 are used by the phased light sequences
			case SECSPEC_LightFlicker:
				P_SpawnLightFlash(sector);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_LightStrobeFast:
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_LightStrobeSlow:
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 0);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_LightStrobeFastDamage:
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				break;
			case SECSPEC_LightGlow:
				P_SpawnGlowingLight(sector);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_DoorCloseIn30:
				P_SpawnDoorCloseIn30(sector);
				break;
			case SECSPEC_LightSyncStrobeSlow:
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 1);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_LightSyncStrobeFast:
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 1);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_DoorRaiseIn5Minutes:
				P_SpawnDoorRaiseIn5Mins(sector);
				break;
			case SECSPEC_LightFireFlicker:
				P_SpawnFireFlicker(sector);
				sector->special &= ~SECSPEC_BASE_MASK;
				break;
			case SECSPEC_ScrollEastLavaDamage:
				SpawnScrollingFloor(sector, -1, 0, 3);
				break;
			case SECSPEC_ScrollNorthSlow:
			case SECSPEC_ScrollNorthMedium:
			case SECSPEC_ScrollNorthFast:
				SpawnScrollingFloor(sector, 0, 1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthSlow);
				break;
			case SECSPEC_ScrollEastSlow:
			case SECSPEC_ScrollEastMedium:
			case SECSPEC_ScrollEastFast:
				SpawnScrollingFloor(sector, -1, 0, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollEastSlow);
				break;
			case SECSPEC_ScrollSouthSlow:
			case SECSPEC_ScrollSouthMedium:
			case SECSPEC_ScrollSouthFast:
				SpawnScrollingFloor(sector, 0, -1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthSlow);
				break;
			case SECSPEC_ScrollWestSlow:
			case SECSPEC_ScrollWestMedium:
			case SECSPEC_ScrollWestFast:
				SpawnScrollingFloor(sector, 1, 0, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollWestSlow);
				break;
			case SECSPEC_ScrollNorthWestSlow:
			case SECSPEC_ScrollNorthWestMedium:
			case SECSPEC_ScrollNorthWestFast:
				SpawnScrollingFloor(sector, 1, 1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthWestSlow);
				break;
			case SECSPEC_ScrollNorthEastSlow:
			case SECSPEC_ScrollNorthEastMedium:
			case SECSPEC_ScrollNorthEastFast:
				SpawnScrollingFloor(sector, -1, 1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthEastSlow);
				break;
			case SECSPEC_ScrollSouthEastSlow:
			case SECSPEC_ScrollSouthEastMedium:
			case SECSPEC_ScrollSouthEastFast:
				SpawnScrollingFloor(sector, -1, -1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthEastSlow);
				break;
			case SECSPEC_ScrollSouthWestSlow:
			case SECSPEC_ScrollSouthWestMedium:
			case SECSPEC_ScrollSouthWestFast:
				SpawnScrollingFloor(sector, 1, -1, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthWestSlow);
				break;
			case SECSPEC_ScrollEast5:
			case SECSPEC_ScrollEast10:
			case SECSPEC_ScrollEast25:
			case SECSPEC_ScrollEast30:
			case SECSPEC_ScrollEast35:
				SpawnScrollingFloor(sector, -1, 0, (sector->special &
					SECSPEC_BASE_MASK) - SECSPEC_ScrollEast5);
				break;
			}
		}

		//  Init line EFFECTs
		for (i = 0; i < GLevel.NumLines; i++)
		{
			switch (GLevel.Lines[i].special)
			{
			case LNSPEC_ScrollTextureLeft:
				SpawnWallScroller(&GLevel.Lines[i], 1, 0);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureRight:
				SpawnWallScroller(&GLevel.Lines[i], -1, 0);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureUp:
				SpawnWallScroller(&GLevel.Lines[i], 0, 1);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureDown:
				SpawnWallScroller(&GLevel.Lines[i], 0, -1);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureBoth:
				SpawnTextureBothScroller(&GLevel.Lines[i]);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureModel:
				SpawnScrollTextureModel(&GLevel.Lines[i]);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollFloor:
				SpawnScrollFloor(&GLevel.Lines[i]);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollCeiling:
				SpawnScrollCeiling(&GLevel.Lines[i]);
				GLevel.Lines[i].special = 0;
				break;
			case LNSPEC_ScrollTextureOffsets:
				SpawnWallOffsetsScroller(&GLevel.Lines[i]);
				GLevel.Lines[i].special = 0;
				break;
			}
		}
		P_SpawnPushers();
	}
}

//==========================================================================
//
//  P_UpdateSpecials
//
//==========================================================================

void P_UpdateSpecials()
{
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, Actor A)
{
	int lineActivation;
	bool noway;

	noway = true;
	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
			case LNSPEC_PlatDownWaitUpStay:
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
			case LNSPEC_PlatDownWaitUpStayLip:
			case LNSPEC_TeleportLine:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
				if (line->arg1 == 0)
					noway = false;
				break;
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
				noway = false;
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//==========================================================================
//
//  P_ActivateLine
//
//==========================================================================

bool P_ActivateLine(line_t * line, Actor A, int side, int activationType)
{
	int lineActivation;
	bool repeat;
	bool buttonSuccess;
	bool changeBack;

	if (!CheckActivation(activationType, line, A))
	{
		return false;
	}

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH)
	{
		lineActivation = activationType;
	}
	repeat = line->flags & ML_REPEAT_SPECIAL;
	buttonSuccess = ExecuteLineSpecial(line->special, &line->arg1, line,
		side, A);
	changeBack = line->special == 49 && (line->flags & ML_TWOSIDED) && buttonSuccess;
	if (!repeat && buttonSuccess)
	{
		// clear the special on non-retriggerable lines
		line->special = 0;
	}
	if ((lineActivation == SPAC_USE || lineActivation == SPAC_IMPACT ||
		lineActivation == SPAC_USETHROUGH) && buttonSuccess)
	{
		P_ChangeSwitchTexture(line, repeat);
	}
	if (changeBack)
	{
		SetLineTexture(line->sidenum[1], 1, GLevel.Sides[line->sidenum[0]].midtexture);
	}
	return true;
}

//==========================================================================
//
//  P_FindLine
//
//==========================================================================

line_t *P_FindLine(int lineTag, int *searchPosition)
{
	int i;

	for (i = *searchPosition + 1; i < TaggedLineCount; i++)
	{
		if (TaggedLines[i].lineTag == lineTag)
		{
			*searchPosition = i;
			return TaggedLines[i].line;
		}
	}
	*searchPosition = -1;
	return NULL;
}

//==========================================================================
//
//  StartPlaneWatcher
//
//==========================================================================

void StartPlaneWatcher(Actor it, line_t* line, int lineSide, bool ceiling,
	int tag, int height, int special, int arg0, int arg1, int arg2, int arg3,
	int arg4)
{
	PlaneWatcher	PW;

	PW = PlaneWatcher(NewSpecialThinker(PlaneWatcher));
	PW.Start(it, line, lineSide, ceiling, tag, height, special, arg0, arg1,
		arg2, arg3, arg4);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.39  2005/12/14 20:52:33  dj_jl
//  State names belong to a class.
//
//  Revision 1.38  2005/11/24 20:32:09  dj_jl
//  Beautification.
//
//  Revision 1.37  2005/11/19 13:43:51  dj_jl
//  Renamed sounds.
//
//  Revision 1.36  2005/06/04 13:51:32  dj_jl
//  Added pusher specials.
//
//  Revision 1.35  2005/03/28 07:45:29  dj_jl
//  Some Boom line specials, fixed multiple bugs.
//
//  Revision 1.34  2005/03/16 15:04:43  dj_jl
//  More work on line specials.
//
//  Revision 1.33  2005/03/01 14:39:33  dj_jl
//  Big update of line specials.
//
//  Revision 1.32  2005/01/25 17:45:18  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.31  2004/12/27 12:23:15  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.30  2004/12/22 07:56:48  dj_jl
//  Fully working Strife support.
//
//  Revision 1.29  2004/11/22 07:36:29  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.28  2004/11/01 07:38:24  dj_jl
//  Almost all Hexen line specials are available in all games.
//
//  Revision 1.27  2004/10/13 06:41:14  dj_jl
//  Implemented animated doors.
//
//  Revision 1.26  2004/10/12 06:39:08  dj_jl
//  Various improvements.
//
//  Revision 1.25  2004/01/20 07:13:42  dj_jl
//  Communicator voices
//
//  Revision 1.24  2003/11/12 16:51:33  dj_jl
//  Changed player structure into a class
//
//  Revision 1.23  2003/09/12 16:47:11  dj_jl
//  Translating most of the line specials
//
//  Revision 1.22  2002/11/02 08:22:38  dj_jl
//  New style classes.
//
//  Revision 1.21  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.20  2002/05/03 17:17:32  dj_jl
//  Started work on weapons and items.
//
//  Revision 1.19  2002/03/28 18:21:41  dj_jl
//  Removed P_RespawnSpecials.
//
//  Revision 1.18  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.17  2002/03/16 17:48:58  dj_jl
//  Added PlayerPawn class, beautifucation.
//
//  Revision 1.16  2002/02/22 18:00:26  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.15  2002/02/16 16:23:46  dj_jl
//  Added line teleporters and translucent lines
//
//  Revision 1.14  2002/02/14 19:21:00  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.13  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.12  2002/01/29 18:15:06  dj_jl
//  Added some thing specials
//
//  Revision 1.11  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.10  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:43  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.4  2001/09/24 17:14:11  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
