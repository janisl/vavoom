//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    TELEPORTATION
//**
//**************************************************************************

float teleport_bbox[4];
Actor teleport_thing;
float teleport_x;
float teleport_y;

//==========================================================================
//
//  PIT_StompThing
//
//==========================================================================

bool PIT_StompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
		return true;

	blockdist = Other.Radius + teleport_thing.Radius;

	if (fabs(Other.Origin.x - teleport_x) >= blockdist ||
		fabs(Other.Origin.y - teleport_y) >= blockdist)
	{
		// didn't hit it
		return true;
	}

	// don't clip against self
	if (Other == teleport_thing)
		return true;

	if (!teleport_thing.bIsPlayer)
	{
		return false;
	}

	Actor(Other).Damage(teleport_thing, teleport_thing, 10000);

	return true;
}

//==========================================================================
//
//	EV_Teleport
//
//==========================================================================

bool EV_Teleport(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	Actor thing, line_t* Line, bool fog)
{
	int			i;
	int			count;
	Actor		A;
	int			searcher;
	int			SecTag;
	int			SecNum;
	sector_t*	Sec;
	bool		SrcFog;
	bool		KeepOrient;
	TVec		DstOrg;
	float		Angle;
	TVec		OldVel;

	if (!thing)
	{
		// Teleport function called with an invalid mobj
		return false;
	}
	if (thing.bNoTeleport)
	{
		return false;
	}

	A = none;
	if (fog)
	{
		SecTag = Arg2;
		SrcFog = !Arg3;
		KeepOrient = false;
	}
	else
	{
		SecTag = Arg3;
		SrcFog = false;
		KeepOrient = !Arg2;
	}
	if (Arg1)
	{
		count = 0;
		searcher = -1;
		for (A = Actor(FindMobjFromTID(Arg1, &searcher)); A;
			A = Actor(FindMobjFromTID(Arg1, &searcher)))
		{
			if (SecTag == 0 || A.Sector->tag == SecTag)
			{
				count++;
			}
		}
		if (count == 0)
		{
			return false;
		}
		count = 1 + (P_Random() % count);
		searcher = -1;
		for (i = 0; i < count; i++)
		{
			do
			{
				A = Actor(FindMobjFromTID(Arg1, &searcher));
			}
			while (A && SecTag != 0 && A.Sector->tag != SecTag);
		}
	}
	else if (SecTag)
	{
		for (SecNum = FindSectorFromTag(SecTag, -1); SecNum >= 0;
			SecNum = FindSectorFromTag(SecTag, SecNum))
		{
			Sec = &GLevel.Sectors[SecNum];
			FOREACH(Actor, A)
			{
				if (!TeleportSpot(A))
				{
					//	Not a teleportman
					continue;
				}
				if (A.Sector != Sec)
				{
					//	Wrong sector
					continue;
				}
				break;
			}
			if (A)
			{
				break;
			}
		}
	}
	if (!A)
	{
		return false;
	}

	DstOrg = A.Origin;
	// Lee Killough's changes for silent teleporters from BOOM
	if (KeepOrient && Line)
	{
		// Get the angle between the exit thing and source linedef.
		// Rotate 180 degrees, so that walking perpendicularly across
		// teleporter linedef causes thing to exit in the direction
		// indicated by the exit thing.
		Angle = atan2(Line->normal.y, Line->normal.x) - A.Angles.yaw + 180.0;

		// Momentum of thing crossing teleporter linedef
		OldVel = thing.Velocity;
	}
	if (!TeleportSpot2(A))
	{
		DstOrg.z = ONFLOORZ;
	}
	if (thing.Teleport(DstOrg, A.Angles.yaw, fog, SrcFog, KeepOrient))
	{
		// Lee Killough's changes for silent teleporters from BOOM
		if (!fog && Line && KeepOrient)
		{
			// Rotate thing according to difference in angles
			thing.Angles.yaw = AngleMod360(thing.Angles.yaw + Angle);

			// Rotate thing's momentum to come out of exit just like it entered
			thing.Velocity.x = OldVel.x * cos(Angle) - OldVel.y * sin(Angle);
			thing.Velocity.y = OldVel.y * cos(Angle) + OldVel.x * sin(Angle);
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//	EV_TeleportOther
//
//	Teleport anything matching other_tid to dest_tid
//
//==========================================================================

bool EV_TeleportOther(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	bool		Ret;
	int			Searcher;
	Actor		A;

	Ret = false;
	if (Arg1 && Arg2)
	{
		Searcher = -1;
		for (A = Actor(FindMobjFromTID(Arg1, &Searcher)); A;
			A = Actor(FindMobjFromTID(Arg1, &Searcher)))
		{
			Ret |= EV_Teleport(Arg2, 0, 0, 0, 0, A, NULL, !!Arg3);
		}
	}
	return Ret;
}

//==========================================================================
//
//	DoGroupForOne
//
//==========================================================================

bool DoGroupForOne(Actor victim, Actor source, Actor dest, bool floorz,
	bool fog)
{
	float an = dest.Angles.yaw - source.Angles.yaw;
	float offX = victim.Origin.x - source.Origin.x;
	float offY = victim.Origin.y - source.Origin.y;
	float offAngle = victim.Angles.yaw - source.Angles.yaw;
	float newX = offX * cos(an) - offY * sin(an);
	float newY = offX * sin(an) + offY * cos(an);
	bool res;

	res = victim.Teleport(vector(dest.Origin.x + newX,
		dest.Origin.y + newY, floorz ? ONFLOORZ : dest.Origin.z +
		victim.Origin.z - source.Origin.z), 0.0, fog, fog, !fog);
	// P_Teleport only changes angle if fog is true
	victim.Angles.yaw = AngleMod360(dest.Angles.yaw + offAngle);

	return res;
}

//==========================================================================
//
//	EV_TeleportGroup
//
//	[RH] Teleport a group of actors centered around source_tid so
// that they become centered around dest_tid instead.
//
//==========================================================================

bool EV_TeleportGroup(int group_tid, int source_tid, int dest_tid,
	bool moveSource, bool fog, Actor victim)
{
	Actor		sourceOrigin;
	Actor		destOrigin;
	int			Searcher;
	bool		didSomething;
	bool		floorz;

	Searcher = -1;
	sourceOrigin = Actor(FindMobjFromTID(source_tid, &Searcher));
	if (!sourceOrigin)
	{
		//	If there is no source origin, behave like TeleportOther
		return EV_TeleportOther(group_tid, dest_tid, fog, 0, 0);
	}

	Searcher = -1;
	do
	{
		destOrigin = Actor(FindMobjFromTID(dest_tid, &Searcher));
	}
	while (destOrigin && !TeleportSpot(destOrigin));
	if (!destOrigin)
	{
		return false;
	}

	didSomething = false;
	floorz = !TeleportSpot2(destOrigin);

	// Use the passed victim if group_tid is 0
	if (group_tid == 0 && victim)
	{
		didSomething = DoGroupForOne(victim, sourceOrigin, destOrigin,
			floorz, fog);
	}
	else
	{
		// For each actor with tid matching arg0, move it to the same
		// position relative to destOrigin as it is relative to
		// sourceOrigin before the teleport.
		Searcher = -1;
		for (victim = Actor(FindMobjFromTID(group_tid, &Searcher)); victim;
			victim = Actor(FindMobjFromTID(group_tid, &Searcher)))
		{
			didSomething |= DoGroupForOne(victim, sourceOrigin, destOrigin,
				floorz, fog);
		}
	}

	if (moveSource && didSomething)
	{
		didSomething |= sourceOrigin.Teleport(vector(destOrigin.Origin.x,
			destOrigin.Origin.y, floorz ? ONFLOORZ : destOrigin.Origin.z),
			0.0, false, false, true);
		sourceOrigin.Angles.yaw = destOrigin.Angles.yaw;
	}

	return didSomething;
}

//==========================================================================
//
//	EV_TeleportSector
//
//	[RH] Teleport a group of actors in a sector. Source_tid is used as a
// reference point so that they end up in the same position relative to
// dest_tid. Group_tid can be used to not teleport all actors in the sector.
//
//==========================================================================

bool EV_TeleportSector(int tag, int source_tid, int dest_tid, bool fog,
	int group_tid)
{
	Actor		sourceOrigin;
	Actor		destOrigin;
	int			Searcher;
	bool		didSomething;
	bool		floorz;
	int			secnum;
	sector_t*	sec;
	Actor		A;

	Searcher = -1;
	sourceOrigin = Actor(FindMobjFromTID(source_tid, &Searcher));
	if (!sourceOrigin)
	{
		return false;
	}

	Searcher = -1;
	do
	{
		destOrigin = Actor(FindMobjFromTID(dest_tid, &Searcher));
	}
	while (destOrigin && !TeleportSpot(destOrigin));
	if (!destOrigin)
	{
		return false;
	}

	didSomething = false;
	floorz = !TeleportSpot2(destOrigin);

	for (secnum = FindSectorFromTag(tag, -1); secnum >= 0;
		secnum = FindSectorFromTag(tag, secnum))
	{
		sec = &GLevel.Sectors[secnum];

		FOREACH(Actor, A)
		{
			// possibly limit actors by group
			if (A.Sector == sec && (group_tid == 0 || A.TID == group_tid))
			{
				didSomething |= DoGroupForOne(A, sourceOrigin, destOrigin,
					floorz, fog);
			}
		}
	}
	return didSomething;
}

//==========================================================================
//
//	EV_SilentLineTeleport
//
// Silent linedef-based TELEPORTATION, by Lee Killough
// Primarily for rooms-over-rooms etc.
// This is the complete player-preserving kind of teleporter.
// It has advantages over the teleporter with thing exits.
//
// [RH] Modified to support different source and destination ids.
//
//==========================================================================

bool EV_SilentLineTeleport(line_t *line, int side, Actor thing, int id,
							bool reverse)
{
	int searcher;
	line_t *l;

	if (side || thing.bNoTeleport || !line)
	{
		return false;
	}

	searcher = -1;
	for (l = P_FindLine(id, &searcher); l; l = P_FindLine(id, &searcher))
	{
		TVec SrcXAxis;
		TVec SrcYAxis;
		TVec DstXAxis;
		TVec DstYAxis;
		TVec newPos;
		TVec TempV;
		TAVec TempA;
		float pos;
		float TempX;
		float TempY;
		float oldZ;

		if (l == line || !l->backsector)
		{
			continue;
		}

		// Get the thing's position along the source linedef
		SrcXAxis = Normalise(*line->v2 - *line->v1);
		SrcYAxis = -line->normal;
		pos = DotProduct(SrcXAxis, thing.Origin - *line->v1);
		oldZ = thing.Origin.z;

		// Interpolate position across the exit linedef
		if (reverse)
		{
			DstXAxis = Normalise(*l->v2 - *l->v1);
			DstYAxis = -l->normal;
			newPos = *l->v1 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->frontsector->botregion->floor, newPos);
		}
		else
		{
			DstXAxis = Normalise(*l->v1 - *l->v2);
			DstYAxis = l->normal;
			newPos = *l->v2 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->backsector->botregion->floor, newPos);
		}

		// Attempt to teleport, aborting if blocked
		if (!thing.TeleportMove(newPos))
		{
			return false;
		}
		thing.Origin.z = newPos.z;

		// Rotate thing's orientation according to difference in linedef angles
		TempV.x = DotProduct(DstXAxis, SrcXAxis);
		TempV.y = DotProduct(DstYAxis, SrcXAxis);
		TempV.z = 0.0;
		VectorAngles(&TempV, &TempA);
		thing.Angles.yaw = AngleMod360(thing.Angles.yaw - TempA.yaw);

		// Rotate thing's momentum to come out of exit just like it entered
		TempX = DotProduct(thing.Velocity, SrcXAxis);
		TempY = DotProduct(thing.Velocity, SrcYAxis);
		thing.Velocity.x = TempX * DstXAxis.x + TempY * DstYAxis.x;
		thing.Velocity.y = TempX * DstXAxis.y + TempY * DstYAxis.y;

		// Adjust a player's view, in case there has been a height change
		if (thing.bIsPlayer)
		{
			thing.Player.ViewOrg.z += thing.Origin.z - oldZ;

			thing.Player.bFixAngle = true;
		}
		return true;
	}
	return false;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.31  2005/03/28 07:45:30  dj_jl
//  Some Boom line specials, fixed multiple bugs.
//
//  Revision 1.30  2005/03/16 15:04:43  dj_jl
//  More work on line specials.
//
//  Revision 1.29  2004/12/27 12:23:15  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.28  2004/11/01 07:38:24  dj_jl
//  Almost all Hexen line specials are available in all games.
//
//  Revision 1.27  2003/11/12 16:51:33  dj_jl
//  Changed player structure into a class
//
//  Revision 1.26  2002/11/02 08:22:38  dj_jl
//  New style classes.
//
//  Revision 1.25  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.24  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.23  2002/07/13 07:56:42  dj_jl
//  Huge work on Strife: splitting, merging, implementing stuff, etc.
//
//  Revision 1.22  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.21  2002/03/16 17:48:58  dj_jl
//  Added PlayerPawn class, beautifucation.
//
//  Revision 1.20  2002/03/09 17:57:03  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.19  2002/02/22 18:00:26  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.18  2002/02/16 16:21:49  dj_jl
//  Added line teleporters
//
//  Revision 1.17  2002/02/14 19:21:00  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.16  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.15  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.14  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.13  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.12  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.11  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.10  2002/01/11 18:19:43  dj_jl
//  Started to use names in progs
//
//  Revision 1.9  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.8  2001/12/27 17:52:24  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.7  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/09/25 17:12:09  dj_jl
//  Switched to Hexen map format, special thinker classes
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
