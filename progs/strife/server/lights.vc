//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Light specials
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define STROBEBRIGHT		5
#define FASTDARK			15
#define SLOWDARK			35

// CONSTANTS ---------------------------------------------------------------

enum
{
	LIGHTEV_Fade,
	LIGHTEV_Glow,
	LIGHTEV_Flicker,
	LIGHTEV_Strobe
};

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

int PhaseTable[64] = {
	128, 112, 96, 80, 64, 48, 32, 32,
	16, 16, 16, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 16, 16, 16,
	32, 32, 48, 64, 80, 96, 112, 128
};

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  P_SpawnFireFlicker
//
//==========================================================================

void P_SpawnFireFlicker(sector_t* sector)
{
	FireFlicker Flick;

	Flick = NewSpecialThinker(FireFlicker);
	Flick.Init(sector);
}

//==========================================================================
//
//  P_SpawnGlowingLight
//
//  Spawn glowing light
//
//==========================================================================

void P_SpawnGlowingLight(sector_t* sector)
{
	GlowingLight G;

	G = NewSpecialThinker(GlowingLight);
	G.Init(sector);
}

//==========================================================================
//
//  P_SpawnLightFlash
//
//==========================================================================

void P_SpawnLightFlash(sector_t* sector)
{
	LightFlash Flash;

	Flash = NewSpecialThinker(LightFlash);
	Flash.Init(sector);
}

//==========================================================================
//
//  P_SpawnStrobeFlash
//
//==========================================================================

void P_SpawnStrobeFlash(sector_t* sector, int fastOrSlow, int maxtime,
	int inSync)
{
	Strobe Flash;

	Flash = NewSpecialThinker(Strobe);
	Flash.Init(sector, fastOrSlow, maxtime, inSync);
}

//==========================================================================
//
//  EV_StartLightStrobing
//
//  Start strobing lights (usually from a trigger)
//
//==========================================================================

int EV_StartLightStrobing(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			Ret;
	int			SecNum;
	sector_t*	Sec;
	Strobe		Flash;

	Ret = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		if (Sec->LightingData)
			continue;

		Ret = true;
		Flash = NewSpecialThinker(Strobe);
		Flash.Init(Sec, Arg3, Arg2, Arg4);
	}
	return Ret;
}

//**************************************************************************
//
//  TURN LINE'S TAG LIGHTS ON / OFF
//
//**************************************************************************

//==========================================================================
//
//  EV_TagLightTurnOn
//
//==========================================================================

int EV_TagLightTurnOn(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	int			j;
	sector_t*	TSec;
	int			Max;

	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Max = 0;
		for (j = 0; j < Sec->linecount; j++)
		{
			TSec = getNextSector(Sec->lines[j], Sec);
			if (!TSec)
				continue;
			if (TSec->params.lightlevel > Max)
				Max = TSec->params.lightlevel;
		}
		Sec->params.lightlevel = Max;
	}
	return 1;
}

//==========================================================================
//
//  EV_TurnTagLightsOff
//
//==========================================================================

int EV_TurnTagLightsOff(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	int			i;
	int			Min;
	sector_t*	TSec;

	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Min = Sec->params.lightlevel;
		for (i = 0; i < Sec->linecount; i++)
		{
			TSec = getNextSector(Sec->lines[i], Sec);
			if (!TSec)
				continue;
			if (TSec->params.lightlevel < Min)
				Min = TSec->params.lightlevel;
		}
		Sec->params.lightlevel = Min;
	}
	return 1;
}

//============================================================================
//
//  EV_LightRaiseByValue
//
//============================================================================

bool EV_LightRaiseByValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Sec->params.lightlevel += Arg2;
		if (Sec->params.lightlevel > 255)
		{
			Sec->params.lightlevel = 255;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//  EV_LightLowerByValue
//
//============================================================================

bool EV_LightLowerByValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Sec->params.lightlevel -= Arg2;
		if (Sec->params.lightlevel < 0)
		{
			Sec->params.lightlevel = 0;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//	EV_LightChangeToValue
//
//============================================================================

bool EV_LightChangeToValue(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Sec->params.lightlevel = Arg2;
		if (Sec->params.lightlevel < 0)
		{
			Sec->params.lightlevel = 0;
		}
		else if (Sec->params.lightlevel > 255)
		{
			Sec->params.lightlevel = 255;
		}
		Rtn = true;
	}
	return Rtn;
}

//============================================================================
//
//  EV_SpawnLight
//
//============================================================================

bool EV_SpawnLight(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type)
{
	LightEffect	Light;
	sector_t*	Sec;
	int			SecNum;
	bool		Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Light = NewSpecialThinker(LightEffect);
		Light.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		Rtn = true;
	}
	return Rtn;
}

//==========================================================================
//
//	P_SpawnPhasedLight
//
//==========================================================================

void P_SpawnPhasedLight(sector_t * sector, int base, int index)
{
	PhasedLight Phase;

	Phase = NewSpecialThinker(PhasedLight);
	Phase.Init(sector, base, index);
}

//==========================================================================
//
// P_SpawnLightSequence
//
//==========================================================================

void P_SpawnLightSequence(sector_t * sector, float indexStep)
{
	sector_t *sec;
	sector_t *nextSec;
	sector_t *tempSec;
	int seqSpecial;
	int i;
	float count;
	float index;
	float indexDelta;
	int base;

	seqSpecial = SECSPEC_LightSequence;	// look for Light_Sequence, first
	sec = sector;
	count = 1.0;
	do
	{
		nextSec = NULL;
		//	Make sure that the search doesn't back up.
		sec->special = (sec->special & ~SECSPEC_BASE_MASK) |
			SECSPEC_LightSequenceStart;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) == seqSpecial)
			{
				if (seqSpecial == SECSPEC_LightSequence)
				{
					seqSpecial = SECSPEC_LightSequenceAlt;
				}
				else
				{
					seqSpecial = SECSPEC_LightSequence;
				}
				nextSec = tempSec;
				count += 1.0;
			}
		}
		sec = nextSec;
	}
	while (sec);

	sec = sector;
	count *= indexStep;
	index = 0.0;
	indexDelta = 64.0 / count;
	base = sector->params.lightlevel;
	do
	{
		nextSec = NULL;
		if (sec->params.lightlevel)
		{
			base = sec->params.lightlevel;
		}
		P_SpawnPhasedLight(sec, base, ftoi(index));
		//	Clear sector special.
		sec->special &= ~SECSPEC_BASE_MASK;
		index += indexDelta;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) ==
				SECSPEC_LightSequenceStart)
			{
				nextSec = tempSec;
			}
		}
		sec = nextSec;
	}
	while (sec);
}

//==========================================================================
//
//	EV_LightStop
//
//==========================================================================

bool EV_LightStop(int Tag)
{
	Lighting		L;

	FOREACH(Lighting, L)
	{
		if (L.Sector->tag == Tag)
		{
			if (L.Sector->LightingData == L)
				L.Sector->LightingData = none;
			RemoveSpecialThinker(L);
		}
	}
	return true;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.21  2005/03/16 15:04:43  dj_jl
//  More work on line specials.
//
//  Revision 1.20  2005/03/01 14:39:33  dj_jl
//  Big update of line specials.
//
//  Revision 1.19  2005/01/20 08:15:09  dj_jl
//  Fixed endless loop of phased lights.
//
//  Revision 1.18  2004/11/22 07:36:29  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.17  2002/11/02 08:22:38  dj_jl
//  New style classes.
//
//  Revision 1.16  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.15  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.14  2002/06/29 15:55:42  dj_jl
//  Fixed static lights, beautification.
//
//  Revision 1.13  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.12  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.11  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.9  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.8  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.6  2001/10/22 17:23:11  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/09 17:33:29  dj_jl
//  Moved static light sources into games
//
//  Revision 1.4  2001/09/24 17:13:25  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
