//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//**************************************************************************
//
//  USE LINES
//
//**************************************************************************

Actor usething;
TVec useDir;

//==========================================================================
//
//  PTR_UseTraverse
//
//==========================================================================

bool PTR_UseTraverse(intercept_t * in)
{
	line_t* line;
	float pheight;
	TVec hit_point;
	opening_t *open;

	line = in->line;
	if (!line->special || (GET_SPAC(line->flags) != SPAC_USE &&
		GET_SPAC(line->flags) != SPAC_USETHROUGH))
	{
		hit_point = usething.Origin + (USERANGE * in->frac) * useDir;
		open = LineOpenings(line, hit_point);
		open = FindOpening(open, hit_point.z + usething.Height / 2.0,
			hit_point.z + usething.Height);
		if (!open)
		{
			if (usething.bIsPlayer)
			{
				if (usething.Player.MorphTime)
				{
					usething.PlaySound('PigActive1', CHAN_VOICE);
				}
				else
				{
					usething.PlaySound('*usefail', CHAN_VOICE);
				}
			}
			return false;	// can't use through a wall
		}
		if (usething.bIsPlayer)
		{
			pheight = usething.Origin.z + usething.Height / 2.0;
			if ((open->top < pheight) || (open->bottom > pheight))
			{
				if (usething.Player.MorphTime)
				{
					usething.PlaySound('PigActive1', CHAN_VOICE);
				}
				else
				{
					usething.PlaySound('*usefail', CHAN_VOICE);
				}
			}
		}
		return true;	// not a special line, but keep checking
	}

	if (PointOnPlaneSide(usething.Origin, line) == 1)
	{
		//	Don't use back side unless it's a two-sided line.
		return line->backsector != NULL;
	}

	P_ActivateLine(line, usething, 0, SPAC_USE);

	//WAS can't use more than one special line in a row
	//jff 3/21/98 NOW multiple use allowed with enabling line flag
	return GET_SPAC(line->flags) == SPAC_USETHROUGH;
}

//==========================================================================
//
//  P_UseLines
//
//  Looks for special lines in front of the player to activate.
//
//==========================================================================

void P_UseLines(Player player)
{
	float x1;
	float y1;
	float x2;
	float y2;

	usething = player.MO;

	AngleVector(&player.MO.Angles, &useDir);
	x1 = player.MO.Origin.x;
	y1 = player.MO.Origin.y;
	x2 = x1 + USERANGE * useDir.x;
	y2 = y1 + USERANGE * useDir.y;
	P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES, 'PTR_UseTraverse');
}

//**************************************************************************
//
//  USING A PUZZLE ITEM
//
//**************************************************************************

#define USE_PUZZLE_ITEM_SPECIAL 129

Actor PuzzleItemUser;
int PuzzleItemType;
bool PuzzleActivated;
TVec PuzzleUseDir;

//==========================================================================
//
// PTR_PuzzleItemTraverse
//
//==========================================================================

bool PTR_PuzzleItemTraverse(intercept_t * in)
{
	Actor mobj;
	TVec hit_point;
	opening_t *open;

	if (in->bIsALine)
	{
		// Check line
		hit_point =
			PuzzleItemUser.Origin + (USERANGE * in->frac) * PuzzleUseDir;
		if (in->line->special != USE_PUZZLE_ITEM_SPECIAL)
		{
			open = LineOpenings(in->line, hit_point);
			if (!open || open->range <= 0.0)
			{
				if (PuzzleItemUser.bIsPlayer)
				{
					PuzzleItemUser.PlaySound('*puzzfail', CHAN_VOICE);
				}
				return false;	// can't use through a wall
			}
			return true;	// Continue searching
		}
		if (PointOnPlaneSide(PuzzleItemUser.Origin, in->line) == 1)
		{
			// Don't use back sides
			return false;
		}
		if (PuzzleItemType != in->line->arg1)
		{
			// Item type doesn't match
			return false;
		}
		StartACS(in->line->arg2, 0, in->line->arg3, in->line->arg4,
			in->line->arg5, PuzzleItemUser, in->line, 0, false, false);
		in->line->special = 0;
		PuzzleActivated = true;
		return false;	// Stop searching
	}
	// Check thing
	mobj = Actor(in->Thing);
	if (mobj.Special != USE_PUZZLE_ITEM_SPECIAL)
	{
		// Wrong special
		return true;
	}
	if (PuzzleItemType != mobj.Args[0])
	{
		// Item type doesn't match
		return true;
	}
	StartACS(mobj.Args[1], 0, mobj.Args[2], mobj.Args[3], mobj.Args[4],
		PuzzleItemUser, NULL, 0, false, false);
	mobj.Special = 0;
	PuzzleActivated = true;
	return false;	// Stop searching
}

//==========================================================================
//
//  P_UsePuzzleItem
//
//  Returns true if the puzzle item was used on a line or a thing.
//
//==========================================================================

bool P_UsePuzzleItem(Player player, int itemType)
{
	float x1, y1, x2, y2;

	PuzzleItemType = itemType;
	PuzzleItemUser = player.MO;
	PuzzleActivated = false;
	AngleVector(&player.MO.Angles, &PuzzleUseDir);
	x1 = player.MO.Origin.x;
	y1 = player.MO.Origin.y;
	x2 = x1 + USERANGE * PuzzleUseDir.x;
	y2 = y1 + USERANGE * PuzzleUseDir.y;
	P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS,
		'PTR_PuzzleItemTraverse');
	return PuzzleActivated;
}

//**************************************************************************
//
//  AIMING
//
//**************************************************************************

Actor aim_thing;

// Height if not aiming up or down
// ???: use slope for monsters?
float aim_z;
float aim_range;
float aim_slope;
TVec aim_dir;
float aim_topslope;
float aim_bottomslope;	// slopes to top and bottom of target
float aim_range2d;

//==========================================================================
//
//  PTR_AimTraverse
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================

bool PTR_AimTraverse(intercept_t * in)
{
	line_t *li;
	Actor th;
	float thingtopslope;
	float thingbottomslope;
	float dist;
	float slope;
	opening_t *open;

	if (in->bIsALine)
	{
		TVec hit_point;

		li = in->line;

		if (!(li->flags & ML_TWOSIDED))
			return false;	// stop

		// Crosses a two sided line.
		// A two sided line will restrict
		// the possible target ranges.
		dist = aim_range * in->frac;
		hit_point = aim_thing.Origin + dist * aim_dir;
		open = LineOpenings(li, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z);

		if (!open || open->bottom >= open->top)
			return false;	// stop

		dist = aim_range2d * in->frac;
		if (li->frontsector->floorheight != li->backsector->floorheight)
		{
			slope = (open->bottom - aim_z) / dist;
			if (slope > aim_bottomslope)
				aim_bottomslope = slope;
		}

		if (li->frontsector->ceilingheight != li->backsector->ceilingheight)
		{
			slope = (open->top - aim_z) / dist;
			if (slope < aim_topslope)
				aim_topslope = slope;
		}

		if (aim_topslope <= aim_bottomslope)
			return false;	// stop

		return true;	// shot continues
	}

	// shoot a thing
	th = Actor(in->Thing);
	if (th == aim_thing)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	if (th.bIsPlayer && netgame && !deathmatch)
	{
		// don't aim at fellow co-op players
		return true;
	}

	// check angles to see if the thing can be aimed at
	dist = aim_range2d * in->frac;
	thingtopslope = (th.Origin.z + th.Height - aim_z) / dist;

	if (thingtopslope < aim_bottomslope)
		return true;	// shot over the thing

	thingbottomslope = (th.Origin.z - aim_z) / dist;

	if (thingbottomslope > aim_topslope)
		return true;	// shot under the thing

	// this thing can be hit!
	if (thingtopslope > aim_topslope)
		thingtopslope = aim_topslope;

	if (thingbottomslope < aim_bottomslope)
		thingbottomslope = aim_bottomslope;

	aim_slope = (thingtopslope + thingbottomslope) / 2.0;
	linetarget = th;

	return false;	// don't go any farther
}

//==========================================================================
//
//  AimLineAttack
//
//==========================================================================

void AimLineAttack(Actor t1, TAVec * angles, float distance)
{
	float x2;
	float y2;
	float topangle;
	float botangle;

	aim_thing = t1;

	AngleVector(angles, &aim_dir);
	x2 = t1.Origin.x + distance * aim_dir.x;
	y2 = t1.Origin.y + distance * aim_dir.y;
	aim_z = t1.Origin.z + t1.Height / 2.0 + 8.0 - t1.FloorClip;
	aim_range2d =
		Length(vector(distance * aim_dir.x, distance * aim_dir.y, 0.0));

	// can't shoot outside view angles
	topangle = AngleMod180(-angles->pitch + 30.0);
	botangle = AngleMod180(-angles->pitch - 30.0);
	if (topangle > 89.0)
		topangle = 89.0;
	if (botangle < -89.0)
		botangle = -89.0;
	aim_topslope = tan(topangle);
	aim_bottomslope = tan(botangle);

	aim_range = distance;
	linetarget = none;

	P_PathTraverse(t1.Origin.x, t1.Origin.y, x2, y2,
		PT_ADDLINES | PT_ADDTHINGS, 'PTR_AimTraverse');

	if (linetarget)
	{
		angles->pitch = -atan(aim_slope);
	}
}

//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

Actor shoot_thing;
float shoot_range;
TVec shoot_origin;
TVec shoot_dir;
int la_damage;

//==========================================================================
//
//  ShootHitPlane
//
//==========================================================================

bool ShootHitPlane(sec_plane_t * plane)
{
	float org_dist;
	float hit_dist;

	if (plane->flags & SPF_NOBLOCKSHOOT)
	{
		//  Doesn't block shooting
		return true;
	}
	org_dist = DotProduct(linestart, plane->normal) - plane->dist;
	if (org_dist < 0.0)
	{
		//  Don't shoot back side
		return true;
	}
	hit_dist = DotProduct(lineend, plane->normal) - plane->dist;
	if (hit_dist >= 0.0)
	{
		//  Didn't hit plane
		return true;
	}

	//  Hit plane
	if (plane->pic == skyflatnum)
	{
		// don't shoot the sky!
		return false;
	}

	//  If we are shooting floor or ceiling we are adjusting position
	// to spawn puff on floor or ceiling, not on wall
	lineend -= (lineend - linestart) * hit_dist / (hit_dist - org_dist);

	// position a bit closer
	lineend += 4.0 * plane->normal;

	// Spawn bullet puffs.
	SpawnPuff(lineend);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================

bool ShootCheckPlanes(sector_t * sec)
{
	sec_region_t *reg;
	sec_region_t *startreg;

	startreg = PointInRegion(sec, linestart);
	for (reg = startreg; reg; reg = reg->next)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	for (reg = startreg->prev; reg; reg = reg->prev)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  PTR_ShootTraverse
//
//==========================================================================

bool PTR_ShootTraverse(intercept_t * in)
{
	TVec hit_point;
	line_t *li;
	Actor th;

	if (in->bIsALine)
	{
		sector_t *sec;

		li = in->line;
		hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;
		if (li->flags & ML_TWOSIDED && PointOnPlaneSide(shoot_origin, li))
		{
			sec = li->backsector;
		}
		else
		{
			sec = li->frontsector;
		}

		lineend = hit_point;

		//  Check for shooting floor or ceiling
		if (!ShootCheckPlanes(sec))
		{
			return false;
		}

		linestart = lineend;

		//  Execute line special after checking for hitting floor or ceiling
		// when we know that it actally hits line
		if (li->special)
		{
			P_ActivateLine(li, shoot_thing, 0, SPAC_IMPACT);
		}

		if (li->flags & ML_TWOSIDED)
		{
			// crosses a two sided line
			opening_t *open;
			float opentop = 0.0;

			open = LineOpenings(li, hit_point);
			if (open)
			{
				opentop = open->top;
			}
			while (open)
			{
				if (open->bottom <= hit_point.z && open->top >= hit_point.z)
				{
					// shot continues
					return true;
				}
				open = open->next;
			}
			if (li->frontsector->ceiling.pic == skyflatnum &&
				li->backsector->ceiling.pic == skyflatnum &&
				hit_point.z > opentop)
			{
				// it's a sky hack wall
				return false;
			}
		}

		//  Hit line

		// position a bit closer
		hit_point -= 4.0 * shoot_dir;

		// Spawn bullet puffs.
		SpawnPuff(hit_point);

		// don't go any farther
		return false;
	}

	// shoot a thing
	th = Actor(in->Thing);

	if (th == shoot_thing)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	// check angles to see if the thing can be aimed at
	hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;

	if (th.Origin.z + th.Height < hit_point.z)
		return true;	// shot over the thing

	if (th.Origin.z > hit_point.z)
		return true;	// shot under the thing

	// hit thing
	// position a bit closer
	hit_point -= 10.0 * shoot_dir;

	SpawnPuff(hit_point);
	if (la_damage)
	{
		if (!th.bNoBlood && !th.bInvulnerable)
		{
			if (PuffType == AxePuff || PuffType == AxePuffGlow)
			{
				th.SpawnBloodSplatter2(hit_point);
			}
			if (P_Random() < 192)
			{
				MSG_Select(MSG_SV_DATAGRAM);
				MSG_WriteByte(svc_blood);
				MSG_WriteShort(ftoi(hit_point.x));
				MSG_WriteShort(ftoi(hit_point.y));
				MSG_WriteShort(ftoi(hit_point.z));
				MSG_WriteByte(la_damage > 255 ? 255 : la_damage);

				th.SpawnBloodSplatter(hit_point);
			}
		}
		if (PuffType == FlamePuff2)
		{
			// Cleric FlameStrike does fire damage
			th.Damage(GLavaInflictor, shoot_thing, la_damage);
		}
		else
		{
			th.Damage(shoot_thing, shoot_thing, la_damage);
		}
	}

	// don't go any farther
	return false;
}

//==========================================================================
//
//  LineAttack
//
//  If damage == 0, it is just a test trace that will leave linetarget set.
//
//==========================================================================

int LineAttack(Actor t1, TVec dir, float distance, int damage)
{
	TVec dst;

	shoot_thing = t1;
	la_damage = damage;

	shoot_origin = t1.Origin;
	shoot_origin.z += t1.Height * 0.5 + 8.0 - t1.FloorClip;

	shoot_dir = dir;
	shoot_range = distance;

	dst = shoot_origin + shoot_range * shoot_dir;
	linestart = shoot_origin;
	if (!P_PathTraverse(t1.Origin.x, t1.Origin.y, dst.x, dst.y,
			PT_ADDLINES | PT_ADDTHINGS, 'PTR_ShootTraverse'))
	{
		return false;
	}
	lineend = dst;
	return ShootCheckPlanes(GLevel.PointInSector(dst));
}

//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

Actor bombsource;
Actor bombspot;
int bombdamage;
float bombdistance;
bool DamageSource;

//==========================================================================
//
//  PIT_RadiusAttack
//
//  "bombsource" is the creature that caused the explosion at "bombspot".
//
//==========================================================================

bool PIT_RadiusAttack(Entity Other)
{
	float dist;
	int damage;

	if (!Actor(Other).bShootable)
	{
		return true;
	}
//  if (Other.Flags2 & MF2_BOSS)
//  {
//		// Bosses take no damage from PIT_RadiusAttack
//      return true;
//  }
	if (!DamageSource && Other == bombsource)
	{
		// don't damage the source of the explosion
		return true;
	}
#if 0
	if (abs(ftoi(Other.Origin.z - bombspot.Origin.z)) > 2 * bombdistance)
	{
		// too high/low
		return true;
	}
#endif
	dist = Length(MobjCenter(Other) - MobjCenter(bombspot)) - Other.Radius;
	if (dist < 0.0)
	{
		dist = 0.0;
	}
	if (dist >= bombdistance)
	{
		// Out of range
		return true;
	}
	if (Actor(Other).CanSee(bombspot))
	{
		// OK to damage, target is in direct path
		damage = (bombdamage * ftoi(bombdistance - dist) /
			ftoi(bombdistance)) + 1;
		if (Other.bIsPlayer)
		{
			damage >>= 2;
		}
		Actor(Other).Damage(bombspot, bombsource, damage);
	}
	return true;
}

//==========================================================================
//
//  P_RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//==========================================================================

void P_RadiusAttack(Actor spot, Actor source, int damage,
	float distance, bool damageSource)
{
	int x, y, xl, xh, yl, yh;

	yh = MapBlock(spot.Origin.y + distance - spot.XLevel.BlockMapOrgY);
	yl = MapBlock(spot.Origin.y - distance - spot.XLevel.BlockMapOrgY);
	xh = MapBlock(spot.Origin.x + distance - spot.XLevel.BlockMapOrgX);
	xl = MapBlock(spot.Origin.x - distance - spot.XLevel.BlockMapOrgX);
	bombspot = spot;
	bombsource = source;
	bombdamage = damage;
	bombdistance = distance;
	DamageSource = damageSource;
	for (y = yl; y <= yh; y++)
	{
		for (x = xl; x <= xh; x++)
		{
			P_BlockThingsIterator(x, y, 'PIT_RadiusAttack');
		}
	}
}

//**************************************************************************
//
//
//
//**************************************************************************

Actor tsthing;

//==========================================================================
//
//  PIT_ThrustStompThing
//
//==========================================================================

bool PIT_ThrustStompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
		return true;

	blockdist = Other.Radius + tsthing.Radius;
	if (fabs(Other.Origin.x - tsthing.Origin.x) >= blockdist ||
		fabs(Other.Origin.y - tsthing.Origin.y) >= blockdist ||
		(Other.Origin.z > tsthing.Origin.z + tsthing.Height))
	{
		return true;	// didn't hit it
	}

	if (Other == tsthing)
		return true;	// don't clip against self

	Actor(Other).Damage(tsthing, tsthing, 10001);
	tsthing.Args[1] = 1;	// Mark thrust thing as bloody

	return true;
}

//==========================================================================
//
//  PIT_ThrustSpike
//
//==========================================================================

void PIT_ThrustSpike(Actor actor)
{
	int xl, xh, yl, yh, bx, by;
	float x0, x2, y0, y2;

	tsthing = actor;

	x0 = actor.Origin.x - actor.Radius;
	x2 = actor.Origin.x + actor.Radius;
	y0 = actor.Origin.y - actor.Radius;
	y2 = actor.Origin.y + actor.Radius;

	xl = MapBlock(x0 - actor.XLevel.BlockMapOrgX - MAXRADIUS);
	xh = MapBlock(x2 - actor.XLevel.BlockMapOrgX + MAXRADIUS);
	yl = MapBlock(y0 - actor.XLevel.BlockMapOrgY - MAXRADIUS);
	yh = MapBlock(y2 - actor.XLevel.BlockMapOrgY + MAXRADIUS);

	// stomp on any things contacted
	for (bx = xl; bx <= xh; bx++)
		for (by = yl; by <= yh; by++)
			P_BlockThingsIterator(bx, by, 'PIT_ThrustStompThing');
}

//**************************************************************************
//
//  $Log$
//  Revision 1.36  2005/11/19 15:15:08  dj_jl
//  Renamed sounds.
//
//  Revision 1.35  2005/09/29 17:17:22  dj_jl
//  Fix for using a puzzle item.
//
//  Revision 1.34  2005/03/28 07:44:09  dj_jl
//  Some Boom line specials and other improvements.
//
//  Revision 1.33  2004/12/22 07:54:42  dj_jl
//  More extended ACS support, more linedef flags.
//
//  Revision 1.32  2003/11/12 16:50:47  dj_jl
//  Changed player structure into a class
//
//  Revision 1.31  2002/11/02 08:24:10  dj_jl
//  New style classes.
//
//  Revision 1.30  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.29  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.28  2002/07/13 08:01:49  dj_jl
//  Moved some functions to the Entity class.
//
//  Revision 1.27  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.26  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.25  2002/03/16 17:47:46  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.24  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.23  2002/03/02 18:00:15  dj_jl
//  Some smaller changes, beautification.
//
//  Revision 1.22  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.21  2002/02/22 18:00:22  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.20  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.19  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.18  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.17  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.16  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.15  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.14  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.13  2002/01/15 08:10:57  dj_jl
//  Added P_CheckRelPosition
//
//  Revision 1.12  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.11  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.10  2001/12/01 18:14:09  dj_jl
//  Changed MSG_Select, beautification
//
//  Revision 1.9  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.8  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.7  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/09/27 17:12:14  dj_jl
//  Changed LavaInflictor to pointer
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
