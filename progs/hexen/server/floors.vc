//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	FLEV_LOWERFLOOR,	// lower floor to highest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,	// lower floor to lowest surrounding floor
	FLEV_LOWERFLOORBYVALUE,
	FLEV_RAISEFLOOR,	// raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOORTONEAREST,	// raise floor to next highest surrounding floor
	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORCRUSH,
	FLEV_RAISEBYVALUETIMES8,
	FLEV_LOWERBYVALUETIMES8,
	FLEV_LOWERTIMES8INSTANT,
	FLEV_RAISETIMES8INSTANT,
	FLEV_MOVETOVALUETIMES8
};

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t * line, int *args, int floortype)
{
	int secnum;
	int rtn;
	sector_t *sec;
	FloorMover Floor;

	rtn = 0;
	for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
		secnum = FindSectorFromTag(args[0], secnum))
	{
		sec = &GLevel.Sectors[secnum];

		//      ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->SpecialData)
			continue;

		//
		//      new floor thinker
		//
		rtn = 1;
		Floor = NewSpecialThinker(FloorMover);
		sec->SpecialData = Floor;
		Floor.sector = sec;
		Floor.type = floortype;
		Floor.crush = 0;
		Floor.speed = itof(args[1]) * 35.0 / 8.0;//4.0;
		if (floortype == FLEV_LOWERTIMES8INSTANT ||
			floortype == FLEV_RAISETIMES8INSTANT)
		{
			Floor.speed = 32.0 * 2000.0;
		}
		switch (floortype)
		{
		case FLEV_LOWERFLOOR:
			Floor.direction = -1;
			Floor.floordestheight = FindHighestFloorSurrounding(sec);
			break;
		case FLEV_LOWERFLOORTOLOWEST:
			Floor.direction = -1;
			Floor.floordestheight = FindLowestFloorSurrounding(sec);
			break;
		case FLEV_LOWERFLOORBYVALUE:
			Floor.direction = -1;
			Floor.floordestheight = Floor.sector->floorheight -
				itof(args[2]);
			break;
		case FLEV_LOWERTIMES8INSTANT:
		case FLEV_LOWERBYVALUETIMES8:
			Floor.direction = -1;
			Floor.floordestheight = Floor.sector->floorheight -
				itof(args[2]) * 8.0;
			break;
		case FLEV_RAISEFLOORCRUSH:
			Floor.crush = args[2];	// arg[2] = crushing value
			Floor.direction = 1;
			Floor.floordestheight = sec->ceilingheight - 8.0;
			break;
		case FLEV_RAISEFLOOR:
			Floor.direction = 1;
			Floor.floordestheight = FindLowestCeilingSurrounding(sec);
			if (Floor.floordestheight > sec->ceilingheight)
				Floor.floordestheight = sec->ceilingheight;
			break;
		case FLEV_RAISEFLOORTONEAREST:
			Floor.direction = 1;
			Floor.floordestheight =
				FindNextHighestFloor(sec, sec->floorheight);
			break;
		case FLEV_RAISEFLOORBYVALUE:
			Floor.direction = 1;
			Floor.floordestheight = Floor.sector->floorheight +
				itof(args[2]);
			break;
		case FLEV_RAISETIMES8INSTANT:
		case FLEV_RAISEBYVALUETIMES8:
			Floor.direction = 1;
			Floor.floordestheight = Floor.sector->floorheight +
				itof(args[2]) * 8.0;
			break;
		case FLEV_MOVETOVALUETIMES8:
			Floor.floordestheight = itof(args[2]) * 8.0;
			if (args[3])
			{
				Floor.floordestheight = -Floor.floordestheight;
			}
			if (Floor.floordestheight > Floor.sector->floorheight)
			{
				Floor.direction = 1;
			}
			else if (Floor.floordestheight < Floor.sector->floorheight)
			{
				Floor.direction = -1;
			}
			else
			{	// already at lowest position
				rtn = 0;
			}
			break;
		default:
			Error("Invalid floor type.");
			rtn = 0;
			break;
		}
	}
	if (rtn)
	{
		SectorStartSequence(Floor.sector,
			seq_name[SEQ_PLATFORM + Floor.sector->seqType]);
	}
	return rtn;
}

//==========================================================================
//
//  EV_DoFloorAndCeiling
//
//==========================================================================

int EV_DoFloorAndCeiling(line_t * line, int *args, bool raise)
{
	bool floor;
	bool ceiling;
	int secnum;
	sector_t *sec;

	if (raise)
	{
		floor = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUE);
		for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
			secnum = FindSectorFromTag(args[0], secnum))
		{
			sec = &GLevel.Sectors[secnum];
			sec->SpecialData = none;
		}
		ceiling = EV_DoCeiling(line, args, CLEV_RAISEBYVALUE);
	}
	else
	{
		floor = EV_DoFloor(line, args, FLEV_LOWERFLOORBYVALUE);
		for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
			secnum = FindSectorFromTag(args[0], secnum))
		{
			sec = &GLevel.Sectors[secnum];
			sec->SpecialData = none;
		}
		ceiling = EV_DoCeiling(line, args, CLEV_LOWERBYVALUE);
	}
	return floor || ceiling;
}

//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================

int EV_FloorCrushStop(line_t * line, int *args)
{
	FloorMover Floor;
	bool rtn;

	rtn = 0;
	FOREACH(FloorMover, Floor)
	{
		if (Floor.type != FLEV_RAISEFLOORCRUSH)
		{
			continue;
		}
		// Completely remove the crushing floor
		SectorStopSequence(Floor.sector);
		Floor.sector->SpecialData = none;
		TagFinished(Floor.sector->tag);
		RemoveSpecialThinker(Floor);
		rtn = 1;
	}
	return rtn;
}

//**************************************************************************
//
//  STAIRS
//
//**************************************************************************

// ===== Build Stairs Private Data =====

#define STAIR_QUEUE_SIZE        32

enum
{
	STAIRS_NORMAL,
	STAIRS_SYNC,
	STAIRS_PHASED
};

struct stairqueue_t
{
	sector_t *sector;
	int type;
	float height;
};

stairqueue_t StairQueue[STAIR_QUEUE_SIZE];
int StairQueueHead;
int StairQueueTail;

float StairStepDelta;
int StairDirection;
float StairSpeed;
int StairTexture;
float StairStartDelay;
float StairStartDelayDelta;
int StairTextureChange;
float StairStartHeight;

//==========================================================================
//
//  QueueStairSector
//
//==========================================================================

void QueueStairSector(sector_t * sec, int type, float height)
{
	if ((StairQueueTail + 1) % STAIR_QUEUE_SIZE == StairQueueHead)
	{
		Error("BuildStairs:  Too many branches located.");
	}
	StairQueue[StairQueueTail].sector = sec;
	StairQueue[StairQueueTail].type = type;
	StairQueue[StairQueueTail].height = height;

	StairQueueTail = (StairQueueTail + 1) % STAIR_QUEUE_SIZE;
}

//==========================================================================
//
//  DequeueStairSector
//
//==========================================================================

sector_t *DequeueStairSector(int *type, float *height)
{
	sector_t *sec;

	if (StairQueueHead == StairQueueTail)
	{
		// queue is empty
		return NULL;
	}
	*type = StairQueue[StairQueueHead].type;
	*height = StairQueue[StairQueueHead].height;
	sec = StairQueue[StairQueueHead].sector;
	StairQueueHead = (StairQueueHead + 1) % STAIR_QUEUE_SIZE;

	return sec;
}

//==========================================================================
//
//  ProcessStairSector
//
//==========================================================================

void ProcessStairSector(sector_t * sec, int type, float height,
	int stairsType, float delay, float resetDelay)
{
	int i;
	sector_t *tsec;
	StairStepMover StairStep;

	//
	// new stairStep thinker
	//
	height += StairStepDelta;
	StairStep = NewSpecialThinker(StairStepMover);
	sec->SpecialData = StairStep;
	StairStep.direction = StairDirection;
	StairStep.sector = sec;
	StairStep.floordestheight = height;
	switch (stairsType)
	{
	case STAIRS_NORMAL:
		StairStep.speed = StairSpeed;
		if (delay)
		{
			StairStep.delayTotal = delay;
			StairStep.stairsDelayHeight = sec->floorheight + StairStepDelta;
			StairStep.stairsDelayHeightDelta = StairStepDelta;
		}
		StairStep.resetDelay = resetDelay;
		StairStep.resetDelayTime = resetDelay;
		StairStep.resetHeight = sec->floorheight;
		break;
	case STAIRS_SYNC:
		StairStep.speed = StairSpeed * (height - StairStartHeight) / StairStepDelta;
		StairStep.resetDelay = delay;	//arg4
		StairStep.resetDelayTime = delay;
		StairStep.resetHeight = sec->floorheight;
		break;
/*
	case STAIRS_PHASED:
		StairStep.floordestheight = sec->floorheight + StairStepDelta;
		StairStep.speed = StairSpeed;
		StairStep.delayTime = StairStartDelay;
		StairStartDelay += StairStartDelayDelta;
		StairStep.textureChange = StairTextureChange;
		StairStep.resetDelayCount = StairStartDelay;
		break;
*/
	default:
		break;
	}
	SectorStartSequence(sec, seq_name[SEQ_PLATFORM + sec->seqType]);
	//
	// Find next sector to raise
	// Find nearby sector with sector special equal to type
	//
	for (i = 0; i < sec->linecount; i++)
	{
		line_t *line;

		line = sec->lines[i];
		if (!(line->flags & ML_TWOSIDED))
		{
			continue;
		}
		tsec = line->frontsector;
		if ((tsec->special & SECSPEC_BASE_MASK) == type + SECSPEC_StairsSpecial1 &&
			!tsec->SpecialData && tsec->floor.pic == StairTexture &&
			tsec->validcount != *validcount)
		{
			QueueStairSector(tsec, type ^ 1, height);
			tsec->validcount = *validcount;
		}
		tsec = line->backsector;
		if ((tsec->special & SECSPEC_BASE_MASK) == type + SECSPEC_StairsSpecial1 &&
			!tsec->SpecialData && tsec->floor.pic == StairTexture &&
			tsec->validcount != *validcount)
		{
			QueueStairSector(tsec, type ^ 1, height);
			tsec->validcount = *validcount;
		}
	}
}

//==========================================================================
//
//  EV_BuildStairs
//
//  BUILD A STAIRCASE!
//
//  StairDirection is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================

int EV_BuildStairs(line_t * line, int *args, int direction, int stairsType)
{
	int secnum;
	float height;
	float delay;
	float resetDelay;
	sector_t *sec;
	sector_t *qSec;
	int type;

	// Set global stairs variables
	StairTextureChange = 0;
	StairDirection = direction;
	StairStepDelta = itof(StairDirection * args[2]);
	StairSpeed = itof(args[1]) * 4.0;
	resetDelay = itof(args[4]) / 32.0;
	delay = itof(args[3]) / 32.0;
	if (stairsType == STAIRS_PHASED)
	{
		StairStartDelayDelta = itof(args[3]) / 32.0;
		StairStartDelay = StairStartDelayDelta;
		resetDelay = StairStartDelayDelta;
		delay = 0.0;
		StairTextureChange = args[4];
	}

	(*validcount)++;
	for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
		secnum = FindSectorFromTag(args[0], secnum))
	{
		sec = &GLevel.Sectors[secnum];

		StairTexture = sec->floor.pic;
		StairStartHeight = sec->floorheight;

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->SpecialData)
			continue;

		QueueStairSector(sec, 0, sec->floorheight);
		sec->special &= ~SECSPEC_BASE_MASK;
	}
	for (qSec = DequeueStairSector(&type, &height); qSec != NULL;
		qSec = DequeueStairSector(&type, &height))
	{
		ProcessStairSector(qSec, type, height, stairsType, delay, resetDelay);
	}
	return 1;
}

//**************************************************************************
//
//  PILLAR
//
//**************************************************************************

//==========================================================================
//
//  EV_BuildPillar
//
//==========================================================================

int EV_BuildPillar(line_t * line, int *args, bool crush)
{
	int secnum;
	sector_t *sec;
	Pillar pillar;
	float newHeight;
	int rtn;

	rtn = 0;
	for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
		secnum = FindSectorFromTag(args[0], secnum))
	{
		sec = &GLevel.Sectors[secnum];
		if (sec->SpecialData)
			continue;	// already moving
		if (sec->floorheight == sec->ceilingheight)
		{
			// pillar is already closed
			continue;
		}
		rtn = 1;
		if (!args[2])
		{
			newHeight = sec->floorheight +
				((sec->ceilingheight - sec->floorheight) / 2.0);
		}
		else
		{
			newHeight = sec->floorheight + itof(args[2]);
		}

		pillar = NewSpecialThinker(Pillar);
		sec->SpecialData = pillar;
		pillar.sector = sec;
		if (!args[2])
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = pillar.floorSpeed;
		}
		else if (newHeight - sec->floorheight >
			sec->ceilingheight - newHeight)
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = (sec->ceilingheight - newHeight) *
				pillar.floorSpeed / (newHeight - sec->floorheight);
		}
		else
		{
			pillar.ceilingSpeed = itof(args[1]) * 4.0;
			pillar.floorSpeed = (newHeight - sec->floorheight) *
				pillar.ceilingSpeed / (sec->ceilingheight - newHeight);
		}
		pillar.floordest = newHeight;
		pillar.ceilingdest = newHeight;
		pillar.direction = 1;
		pillar.crush = crush * args[3];
		SectorStartSequence(pillar.sector,
			seq_name[SEQ_PLATFORM + pillar.sector->seqType]);
	}
	return rtn;
}

//==========================================================================
//
// EV_OpenPillar
//
//==========================================================================

int EV_OpenPillar(line_t * line, int *args)
{
	int secnum;
	sector_t *sec;
	Pillar pillar;
	int rtn;

	rtn = 0;
	for (secnum = FindSectorFromTag(args[0], -1); secnum >= 0;
		secnum = FindSectorFromTag(args[0], secnum))
	{
		sec = &GLevel.Sectors[secnum];
		if (sec->SpecialData)
			continue;	// already moving
		if (sec->floorheight != sec->ceilingheight)
		{	// pillar isn't closed
			continue;
		}
		rtn = 1;
		pillar = NewSpecialThinker(Pillar);
		sec->SpecialData = pillar;
		pillar.sector = sec;
		if (!args[2])
		{
			pillar.floordest = FindLowestFloorSurrounding(sec);
		}
		else
		{
			pillar.floordest = sec->floorheight - itof(args[2]);
		}
		if (!args[3])
		{
			pillar.ceilingdest = FindHighestCeilingSurrounding(sec);
		}
		else
		{
			pillar.ceilingdest = sec->ceilingheight + itof(args[3]);
		}
		if (sec->floorheight - pillar.floordest >= pillar.ceilingdest -
			sec->ceilingheight)
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = (sec->ceilingheight -
				pillar.ceilingdest) * pillar.floorSpeed /
				(pillar.floordest - sec->floorheight);
		}
		else
		{
			pillar.ceilingSpeed = itof(args[1]) * 4.0;
			pillar.floorSpeed = (pillar.floordest -
				sec->floorheight) * pillar.ceilingSpeed /
				(sec->ceilingheight - pillar.ceilingdest);
		}
		pillar.direction = -1;	// open the pillar
		SectorStartSequence(pillar.sector,
			seq_name[SEQ_PLATFORM + pillar.sector->seqType]);
	}
	return rtn;
}

//**************************************************************************
//
//  FLOOR WAGGLE
//
//**************************************************************************

#define WGLSTATE_EXPAND 1
#define WGLSTATE_STABLE 2
#define WGLSTATE_REDUCE 3

//==========================================================================
//
//  EV_StartFloorWaggle
//
//==========================================================================

bool EV_StartFloorWaggle(int tag, int height, int speed, int offset,
	int timer)
{
	int sectorIndex;
	sector_t *sector;
	FloorWaggle Waggle;
	bool retCode;

	retCode = false;
	for (sectorIndex = FindSectorFromTag(tag, -1); sectorIndex >= 0;
		sectorIndex = FindSectorFromTag(tag, sectorIndex))
	{
		sector = &GLevel.Sectors[sectorIndex];
		if (sector->SpecialData)
		{
			// Already busy with another thinker
			continue;
		}
		retCode = true;
		Waggle = NewSpecialThinker(FloorWaggle);
		sector->SpecialData = Waggle;
		Waggle.sector = sector;
		Waggle.originalHeight = sector->floor.dist;
		Waggle.accumulator = itof(offset);
		Waggle.accSpeed = itof(speed) / 2.0;
		Waggle.scale = 0.0;
		Waggle.targetScale = itof(height) / 64.0;
		Waggle.scaleSpeed = Waggle.targetScale
			/ (1.0 + 3.0 * itof(height) / 255.0);
		Waggle.timer = timer ? itof(timer) : -1.0;
		Waggle.state = WGLSTATE_EXPAND;
	}
	return retCode;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.17  2004/11/22 07:36:28  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.16  2002/11/02 08:24:10  dj_jl
//  New style classes.
//
//  Revision 1.15  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.14  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.13  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.12  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.11  2002/01/29 18:16:19  dj_jl
//  Adjusted speed to fix timing
//
//  Revision 1.10  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.9  2002/01/12 18:02:48  dj_jl
//  Replaced some C style casts with dynamic casts
//
//  Revision 1.8  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/18 18:31:01  dj_jl
//  Added class SectorThinker
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/09/25 17:13:50  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/24 17:17:17  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
