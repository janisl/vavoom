//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class VerticalDoor : SectorMover;

int			Type;
float		TopHeight;
float		Speed;
int			Direction;	// 1 = up, 0 = waiting at top, -1 = down
float		TopWait;	// tics to wait at the top (keep in case a door going down is reset)
float		TopTime;	// when it reaches 0, start going down

float		BotDist;
float		OldFloorDist;

TVec		BotSpot;

int			LightTag;

//==========================================================================
//
//	Init
//
//==========================================================================

void Init(sector_t* InSector, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int InType)
{
	float		Height;
	TVec		Spot;

	sector = InSector;
	sector->SpecialData = self;

	Type = InType;
	Speed = itof(Arg2) * 35.0 / 8.0;
	TopWait = itof(Arg3) / 35.0;
	switch (Type)
	{
	case DOOREV_Close:
		Height = FindLowestCeilingSurrounding(sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(sector->ceiling.normal, Spot);
		Direction = -1;
		SectorStartSequence(sector, seq_name[SEQ_DOOR_STONE +
			sector->seqType]);
		break;

	case DOOREV_CloseWaitOpen:
		LightTag = Arg4;
		TopHeight = sector->ceiling.dist;
		TopWait *= 4.0;
		Direction = -1;
		SectorStartSequence(sector, seq_name[SEQ_DOOR_STONE +
			sector->seqType]);
		break;

	case DOOREV_Raise:
	case DOOREV_RaiseLocked:
	case DOOREV_Open:
		//	Get light tag depending on type.
		if (Type == DOOREV_Open)
		{
			LightTag = Arg3;
		}
		else if (Type == DOOREV_Raise)
		{
			LightTag = Arg4;
		}
		else
		{
			LightTag = Arg5;
			Type = DOOREV_Raise;
		}

		//HACK delay 0 means open
		if (Type == DOOREV_Raise && !Arg3)
		{
			Type = DOOREV_Open;
		}

		Height = FindLowestCeilingSurrounding(sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(sector->ceiling.normal, Spot);
		Direction = 1;
		SectorStartSequence(sector, seq_name[SEQ_DOOR_STONE +
			sector->seqType]);
		break;

	case DOOREV_RaiseIn5Mins:
		Direction = 2;
		Height = FindLowestCeilingSurrounding(sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(sector->ceiling.normal, Spot);
		TopTime = 5.0 * 60.0;
		break;
	}

	Height = FindHighestFloorPoint(sector, &BotSpot);
	BotDist = DotProduct(vector(BotSpot.x, BotSpot.y, Height),
		sector->ceiling.normal);
	OldFloorDist = sector->floor.dist;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	int res;

	if (sector->floor.dist != OldFloorDist)
	{
		OldFloorDist = sector->floor.dist;
		BotDist = DotProduct(sector->ceiling.normal, vector(BotSpot.x,
			BotSpot.y, GetPlanePointZ(&sector->floor, BotSpot)));
	}

	switch (Direction)
	{
	case 0:	// WAITING
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = -1;	// time to go back down
				SectorStartSequence(sector,
					seq_name[SEQ_DOOR_STONE + sector->seqType]);
				break;
			case DOOREV_CloseWaitOpen:
				Direction = 1;
				SectorStartSequence(sector,
					seq_name[SEQ_DOOR_STONE + sector->seqType]);
				break;
			default:
				break;
			}
		break;

	case 2:
		//  INITIAL WAIT
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
		{
			TopTime = 0.0;
			switch (Type)
			{
			case DOOREV_RaiseIn5Mins:
				Direction = 1;
				Type = DOOREV_Raise;
				SectorStartSequence(sector,
					seq_name[SEQ_DOOR_STONE + sector->seqType]);
				break;
			}
		}
		break;

	case -1:	// DOWN
		res = MovePlane(sector, Speed * deltaTime, BotDist, false, 1,
			Direction, false);

		// killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (sector->ceiling.dist +
				sector->floor.dist) / (TopHeight + sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			SectorStopSequence(sector);
			switch (Type)
			{
			case DOOREV_Raise:
			case DOOREV_Close:
				sector->SpecialData = none;
				TagFinished(sector->tag);
				RemoveSpecialThinker(self);	// unlink and free
				break;
			case DOOREV_CloseWaitOpen:
				Direction = 0;
				TopTime = TopWait;
				break;
			default:
				break;
			}
		}
		else if (res == RES_CRUSHED)
		{
			switch (Type)
			{
			case DOOREV_Close:	// DON'T GO BACK UP!
				break;
			default:
				Direction = 1;
				break;
			}
		}
		break;

	case 1:	// UP
		res = MovePlane(sector, Speed * deltaTime, TopHeight, false, 1,
			Direction, false);

		//	killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (sector->ceiling.dist +
				sector->floor.dist) / (TopHeight + sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			SectorStopSequence(sector);
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = 0;	// wait at top
				TopTime = TopWait;
				break;
			case DOOREV_Open:
			case DOOREV_CloseWaitOpen:
				sector->SpecialData = none;
				TagFinished(sector->tag);
				RemoveSpecialThinker(self);	// unlink and free
				break;
			default:
				break;
			}
		}
		break;
	}
}

defaultproperties
{
}

//**************************************************************************
//
//  $Log$
//  Revision 1.3  2005/01/25 17:45:15  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.2  2004/11/22 07:36:27  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.1  2002/10/26 16:32:27  dj_jl
//  New style of defining classes.
//
//**************************************************************************
